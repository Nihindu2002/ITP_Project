import { jsx as g, jsxs as R, Fragment as le } from "react/jsx-runtime";
import * as y from "react";
import ve, { createRef as yy, memo as by, createContext as gs, createElement as Cy, version as Xu, useContext as ys, useState as Xr, useLayoutEffect as bs, useEffect as Zt, useDebugValue as Nh, useRef as Nt, forwardRef as vy, useCallback as Pn } from "react";
import * as sc from "react-dom";
import Ih, { flushSync as wy, createPortal as Lh } from "react-dom";
var Lo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dh(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Do = { exports: {} }, il = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qu;
function Sy() {
  if (Qu) return il;
  Qu = 1;
  var t = ve;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, o = t.useEffect, i = t.useLayoutEffect, s = t.useDebugValue;
  function l(d, f) {
    var h = f(), p = r({ inst: { value: h, getSnapshot: f } }), m = p[0].inst, b = p[1];
    return i(
      function() {
        m.value = h, m.getSnapshot = f, a(m) && b({ inst: m });
      },
      [d, h, f]
    ), o(
      function() {
        return a(m) && b({ inst: m }), d(function() {
          a(m) && b({ inst: m });
        });
      },
      [d]
    ), s(h), h;
  }
  function a(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : l;
  return il.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, il;
}
var sl = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ed;
function xy() {
  return ed || (ed = 1, process.env.NODE_ENV !== "production" && (function() {
    function t(h, p) {
      return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p;
    }
    function e(h, p) {
      u || o.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var m = p();
      if (!d) {
        var b = p();
        i(m, b) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      b = s({
        inst: { value: m, getSnapshot: p }
      });
      var C = b[0].inst, v = b[1];
      return a(
        function() {
          C.value = m, C.getSnapshot = p, n(C) && v({ inst: C });
        },
        [h, m, p]
      ), l(
        function() {
          return n(C) && v({ inst: C }), h(function() {
            n(C) && v({ inst: C });
          });
        },
        [h]
      ), c(m), m;
    }
    function n(h) {
      var p = h.getSnapshot;
      h = h.value;
      try {
        var m = p();
        return !i(h, m);
      } catch {
        return !0;
      }
    }
    function r(h, p) {
      return p();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var o = ve, i = typeof Object.is == "function" ? Object.is : t, s = o.useState, l = o.useEffect, a = o.useLayoutEffect, c = o.useDebugValue, u = !1, d = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    sl.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), sl;
}
var td;
function lc() {
  return td || (td = 1, process.env.NODE_ENV === "production" ? Do.exports = Sy() : Do.exports = xy()), Do.exports;
}
var Ph = lc();
function Ae(t) {
  this.content = t;
}
Ae.prototype = {
  constructor: Ae,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, o = r.find(t), i = r.content.slice();
    return o == -1 ? i.push(n || t, e) : (i[o + 1] = e, n && (i[o] = n)), new Ae(i);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Ae(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new Ae([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new Ae(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), o = r.content.slice(), i = r.find(t);
    return o.splice(i == -1 ? o.length : i, 0, e, n), new Ae(o);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = Ae.from(t), t.size ? new Ae(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = Ae.from(t), t.size ? new Ae(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = Ae.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Ae.from = function(t) {
  if (t instanceof Ae) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new Ae(e);
};
function Bh(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let o = t.child(r), i = e.child(r);
    if (o == i) {
      n += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(i))
      return n;
    if (o.isText && o.text != i.text) {
      for (let s = 0; o.text[s] == i.text[s]; s++)
        n++;
      return n;
    }
    if (o.content.size || i.content.size) {
      let s = Bh(o.content, i.content, n + 1);
      if (s != null)
        return s;
    }
    n += o.nodeSize;
  }
}
function Hh(t, e, n, r) {
  for (let o = t.childCount, i = e.childCount; ; ) {
    if (o == 0 || i == 0)
      return o == i ? null : { a: n, b: r };
    let s = t.child(--o), l = e.child(--i), a = s.nodeSize;
    if (s == l) {
      n -= a, r -= a;
      continue;
    }
    if (!s.sameMarkup(l))
      return { a: n, b: r };
    if (s.isText && s.text != l.text) {
      let c = 0, u = Math.min(s.text.length, l.text.length);
      for (; c < u && s.text[s.text.length - c - 1] == l.text[l.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || l.content.size) {
      let c = Hh(s.content, l.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= a, r -= a;
  }
}
class A {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, o = 0, i) {
    for (let s = 0, l = 0; l < n; s++) {
      let a = this.content[s], c = l + a.nodeSize;
      if (c > e && r(a, o + l, i || null, s) !== !1 && a.content.size) {
        let u = l + 1;
        a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, n - u), r, o + u);
      }
      l = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, o) {
    let i = "", s = !0;
    return this.nodesBetween(e, n, (l, a) => {
      let c = l.isText ? l.text.slice(Math.max(e, a) - a, n - a) : l.isLeaf ? o ? typeof o == "function" ? o(l) : o : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : "";
      l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (s ? s = !1 : i += r), i += c;
    }, 0), i;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, o = this.content.slice(), i = 0;
    for (n.isText && n.sameMarkup(r) && (o[o.length - 1] = n.withText(n.text + r.text), i = 1); i < e.content.length; i++)
      o.push(e.content[i]);
    return new A(o, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], o = 0;
    if (n > e)
      for (let i = 0, s = 0; s < n; i++) {
        let l = this.content[i], a = s + l.nodeSize;
        a > e && ((s < e || a > n) && (l.isText ? l = l.cut(Math.max(0, e - s), Math.min(l.text.length, n - s)) : l = l.cut(Math.max(0, e - s - 1), Math.min(l.content.size, n - s - 1))), r.push(l), o += l.nodeSize), s = a;
      }
    return new A(r, o);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? A.empty : e == 0 && n == this.content.length ? this : new A(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let o = this.content.slice(), i = this.size + n.nodeSize - r.nodeSize;
    return o[e] = n, new A(o, i);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new A([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new A(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let o = this.content[n];
      e(o, r, n), r += o.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return Bh(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return Hh(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Po(0, e);
    if (e == this.size)
      return Po(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let o = this.child(n), i = r + o.nodeSize;
      if (i >= e)
        return i == e ? Po(n + 1, i) : Po(n, r);
      r = i;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return A.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new A(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return A.empty;
    let n, r = 0;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      r += i.nodeSize, o && i.isText && e[o - 1].sameMarkup(i) ? (n || (n = e.slice(0, o)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i);
    }
    return new A(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return A.empty;
    if (e instanceof A)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new A([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
A.empty = new A([], 0);
const ll = { index: 0, offset: 0 };
function Po(t, e) {
  return ll.index = t, ll.offset = e, ll;
}
function yi(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!yi(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !yi(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let ie = class na {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      if (this.eq(i))
        return e;
      if (this.type.excludes(i.type))
        n || (n = e.slice(0, o));
      else {
        if (i.type.excludes(this.type))
          return e;
        !r && i.type.rank > this.type.rank && (n || (n = e.slice(0, o)), n.push(this), r = !0), n && n.push(i);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && yi(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let o = r.create(n.attrs);
    return r.checkAttrs(o.attrs), o;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return na.none;
    if (e instanceof na)
      return [e];
    let n = e.slice();
    return n.sort((r, o) => r.type.rank - o.type.rank), n;
  }
};
ie.none = [];
class bi extends Error {
}
class B {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = _h(this.content, e + this.openStart, n);
    return r && new B(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new B(Fh(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return B.empty;
    let r = n.openStart || 0, o = n.openEnd || 0;
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new B(A.fromJSON(e, n.content), r, o);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, o = 0;
    for (let i = e.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
      r++;
    for (let i = e.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
      o++;
    return new B(e, r, o);
  }
}
B.empty = new B(A.empty, 0, 0);
function Fh(t, e, n) {
  let { index: r, offset: o } = t.findIndex(e), i = t.maybeChild(r), { index: s, offset: l } = t.findIndex(n);
  if (o == e || i.isText) {
    if (l != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, i.copy(Fh(i.content, e - o - 1, n - o - 1)));
}
function _h(t, e, n, r) {
  let { index: o, offset: i } = t.findIndex(e), s = t.maybeChild(o);
  if (i == e || s.isText)
    return r && !r.canReplace(o, o, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let l = _h(s.content, e - i - 1, n, s);
  return l && t.replaceChild(o, s.copy(l));
}
function ky(t, e, n) {
  if (n.openStart > t.depth)
    throw new bi("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new bi("Inconsistent open depths");
  return zh(t, e, n, 0);
}
function zh(t, e, n, r) {
  let o = t.index(r), i = t.node(r);
  if (o == e.index(r) && r < t.depth - n.openStart) {
    let s = zh(t, e, n, r + 1);
    return i.copy(i.content.replaceChild(o, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let s = t.parent, l = s.content;
      return Vn(s, l.cut(0, t.parentOffset).append(n.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: s, end: l } = Ey(n, t);
      return Vn(i, $h(t, s, l, e, r));
    }
  else return Vn(i, Ci(t, e, r));
}
function Vh(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new bi("Cannot join " + e.type.name + " onto " + t.type.name);
}
function ra(t, e, n) {
  let r = t.node(n);
  return Vh(r, e.node(n)), r;
}
function zn(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function $r(t, e, n, r) {
  let o = (e || t).node(n), i = 0, s = e ? e.index(n) : o.childCount;
  t && (i = t.index(n), t.depth > n ? i++ : t.textOffset && (zn(t.nodeAfter, r), i++));
  for (let l = i; l < s; l++)
    zn(o.child(l), r);
  e && e.depth == n && e.textOffset && zn(e.nodeBefore, r);
}
function Vn(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function $h(t, e, n, r, o) {
  let i = t.depth > o && ra(t, e, o + 1), s = r.depth > o && ra(n, r, o + 1), l = [];
  return $r(null, t, o, l), i && s && e.index(o) == n.index(o) ? (Vh(i, s), zn(Vn(i, $h(t, e, n, r, o + 1)), l)) : (i && zn(Vn(i, Ci(t, e, o + 1)), l), $r(e, n, o, l), s && zn(Vn(s, Ci(n, r, o + 1)), l)), $r(r, null, o, l), new A(l);
}
function Ci(t, e, n) {
  let r = [];
  if ($r(null, t, n, r), t.depth > n) {
    let o = ra(t, e, n + 1);
    zn(Vn(o, Ci(t, e, n + 1)), r);
  }
  return $r(e, null, n, r), new A(r);
}
function Ey(t, e) {
  let n = e.depth - t.openStart, o = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--)
    o = e.node(i).copy(A.from(o));
  return {
    start: o.resolveNoCache(t.openStart + n),
    end: o.resolveNoCache(o.content.size - t.openEnd - n)
  };
}
class Qr {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], o = e.child(n);
    return r ? e.child(n).cut(r) : o;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++)
      o += r.child(i).nodeSize;
    return o;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return ie.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), o = e.maybeChild(n);
    if (!r) {
      let l = r;
      r = o, o = l;
    }
    let i = r.marks;
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!o || !i[s].isInSet(o.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, o = e.parent.maybeChild(e.index());
    for (var i = 0; i < r.length; i++)
      r[i].type.spec.inclusive === !1 && (!o || !r[i].isInSet(o.marks)) && (r = r[i--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new vi(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], o = 0, i = n;
    for (let s = e; ; ) {
      let { index: l, offset: a } = s.content.findIndex(i), c = i - a;
      if (r.push(s, l, o + a), !c || (s = s.child(l), s.isText))
        break;
      i = c - 1, o += a + 1;
    }
    return new Qr(n, r, i);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = nd.get(e);
    if (r)
      for (let i = 0; i < r.elts.length; i++) {
        let s = r.elts[i];
        if (s.pos == n)
          return s;
      }
    else
      nd.set(e, r = new My());
    let o = r.elts[r.i] = Qr.resolve(e, n);
    return r.i = (r.i + 1) % Ty, o;
  }
}
class My {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const Ty = 12, nd = /* @__PURE__ */ new WeakMap();
class vi {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const Ry = /* @__PURE__ */ Object.create(null);
let bn = class oa {
  /**
  @internal
  */
  constructor(e, n, r, o = ie.none) {
    this.type = e, this.attrs = n, this.marks = o, this.content = r || A.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, o = 0) {
    this.content.nodesBetween(e, n, r, o, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, n, r, o) {
    return this.content.textBetween(e, n, r, o);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && yi(this.attrs, n || e.defaultAttrs || Ry) && ie.sameSet(this.marks, r || ie.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new oa(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new oa(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return B.empty;
    let o = this.resolve(e), i = this.resolve(n), s = r ? 0 : o.sharedDepth(n), l = o.start(s), c = o.node(s).content.cut(o.pos - l, i.pos - l);
    return new B(c, o.depth - s, i.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return ky(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: o } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (o == e || n.isText)
        return n;
      e -= o + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let o = this.content.child(n - 1);
    return { node: o, index: n - 1, offset: r - o.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Qr.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Qr.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let o = !1;
    return n > e && this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)), o;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Uh(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = A.empty, o = 0, i = r.childCount) {
    let s = this.contentMatchAt(e).matchFragment(r, o, i), l = s && s.matchFragment(this.content, n);
    if (!l || !l.validEnd)
      return !1;
    for (let a = o; a < i; a++)
      if (!this.type.allowsMarks(r.child(a).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, o) {
    if (o && !this.type.allowsMarks(o))
      return !1;
    let i = this.contentMatchAt(e).matchType(r), s = i && i.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = ie.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!ie.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let o = A.fromJSON(e, n.content), i = e.nodeType(n.type).create(n.attrs, o, r);
    return i.type.checkAttrs(i.attrs), i;
  }
};
bn.prototype.text = void 0;
class wi extends bn {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    if (super(e, n, null, o), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Uh(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new wi(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new wi(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function Uh(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Kn {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new Ay(e, n);
    if (r.next == null)
      return Kn.empty;
    let o = Wh(r);
    r.next && r.err("Unexpected trailing text");
    let i = By(Py(o));
    return Hy(i, r), i;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let o = this;
    for (let i = n; o && i < r; i++)
      o = o.matchType(e.child(i).type);
    return o;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let o = [this];
    function i(s, l) {
      let a = s.matchFragment(e, r);
      if (a && (!n || a.validEnd))
        return A.from(l.map((c) => c.createAndFill()));
      for (let c = 0; c < s.next.length; c++) {
        let { type: u, next: d } = s.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(d) == -1) {
          o.push(d);
          let f = i(d, l.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return i(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let o = r.shift(), i = o.match;
      if (i.matchType(e)) {
        let s = [];
        for (let l = o; l.type; l = l.via)
          s.push(l.type);
        return s.reverse();
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: l, next: a } = i.next[s];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in n) && (!o.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: o }), n[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let o = 0; o < r.next.length; o++)
        e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
    }
    return n(this), e.map((r, o) => {
      let i = o + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        i += (s ? ", " : "") + r.next[s].type.name + "->" + e.indexOf(r.next[s].next);
      return i;
    }).join(`
`);
  }
}
Kn.empty = new Kn(!0);
class Ay {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function Wh(t) {
  let e = [];
  do
    e.push(Oy(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function Oy(t) {
  let e = [];
  do
    e.push(Ny(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Ny(t) {
  let e = Dy(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = Iy(t, e);
    else
      break;
  return e;
}
function rd(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function Iy(t, e) {
  let n = rd(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = rd(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function Ly(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let o = [];
  for (let i in n) {
    let s = n[i];
    s.isInGroup(e) && o.push(s);
  }
  return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function Dy(t) {
  if (t.eat("(")) {
    let e = Wh(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = Ly(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function Py(t) {
  let e = [[]];
  return o(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(s, l, a) {
    let c = { term: a, to: l };
    return e[s].push(c), c;
  }
  function o(s, l) {
    s.forEach((a) => a.to = l);
  }
  function i(s, l) {
    if (s.type == "choice")
      return s.exprs.reduce((a, c) => a.concat(i(c, l)), []);
    if (s.type == "seq")
      for (let a = 0; ; a++) {
        let c = i(s.exprs[a], l);
        if (a == s.exprs.length - 1)
          return c;
        o(c, l = n());
      }
    else if (s.type == "star") {
      let a = n();
      return r(l, a), o(i(s.expr, a), a), [r(a)];
    } else if (s.type == "plus") {
      let a = n();
      return o(i(s.expr, l), a), o(i(s.expr, a), a), [r(a)];
    } else {
      if (s.type == "opt")
        return [r(l)].concat(i(s.expr, l));
      if (s.type == "range") {
        let a = l;
        for (let c = 0; c < s.min; c++) {
          let u = n();
          o(i(s.expr, a), u), a = u;
        }
        if (s.max == -1)
          o(i(s.expr, a), a);
        else
          for (let c = s.min; c < s.max; c++) {
            let u = n();
            r(a, u), o(i(s.expr, a), u), a = u;
          }
        return [r(a)];
      } else {
        if (s.type == "name")
          return [r(l, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function Kh(t, e) {
  return e - t;
}
function od(t, e) {
  let n = [];
  return r(e), n.sort(Kh);
  function r(o) {
    let i = t[o];
    if (i.length == 1 && !i[0].term)
      return r(i[0].to);
    n.push(o);
    for (let s = 0; s < i.length; s++) {
      let { term: l, to: a } = i[s];
      !l && n.indexOf(a) == -1 && r(a);
    }
  }
}
function By(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(od(t, 0));
  function n(r) {
    let o = [];
    r.forEach((s) => {
      t[s].forEach(({ term: l, to: a }) => {
        if (!l)
          return;
        let c;
        for (let u = 0; u < o.length; u++)
          o[u][0] == l && (c = o[u][1]);
        od(t, a).forEach((u) => {
          c || o.push([l, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let i = e[r.join(",")] = new Kn(r.indexOf(t.length - 1) > -1);
    for (let s = 0; s < o.length; s++) {
      let l = o[s][1].sort(Kh);
      i.next.push({ type: o[s][0], next: e[l.join(",")] || n(l) });
    }
    return i;
  }
}
function Hy(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let o = r[n], i = !o.validEnd, s = [];
    for (let l = 0; l < o.next.length; l++) {
      let { type: a, next: c } = o.next[l];
      s.push(a.name), i && !(a.isText || a.hasRequiredAttrs()) && (i = !1), r.indexOf(c) == -1 && r.push(c);
    }
    i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function jh(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function qh(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let o = e && e[r];
    if (o === void 0) {
      let i = t[r];
      if (i.hasDefault)
        o = i.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = o;
  }
  return n;
}
function Gh(t, e, n, r) {
  for (let o in e)
    if (!(o in t))
      throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
  for (let o in t) {
    let i = t[o];
    i.validate && i.validate(e[o]);
  }
}
function Zh(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new _y(t, r, e[r]);
  return n;
}
let id = class Jh {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = Zh(e, r.attrs), this.defaultAttrs = jh(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Kn.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : qh(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new bn(this, this.computeAttrs(e), A.from(n), ie.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = A.from(n), this.checkContent(n), new bn(this, this.computeAttrs(e), n, ie.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = A.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let o = this.contentMatch.matchFragment(n), i = o && o.fillBefore(A.empty, !0);
    return i ? new bn(this, e, n.append(i), ie.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Gh(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : ie.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((i, s) => r[i] = new Jh(i, n, s));
    let o = n.spec.topNode || "doc";
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let i in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function Fy(t, e, n) {
  let r = n.split("|");
  return (o) => {
    let i = o === null ? "null" : typeof o;
    if (r.indexOf(i) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`);
  };
}
class _y {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? Fy(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Cs {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    this.name = e, this.rank = n, this.schema = r, this.spec = o, this.attrs = Zh(e, o.attrs), this.excluded = null;
    let i = jh(this.attrs);
    this.instance = i ? new ie(this, i) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new ie(this, qh(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), o = 0;
    return e.forEach((i, s) => r[i] = new Cs(i, o++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    Gh(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Yh {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let o in e)
      n[o] = e[o];
    n.nodes = Ae.from(e.nodes), n.marks = Ae.from(e.marks || {}), this.nodes = id.compile(this.spec.nodes, this), this.marks = Cs.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let i = this.nodes[o], s = i.spec.content || "", l = i.spec.marks;
      if (i.contentMatch = r[s] || (r[s] = Kn.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = i;
      }
      i.markSet = l == "_" ? null : l ? sd(this, l.split(" ")) : l == "" || !i.inlineContent ? [] : null;
    }
    for (let o in this.marks) {
      let i = this.marks[o], s = i.spec.excludes;
      i.excluded = s == null ? [i] : s == "" ? [] : sd(this, s.split(" "));
    }
    this.nodeFromJSON = (o) => bn.fromJSON(this, o), this.markFromJSON = (o) => ie.fromJSON(this, o), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, o) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof id) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, o);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new wi(r, r.defaultAttrs, e, ie.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function sd(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let o = e[r], i = t.marks[o], s = i;
    if (i)
      n.push(i);
    else
      for (let l in t.marks) {
        let a = t.marks[l];
        (o == "_" || a.spec.group && a.spec.group.split(" ").indexOf(o) > -1) && n.push(s = a);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function zy(t) {
  return t.tag != null;
}
function Vy(t) {
  return t.style != null;
}
class Cn {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((o) => {
      if (zy(o))
        this.tags.push(o);
      else if (Vy(o)) {
        let i = /[^=]*/.exec(o.style)[0];
        r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
      }
    }), this.normalizeLists = !this.tags.some((o) => {
      if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
        return !1;
      let i = e.nodes[o.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new ad(this, n, !1);
    return r.addAll(e, ie.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new ad(this, n, !0);
    return r.addAll(e, ie.none, n.from, n.to), B.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let i = this.tags[o];
      if (Wy(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
        if (i.getAttrs) {
          let s = i.getAttrs(e);
          if (s === !1)
            continue;
          i.attrs = s || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, o) {
    for (let i = o ? this.styles.indexOf(o) + 1 : 0; i < this.styles.length; i++) {
      let s = this.styles[i], l = s.style;
      if (!(l.indexOf(e) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let a = s.getAttrs(n);
          if (a === !1)
            continue;
          s.attrs = a || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(o) {
      let i = o.priority == null ? 50 : o.priority, s = 0;
      for (; s < n.length; s++) {
        let l = n[s];
        if ((l.priority == null ? 50 : l.priority) < i)
          break;
      }
      n.splice(s, 0, o);
    }
    for (let o in e.marks) {
      let i = e.marks[o].spec.parseDOM;
      i && i.forEach((s) => {
        r(s = cd(s)), s.mark || s.ignore || s.clearMark || (s.mark = o);
      });
    }
    for (let o in e.nodes) {
      let i = e.nodes[o].spec.parseDOM;
      i && i.forEach((s) => {
        r(s = cd(s)), s.node || s.ignore || s.mark || (s.node = o);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Cn(e, Cn.schemaRules(e)));
  }
}
const Xh = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, $y = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Qh = { ol: !0, ul: !0 }, eo = 1, ia = 2, Ur = 4;
function ld(t, e, n) {
  return e != null ? (e ? eo : 0) | (e === "full" ? ia : 0) : t && t.whitespace == "pre" ? eo | ia : n & ~Ur;
}
class Bo {
  constructor(e, n, r, o, i, s) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = o, this.options = s, this.content = [], this.activeMarks = ie.none, this.match = i || (s & Ur ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(A.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, o;
        return (o = r.findWrapping(e.type)) ? (this.match = r, o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & eo)) {
      let r = this.content[this.content.length - 1], o;
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let i = r;
        r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - o[0].length));
      }
    }
    let n = A.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(A.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Xh.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class ad {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let o = n.topNode, i, s = ld(null, n.preserveWhitespace, 0) | (r ? Ur : 0);
    o ? i = new Bo(o.type, o.attrs, ie.none, !0, n.topMatch || o.type.contentMatch, s) : r ? i = new Bo(null, null, ie.none, !0, null, s) : i = new Bo(e.schema.topNodeType, null, ie.none, !0, null, s), this.nodes = [i], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, o = this.top, i = o.options & ia ? "full" : this.localPreserveWS || (o.options & eo) > 0;
    if (i === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i)
        i !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let s = o.content[o.content.length - 1], l = e.previousSibling;
        (!s || l && l.nodeName == "BR" || s.isText && /[ \t\r\n\u000c]$/.test(s.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), n, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let o = this.localPreserveWS, i = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), l;
    Qh.hasOwnProperty(s) && this.parser.normalizeLists && Uy(e);
    let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    e: if (a ? a.ignore : $y.hasOwnProperty(s))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!a || a.skip || a.closeParent) {
      a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip);
      let c, u = this.needsBlock;
      if (Xh.hasOwnProperty(s))
        i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c = !0, i.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let d = a && a.skip ? n : this.readStyles(e, n);
      d && this.addAll(e, d), c && this.sync(i), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0);
    }
    this.localPreserveWS = o;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let i = this.parser.matchedStyles[o], s = r.getPropertyValue(i);
        if (s)
          for (let l = void 0; ; ) {
            let a = this.parser.matchStyle(i, s, this, l);
            if (!a)
              break;
            if (a.ignore)
              return null;
            if (a.clearMark ? n = n.filter((c) => !a.clearMark(c)) : n = n.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1)
              l = a;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, o) {
    let i, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let a = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        a && (i = !0, r = a);
      }
    else {
      let a = this.parser.schema.marks[n.mark];
      r = r.concat(a.create(n.attrs));
    }
    let l = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (o)
      this.addElement(e, r, o);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((a) => this.insertNode(a, r, !1));
    else {
      let a = e;
      typeof n.contentElement == "string" ? a = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? a = n.contentElement(e) : n.contentElement && (a = n.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1);
    }
    i && this.sync(l) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, o) {
    let i = r || 0;
    for (let s = r ? e.childNodes[r] : e.firstChild, l = o == null ? null : e.childNodes[o]; s != l; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s, n);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n, r) {
    let o, i;
    for (let s = this.open, l = 0; s >= 0; s--) {
      let a = this.nodes[s], c = a.findWrapping(e);
      if (c && (!o || o.length > c.length + l) && (o = c, i = a, !c.length))
        break;
      if (a.solid) {
        if (r)
          break;
        l += 2;
      }
    }
    if (!o)
      return null;
    this.sync(i);
    for (let s = 0; s < o.length; s++)
      n = this.enterInner(o[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let o = this.findPlace(e, n, r);
    if (o) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let s = ie.none;
      for (let l of o.concat(e.marks))
        (i.type ? i.type.allowsMarkType(l.type) : ud(l.type, e.type)) && (s = l.addToSet(s));
      return i.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, o) {
    let i = this.findPlace(e.create(n), r, !1);
    return i && (i = this.enterInner(e, n, r, !0, o)), i;
  }
  // Open a node of the given type
  enterInner(e, n, r, o = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let l = ld(e, i, s.options);
    s.options & Ur && s.content.length == 0 && (l |= Ur);
    let a = ie.none;
    return r = r.filter((c) => (s.type ? s.type.allowsMarkType(c.type) : ud(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new Bo(e, n, a, o, null, l)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= eo);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let o = r.length - 1; o >= 0; o--)
        e += r[o].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1), s = (l, a) => {
      for (; l >= 0; l--) {
        let c = n[l];
        if (c == "") {
          if (l == n.length - 1 || l == 0)
            continue;
          for (; a >= i; a--)
            if (s(l - 1, a))
              return !0;
          return !1;
        } else {
          let u = a > 0 || a == 0 && o ? this.nodes[a].type : r && a >= i ? r.node(a - i).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          a--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function Uy(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Qh.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function Wy(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function cd(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function ud(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let o = n[r];
    if (!o.allowsMarkType(t))
      continue;
    let i = [], s = (l) => {
      i.push(l);
      for (let a = 0; a < l.edgeCount; a++) {
        let { type: c, next: u } = l.edge(a);
        if (c == e || i.indexOf(u) < 0 && s(u))
          return !0;
      }
    };
    if (s(o.contentMatch))
      return !0;
  }
}
class Qn {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = al(n).createDocumentFragment());
    let o = r, i = [];
    return e.forEach((s) => {
      if (i.length || s.marks.length) {
        let l = 0, a = 0;
        for (; l < i.length && a < s.marks.length; ) {
          let c = s.marks[a];
          if (!this.marks[c.type.name]) {
            a++;
            continue;
          }
          if (!c.eq(i[l][0]) || c.type.spec.spanning === !1)
            break;
          l++, a++;
        }
        for (; l < i.length; )
          o = i.pop()[1];
        for (; a < s.marks.length; ) {
          let c = s.marks[a++], u = this.serializeMark(c, s.isInline, n);
          u && (i.push([c, o]), o.appendChild(u.dom), o = u.contentDOM || u.dom);
        }
      }
      o.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: o } = ii(al(n), this.nodes[e.type.name](e), null, e.attrs);
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, o);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let i = this.serializeMark(e.marks[o], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(r), r = i.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let o = this.marks[e.type.name];
    return o && ii(al(r), o(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, o) {
    return ii(e, n, r, o);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Qn(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = dd(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return dd(e.marks);
  }
}
function dd(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function al(t) {
  return t.document || window.document;
}
const fd = /* @__PURE__ */ new WeakMap();
function Ky(t) {
  let e = fd.get(t);
  return e === void 0 && fd.set(t, e = jy(t)), e;
}
function jy(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let o = 0; o < r.length; o++)
            n(r[o]);
      else
        for (let o in r)
          n(r[o]);
  }
  return n(t), e;
}
function ii(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let o = e[0], i;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (i = Ky(r)) && i.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = o.indexOf(" ");
  s > 0 && (n = o.slice(0, s), o = o.slice(s + 1));
  let l, a = n ? t.createElementNS(n, o) : t.createElement(o), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? a.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : d == "style" && a.style ? a.style.cssText = c[d] : a.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: a, contentDOM: a };
    } else {
      let { dom: h, contentDOM: p } = ii(t, f, n, r);
      if (a.appendChild(h), p) {
        if (l)
          throw new RangeError("Multiple content holes");
        l = p;
      }
    }
  }
  return { dom: a, contentDOM: l };
}
const ep = 65535, tp = Math.pow(2, 16);
function qy(t, e) {
  return t + e * tp;
}
function hd(t) {
  return t & ep;
}
function Gy(t) {
  return (t - (t & ep)) / tp;
}
const np = 1, rp = 2, si = 4, op = 8;
class sa {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & op) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (np | si)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (rp | si)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & si) > 0;
  }
}
class je {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && je.empty)
      return je.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = hd(e);
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[r * 3] + n + Gy(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? o : 0);
      if (a > e)
        break;
      let c = this.ranges[l + i], u = this.ranges[l + s], d = a + c;
      if (e <= d) {
        let f = c ? e == a ? -1 : e == d ? 1 : n : n, h = a + o + (f < 0 ? 0 : u);
        if (r)
          return h;
        let p = e == (n < 0 ? a : d) ? null : qy(l / 3, e - a), m = e == a ? rp : e == d ? np : si;
        return (n < 0 ? e != a : e != d) && (m |= op), new sa(h, m, p);
      }
      o += u - c;
    }
    return r ? e + o : new sa(e + o, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, o = hd(n), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? r : 0);
      if (a > e)
        break;
      let c = this.ranges[l + i], u = a + c;
      if (e <= u && l == o * 3)
        return !0;
      r += this.ranges[l + s] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
      let s = this.ranges[o], l = s - (this.inverted ? i : 0), a = s + (this.inverted ? 0 : i), c = this.ranges[o + n], u = this.ranges[o + r];
      e(l, l + c, a, a + u), i += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new je(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? je.empty : new je(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
je.empty = new je([]);
class to {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, r = 0, o = e ? e.length : 0) {
    this.mirror = n, this.from = r, this.to = o, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new to(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
      let o = e.getMirror(n);
      this.appendMap(e._maps[n], o != null && o < n ? r + o : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
      let o = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), o != null && o > n ? r - o - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new to();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0;
    for (let i = this.from; i < this.to; i++) {
      let s = this._maps[i], l = s.mapResult(e, n);
      if (l.recover != null) {
        let a = this.getMirror(i);
        if (a != null && a > i && a < this.to) {
          i = a, e = this._maps[a].recover(l.recover);
          continue;
        }
      }
      o |= l.delInfo, e = l.pos;
    }
    return r ? e : new sa(e, o, null);
  }
}
const cl = /* @__PURE__ */ Object.create(null);
class Fe {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return je.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = cl[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in cl)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return cl[e] = n, n.prototype.jsonID = e, n;
  }
}
class we {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new we(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new we(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, o) {
    try {
      return we.ok(e.replace(n, r, o));
    } catch (i) {
      if (i instanceof bi)
        return we.fail(i.message);
      throw i;
    }
  }
}
function ac(t, e, n) {
  let r = [];
  for (let o = 0; o < t.childCount; o++) {
    let i = t.child(o);
    i.content.size && (i = i.copy(ac(i.content, e, i))), i.isInline && (i = e(i, n, o)), r.push(i);
  }
  return A.fromArray(r);
}
class mn extends Fe {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), i = new B(ac(n.content, (s, l) => !s.isAtom || !l.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), n.openStart, n.openEnd);
    return we.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new ft(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new mn(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof mn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new mn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new mn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Fe.jsonID("addMark", mn);
class ft extends Fe {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new B(ac(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), n.openStart, n.openEnd);
    return we.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new mn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new ft(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof ft && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ft(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new ft(n.from, n.to, e.markFromJSON(n.mark));
  }
}
Fe.jsonID("removeMark", ft);
class gn extends Fe {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return we.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return we.fromReplace(e, this.pos, this.pos + 1, new B(A.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let o = 0; o < n.marks.length; o++)
          if (!n.marks[o].isInSet(r))
            return new gn(this.pos, n.marks[o]);
        return new gn(this.pos, this.mark);
      }
    }
    return new jn(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gn(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new gn(n.pos, e.markFromJSON(n.mark));
  }
}
Fe.jsonID("addNodeMark", gn);
class jn extends Fe {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return we.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return we.fromReplace(e, this.pos, this.pos + 1, new B(A.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new gn(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new jn(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new jn(n.pos, e.markFromJSON(n.mark));
  }
}
Fe.jsonID("removeNodeMark", jn);
class ke extends Fe {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, o = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = o;
  }
  apply(e) {
    return this.structure && la(e, this.from, this.to) ? we.fail("Structure replace would overwrite content") : we.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new je([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new ke(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new ke(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof ke) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? B.empty : new B(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new ke(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? B.empty : new B(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new ke(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ke(n.from, n.to, B.fromJSON(e, n.slice), !!n.structure);
  }
}
Fe.jsonID("replace", ke);
class Me extends Fe {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, o, i, s, l = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = o, this.slice = i, this.insert = s, this.structure = l;
  }
  apply(e) {
    if (this.structure && (la(e, this.from, this.gapFrom) || la(e, this.gapTo, this.to)))
      return we.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return we.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? we.fromReplace(e, this.from, this.to, r) : we.fail("Content does not fit in gap");
  }
  getMap() {
    return new je([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new Me(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || o < n.pos || i > r.pos ? null : new Me(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Me(n.from, n.to, n.gapFrom, n.gapTo, B.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
Fe.jsonID("replaceAround", Me);
function la(t, e, n) {
  let r = t.resolve(e), o = n - e, i = r.depth;
  for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
    i--, o--;
  if (o > 0) {
    let s = r.node(i).maybeChild(r.indexAfter(i));
    for (; o > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, o--;
    }
  }
  return !1;
}
function Zy(t, e, n, r) {
  let o = [], i = [], s, l;
  t.doc.nodesBetween(e, n, (a, c, u) => {
    if (!a.isInline)
      return;
    let d = a.marks;
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), h = Math.min(c + a.nodeSize, n), p = r.addToSet(d);
      for (let m = 0; m < d.length; m++)
        d[m].isInSet(p) || (s && s.to == f && s.mark.eq(d[m]) ? s.to = h : o.push(s = new ft(f, h, d[m])));
      l && l.to == f ? l.to = h : i.push(l = new mn(f, h, r));
    }
  }), o.forEach((a) => t.step(a)), i.forEach((a) => t.step(a));
}
function Jy(t, e, n, r) {
  let o = [], i = 0;
  t.doc.nodesBetween(e, n, (s, l) => {
    if (!s.isInline)
      return;
    i++;
    let a = null;
    if (r instanceof Cs) {
      let c = s.marks, u;
      for (; u = r.isInSet(c); )
        (a || (a = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(s.marks) && (a = [r]) : a = s.marks;
    if (a && a.length) {
      let c = Math.min(l + s.nodeSize, n);
      for (let u = 0; u < a.length; u++) {
        let d = a[u], f;
        for (let h = 0; h < o.length; h++) {
          let p = o[h];
          p.step == i - 1 && d.eq(o[h].style) && (f = p);
        }
        f ? (f.to = c, f.step = i) : o.push({ style: d, from: Math.max(l, e), to: c, step: i });
      }
    }
  }), o.forEach((s) => t.step(new ft(s.from, s.to, s.style)));
}
function cc(t, e, n, r = n.contentMatch, o = !0) {
  let i = t.doc.nodeAt(e), s = [], l = e + 1;
  for (let a = 0; a < i.childCount; a++) {
    let c = i.child(a), u = l + c.nodeSize, d = r.matchType(c.type);
    if (!d)
      s.push(new ke(l, u, B.empty));
    else {
      r = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new ft(l, u, c.marks[f]));
      if (o && c.isText && n.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, p;
        for (; f = h.exec(c.text); )
          p || (p = new B(A.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), s.push(new ke(l + f.index, l + f.index + f[0].length, p));
      }
    }
    l = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(A.empty, !0);
    t.replace(l, l, new B(a, 0, 0));
  }
  for (let a = s.length - 1; a >= 0; a--)
    t.step(s[a]);
}
function Yy(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function Ar(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth; ; --r) {
    let o = t.$from.node(r), i = t.$from.index(r), s = t.$to.indexAfter(r);
    if (r < t.depth && o.canReplace(i, s, n))
      return r;
    if (r == 0 || o.type.spec.isolating || !Yy(o, i, s))
      break;
  }
  return null;
}
function Xy(t, e, n) {
  let { $from: r, $to: o, depth: i } = e, s = r.before(i + 1), l = o.after(i + 1), a = s, c = l, u = A.empty, d = 0;
  for (let p = i, m = !1; p > n; p--)
    m || r.index(p) > 0 ? (m = !0, u = A.from(r.node(p).copy(u)), d++) : a--;
  let f = A.empty, h = 0;
  for (let p = i, m = !1; p > n; p--)
    m || o.after(p + 1) < o.end(p) ? (m = !0, f = A.from(o.node(p).copy(f)), h++) : c++;
  t.step(new Me(a, c, s, l, new B(u.append(f), d, h), u.size - d, !0));
}
function uc(t, e, n = null, r = t) {
  let o = Qy(t, e), i = o && eb(r, e);
  return i ? o.map(pd).concat({ type: e, attrs: n }).concat(i.map(pd)) : null;
}
function pd(t) {
  return { type: t, attrs: null };
}
function Qy(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t, i = n.contentMatchAt(r).findWrapping(e);
  if (!i)
    return null;
  let s = i.length ? i[0] : e;
  return n.canReplaceWith(r, o, s) ? i : null;
}
function eb(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t, i = n.child(r), s = e.contentMatch.findWrapping(i.type);
  if (!s)
    return null;
  let a = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let c = r; a && c < o; c++)
    a = a.matchType(n.child(c).type);
  return !a || !a.validEnd ? null : s;
}
function tb(t, e, n) {
  let r = A.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let l = n[s].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = A.from(n[s].type.create(n[s].attrs, r));
  }
  let o = e.start, i = e.end;
  t.step(new Me(o, i, o, i, new B(r, 0, 0), n.length, !0));
}
function nb(t, e, n, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (s, l) => {
    let a = typeof o == "function" ? o(s) : o;
    if (s.isTextblock && !s.hasMarkup(r, a) && rb(t.doc, t.mapping.slice(i).map(l), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let h = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        h && !p ? c = !1 : !h && p && (c = !0);
      }
      c === !1 && sp(t, s, l, i), cc(t, t.mapping.slice(i).map(l, 1), r, void 0, c === null);
      let u = t.mapping.slice(i), d = u.map(l, 1), f = u.map(l + s.nodeSize, 1);
      return t.step(new Me(d, f, d + 1, f - 1, new B(A.from(r.create(a, null, s.marks)), 0, 0), 1, !0)), c === !0 && ip(t, s, l, i), !1;
    }
  });
}
function ip(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.isText) {
      let s, l = /\r?\n|\r/g;
      for (; s = l.exec(o.text); ) {
        let a = t.mapping.slice(r).map(n + 1 + i + s.index);
        t.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function sp(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(r).map(n + 1 + i);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function rb(t, e, n) {
  let r = t.resolve(e), o = r.index();
  return r.parent.canReplaceWith(o, o + 1, n);
}
function ob(t, e, n, r, o) {
  let i = t.doc.nodeAt(e);
  if (!i)
    throw new RangeError("No node at given position");
  n || (n = i.type);
  let s = n.create(r, null, o || i.marks);
  if (i.isLeaf)
    return t.replaceWith(e, e + i.nodeSize, s);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new Me(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new B(A.from(s), 0, 0), 1, !0));
}
function Jt(t, e, n = 1, r) {
  let o = t.resolve(e), i = o.depth - n, s = r && r[r.length - 1] || o.parent;
  if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
    return !1;
  for (let c = o.depth - 1, u = n - 2; c > i; c--, u--) {
    let d = o.node(c), f = o.index(c);
    if (d.type.spec.isolating)
      return !1;
    let h = d.content.cutByIndex(f, d.childCount), p = r && r[u + 1];
    p && (h = h.replaceChild(0, p.type.create(p.attrs)));
    let m = r && r[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !m.type.validContent(h))
      return !1;
  }
  let l = o.indexAfter(i), a = r && r[0];
  return o.node(i).canReplaceWith(l, l, a ? a.type : o.node(i + 1).type);
}
function ib(t, e, n = 1, r) {
  let o = t.doc.resolve(e), i = A.empty, s = A.empty;
  for (let l = o.depth, a = o.depth - n, c = n - 1; l > a; l--, c--) {
    i = A.from(o.node(l).copy(i));
    let u = r && r[c];
    s = A.from(u ? u.type.create(u.attrs, s) : o.node(l).copy(s));
  }
  t.step(new ke(e, e, new B(i.append(s), n, n), !0));
}
function On(t, e) {
  let n = t.resolve(e), r = n.index();
  return lp(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function sb(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let i = e.child(o), s = i.type == r ? t.type.schema.nodes.text : i.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(i.marks))
      return !1;
  }
  return n.validEnd;
}
function lp(t, e) {
  return !!(t && e && !t.isLeaf && sb(t, e));
}
function vs(t, e, n = -1) {
  let r = t.resolve(e);
  for (let o = r.depth; ; o--) {
    let i, s, l = r.index(o);
    if (o == r.depth ? (i = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (i = r.node(o + 1), l++, s = r.node(o).maybeChild(l)) : (i = r.node(o).maybeChild(l - 1), s = r.node(o + 1)), i && !i.isTextblock && lp(i, s) && r.node(o).canReplace(l, l + 1))
      return e;
    if (o == 0)
      break;
    e = n < 0 ? r.before(o) : r.after(o);
  }
}
function lb(t, e, n) {
  let r = null, { linebreakReplacement: o } = t.doc.type.schema, i = t.doc.resolve(e - n), s = i.node().type;
  if (o && s.inlineContent) {
    let u = s.whitespace == "pre", d = !!s.contentMatch.matchType(o);
    u && !d ? r = !1 : !u && d && (r = !0);
  }
  let l = t.steps.length;
  if (r === !1) {
    let u = t.doc.resolve(e + n);
    sp(t, u.node(), u.before(), l);
  }
  s.inlineContent && cc(t, e + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
  let a = t.mapping.slice(l), c = a.map(e - n);
  if (t.step(new ke(c, a.map(e + n, -1), B.empty, !0)), r === !0) {
    let u = t.doc.resolve(c);
    ip(t, u.node(), u.before(), t.steps.length);
  }
  return t;
}
function ab(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.index(o);
      if (r.node(o).canReplaceWith(i, i, n))
        return r.before(o + 1);
      if (i > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.indexAfter(o);
      if (r.node(o).canReplaceWith(i, i, n))
        return r.after(o + 1);
      if (i < r.node(o).childCount)
        return null;
    }
  return null;
}
function ap(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let o = n.content;
  for (let i = 0; i < n.openStart; i++)
    o = o.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = r.depth; s >= 0; s--) {
      let l = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, a = r.index(s) + (l > 0 ? 1 : 0), c = r.node(s), u = !1;
      if (i == 1)
        u = c.canReplace(a, a, o);
      else {
        let d = c.contentMatchAt(a).findWrapping(o.firstChild.type);
        u = d && c.canReplaceWith(a, a, d[0]);
      }
      if (u)
        return l == 0 ? r.pos : l < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function ws(t, e, n = e, r = B.empty) {
  if (e == n && !r.size)
    return null;
  let o = t.resolve(e), i = t.resolve(n);
  return cp(o, i, r) ? new ke(e, n, r) : new cb(o, i, r).fit();
}
function cp(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class cb {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = A.empty;
    for (let o = 0; o <= e.depth; o++) {
      let i = e.node(o);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(o))
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = A.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!o)
      return null;
    let i = this.placed, s = r.depth, l = o.depth;
    for (; s && l && i.childCount == 1; )
      i = i.firstChild.content, s--, l--;
    let a = new B(i, s, l);
    return e > -1 ? new Me(r.pos, e, this.$to.pos, this.$to.end(), a, n) : a.size || r.pos != this.$to.pos ? new ke(r.pos, o.pos, a) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
      let i = n.firstChild;
      if (n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
        e = r;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let o, i = null;
        r ? (i = ul(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
        let s = o.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: a, match: c } = this.frontier[l], u, d = null;
          if (n == 1 && (s ? c.matchType(s.type) || (d = c.fillBefore(A.from(s), !1)) : i && a.compatibleContent(i.type)))
            return { sliceDepth: r, frontierDepth: l, parent: i, inject: d };
          if (n == 2 && s && (u = c.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: i, wrap: u };
          if (i && c.matchType(i.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, o = ul(e, n);
    return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new B(e, n + 1, Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, o = ul(e, n);
    if (o.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + o.size;
      this.unplaced = new B(Hr(e, n - 1, 1), n - 1, i ? n - 1 : r);
    } else
      this.unplaced = new B(Hr(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: o, wrap: i }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (i)
      for (let m = 0; m < i.length; m++)
        this.openFrontierNode(i[m]);
    let s = this.unplaced, l = r ? r.content : s.content, a = s.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (o) {
      for (let m = 0; m < o.childCount; m++)
        u.push(o.child(m));
      d = d.matchFragment(o);
    }
    let h = l.size + e - (s.content.size - s.openEnd);
    for (; c < l.childCount; ) {
      let m = l.child(c), b = d.matchType(m.type);
      if (!b)
        break;
      c++, (c > 1 || a == 0 || m.content.size) && (d = b, u.push(up(m.mark(f.allowedMarks(m.marks)), c == 1 ? a : 0, c == l.childCount ? h : -1)));
    }
    let p = c == l.childCount;
    p || (h = -1), this.placed = Fr(this.placed, n, A.from(u)), this.frontier[n].match = d, p && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, b = l; m < h; m++) {
      let C = b.lastChild;
      this.frontier.push({ type: C.type, match: C.contentMatchAt(C.childCount) }), b = C.content;
    }
    this.unplaced = p ? e == 0 ? B.empty : new B(Hr(s.content, e - 1, 1), e - 1, h < 0 ? s.openEnd : e - 1) : new B(Hr(s.content, e, c), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !dl(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, o = this.$to.after(r);
    for (; r > 1 && o == this.$to.end(--r); )
      ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: o } = this.frontier[n], i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = dl(e, n, o, r, i);
      if (s) {
        for (let l = n - 1; l >= 0; l--) {
          let { match: a, type: c } = this.frontier[l], u = dl(e, l, c, a, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: i ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Fr(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let o = e.node(r), i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
      this.openFrontierNode(o.type, o.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let o = this.frontier[this.depth];
    o.match = o.match.matchType(e), this.placed = Fr(this.placed, this.depth, A.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(A.empty, !0);
    n.childCount && (this.placed = Fr(this.placed, this.frontier.length, n));
  }
}
function Hr(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Hr(t.firstChild.content, e - 1, n)));
}
function Fr(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Fr(t.lastChild.content, e - 1, n)));
}
function ul(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function up(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, up(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(A.empty, !0)))), t.copy(r);
}
function dl(t, e, n, r, o) {
  let i = t.node(e), s = o ? t.indexAfter(e) : t.index(e);
  if (s == i.childCount && !n.compatibleContent(i.type))
    return null;
  let l = r.fillBefore(i.content, !0, s);
  return l && !ub(n, i.content, s) ? l : null;
}
function ub(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function db(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function fb(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let o = t.doc.resolve(e), i = t.doc.resolve(n);
  if (cp(o, i, r))
    return t.step(new ke(e, n, r));
  let s = fp(o, t.doc.resolve(n));
  s[s.length - 1] == 0 && s.pop();
  let l = -(o.depth + 1);
  s.unshift(l);
  for (let f = o.depth, h = o.pos - 1; f > 0; f--, h--) {
    let p = o.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    s.indexOf(f) > -1 ? l = f : o.before(f) == h && s.splice(1, 0, -f);
  }
  let a = s.indexOf(l), c = [], u = r.openStart;
  for (let f = r.content, h = 0; ; h++) {
    let p = f.firstChild;
    if (c.push(p), h == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h = c[f], p = db(h.type);
    if (p && !h.sameMarkup(o.node(Math.abs(l) - 1)))
      u = f;
    else if (p || !h.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let h = (f + u + 1) % (r.openStart + 1), p = c[h];
    if (p)
      for (let m = 0; m < s.length; m++) {
        let b = s[(m + a) % s.length], C = !0;
        b < 0 && (C = !1, b = -b);
        let v = o.node(b - 1), S = o.index(b - 1);
        if (v.canReplaceWith(S, S, p.type, p.marks))
          return t.replace(o.before(b), C ? i.after(b) : n, new B(dp(r.content, 0, r.openStart, h), h, r.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = s.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > d)); f--) {
    let h = s[f];
    h < 0 || (e = o.before(h), n = i.after(h));
  }
}
function dp(t, e, n, r, o) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(dp(i.content, e + 1, n, r, i)));
  }
  if (e > r) {
    let i = o.contentMatchAt(0), s = i.fillBefore(t).append(t);
    t = s.append(i.matchFragment(s).fillBefore(A.empty, !0));
  }
  return t;
}
function hb(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let o = ab(t.doc, e, r.type);
    o != null && (e = n = o);
  }
  t.replaceRange(e, n, new B(A.from(r), 0, 0));
}
function pb(t, e, n) {
  let r = t.doc.resolve(e), o = t.doc.resolve(n), i = fp(r, o);
  for (let s = 0; s < i.length; s++) {
    let l = i[s], a = s == i.length - 1;
    if (a && l == 0 || r.node(l).type.contentMatch.validEnd)
      return t.delete(r.start(l), o.end(l));
    if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), o.indexAfter(l - 1))))
      return t.delete(r.before(l), o.after(l));
  }
  for (let s = 1; s <= r.depth && s <= o.depth; s++)
    if (e - r.start(s) == r.depth - s && n > r.end(s) && o.end(s) - n != o.depth - s && r.start(s - 1) == o.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1)))
      return t.delete(r.before(s), n);
  t.delete(e, n);
}
function fp(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let o = r; o >= 0; o--) {
    let i = t.start(o);
    if (i < t.pos - (t.depth - o) || e.end(o) > e.pos + (e.depth - o) || t.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
      break;
    (i == e.start(o) || o == t.depth && o == e.depth && t.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == i - 1) && n.push(o);
  }
  return n;
}
class gr extends Fe {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return we.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in n.attrs)
      r[i] = n.attrs[i];
    r[this.attr] = this.value;
    let o = n.type.create(r, null, n.marks);
    return we.fromReplace(e, this.pos, this.pos + 1, new B(A.from(o), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return je.empty;
  }
  invert(e) {
    return new gr(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new gr(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new gr(n.pos, n.attr, n.value);
  }
}
Fe.jsonID("attr", gr);
class no extends Fe {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let o in e.attrs)
      n[o] = e.attrs[o];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return we.ok(r);
  }
  getMap() {
    return je.empty;
  }
  invert(e) {
    return new no(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new no(n.attr, n.value);
  }
}
Fe.jsonID("docAttr", no);
let vr = class extends Error {
};
vr = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
vr.prototype = Object.create(Error.prototype);
vr.prototype.constructor = vr;
vr.prototype.name = "TransformError";
class dc {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new to();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new vr(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = B.empty) {
    let o = ws(this.doc, e, n, r);
    return o && this.step(o), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new B(A.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, B.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return fb(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return hb(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return pb(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return Xy(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return lb(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return tb(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, o = null) {
    return nb(this, e, n, r, o), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, o) {
    return ob(this, e, n, r, o), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new gr(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new no(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new gn(e, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (n instanceof ie)
      n.isInSet(r.marks) && this.step(new jn(e, n));
    else {
      let o = r.marks, i, s = [];
      for (; i = n.isInSet(o); )
        s.push(new jn(e, i)), o = i.removeFromSet(o);
      for (let l = s.length - 1; l >= 0; l--)
        this.step(s[l]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, r) {
    return ib(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return Zy(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return Jy(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return cc(this, e, n, r), this;
  }
}
const fl = /* @__PURE__ */ Object.create(null);
let K = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new hp(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = B.empty) {
    let r = n.content.lastChild, o = null;
    for (let l = 0; l < n.openEnd; l++)
      o = r, r = r.lastChild;
    let i = e.steps.length, s = this.ranges;
    for (let l = 0; l < s.length; l++) {
      let { $from: a, $to: c } = s[l], u = e.mapping.slice(i);
      e.replaceRange(u.map(a.pos), u.map(c.pos), l ? B.empty : n), l == 0 && yd(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, o = this.ranges;
    for (let i = 0; i < o.length; i++) {
      let { $from: s, $to: l } = o[i], a = e.mapping.slice(r), c = a.map(s.pos), u = a.map(l.pos);
      i ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), yd(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let o = e.parent.inlineContent ? new V(e) : ur(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (o)
      return o;
    for (let i = e.depth - 1; i >= 0; i--) {
      let s = n < 0 ? ur(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r) : ur(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Ge(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ur(e, e, 0, 0, 1) || new Ge(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ur(e, e, e.content.size, e.childCount, -1) || new Ge(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = fl[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in fl)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return fl[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return V.between(this.$anchor, this.$head).getBookmark();
  }
};
K.prototype.visible = !0;
class hp {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let md = !1;
function gd(t) {
  !md && !t.parent.inlineContent && (md = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class V extends K {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    gd(e), gd(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return K.near(r);
    let o = e.resolve(n.map(this.anchor));
    return new V(o.parent.inlineContent ? o : r, r);
  }
  replace(e, n = B.empty) {
    if (super.replace(e, n), n == B.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof V && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Ss(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new V(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let o = e.resolve(n);
    return new this(o, r == n ? o : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let o = e.pos - n.pos;
    if ((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let i = K.findFrom(n, r, !0) || K.findFrom(n, -r, !0);
      if (i)
        n = i.$head;
      else
        return K.near(n, r);
    }
    return e.parent.inlineContent || (o == 0 ? e = n : (e = (K.findFrom(e, -r, !0) || K.findFrom(e, r, !0)).$anchor, e.pos < n.pos != o < 0 && (e = n))), new V(e, n);
  }
}
K.jsonID("text", V);
class Ss {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new Ss(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return V.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class z extends K {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: o } = n.mapResult(this.anchor), i = e.resolve(o);
    return r ? K.near(i) : new z(i);
  }
  content() {
    return new B(A.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof z && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new fc(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new z(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new z(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
z.prototype.visible = !1;
K.jsonID("node", z);
class fc {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new Ss(r, r) : new fc(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && z.isSelectable(r) ? new z(n) : K.near(n);
  }
}
class Ge extends K {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = B.empty) {
    if (n == B.empty) {
      e.delete(0, e.doc.content.size);
      let r = K.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Ge(e);
  }
  map(e) {
    return new Ge(e);
  }
  eq(e) {
    return e instanceof Ge;
  }
  getBookmark() {
    return mb;
  }
}
K.jsonID("all", Ge);
const mb = {
  map() {
    return this;
  },
  resolve(t) {
    return new Ge(t);
  }
};
function ur(t, e, n, r, o, i = !1) {
  if (e.inlineContent)
    return V.create(t, n);
  for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < e.childCount : s >= 0; s += o) {
    let l = e.child(s);
    if (l.isAtom) {
      if (!i && z.isSelectable(l))
        return z.create(t, n - (o < 0 ? l.nodeSize : 0));
    } else {
      let a = ur(t, l, n + o, o < 0 ? l.childCount : 0, o, i);
      if (a)
        return a;
    }
    n += l.nodeSize * o;
  }
  return null;
}
function yd(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let o = t.steps[r];
  if (!(o instanceof ke || o instanceof Me))
    return;
  let i = t.mapping.maps[r], s;
  i.forEach((l, a, c, u) => {
    s == null && (s = u);
  }), t.setSelection(K.near(t.doc.resolve(s), n));
}
const bd = 1, Ho = 2, Cd = 4;
class gb extends dc {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | bd) & ~Ho, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & bd) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Ho, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return ie.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Ho) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~Ho, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || ie.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let o = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(o.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), r = r ?? n, !e)
        return this.deleteRange(n, r);
      let i = this.storedMarks;
      if (!i) {
        let s = this.doc.resolve(n);
        i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, o.text(e, i)), this.selection.empty || this.setSelection(K.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Cd, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Cd) > 0;
  }
}
function vd(t, e) {
  return !e || !t ? t : t.bind(e);
}
class _r {
  constructor(e, n, r) {
    this.name = e, this.init = vd(n.init, r), this.apply = vd(n.apply, r);
  }
}
const yb = [
  new _r("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new _r("selection", {
    init(t, e) {
      return t.selection || K.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new _r("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new _r("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class hl {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = yb.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new _r(r.key, r.spec.state, r));
    });
  }
}
class mr {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let o = this.config.plugins[r];
        if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), o = null;
    for (; ; ) {
      let i = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let l = this.config.plugins[s];
        if (l.spec.appendTransaction) {
          let a = o ? o[s].n : 0, c = o ? o[s].state : this, u = a < n.length && l.spec.appendTransaction.call(l, a ? n.slice(a) : n, c, r);
          if (u && r.filterTransaction(u, s)) {
            if (u.setMeta("appendedTransaction", e), !o) {
              o = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                o.push(d < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), r = r.applyInner(u), i = !0;
          }
          o && (o[s] = { state: r, n: n.length });
        }
      }
      if (!i)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new mr(this.config), r = this.config.fields;
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new gb(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new hl(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new mr(n);
    for (let o = 0; o < n.fields.length; o++)
      r[n.fields[o].name] = n.fields[o].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new hl(this.schema, e.plugins), r = n.fields, o = new mr(n);
    for (let i = 0; i < r.length; i++) {
      let s = r[i].name;
      o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
    }
    return o;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let o = e[r], i = o.spec.state;
        i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let o = new hl(e.schema, e.plugins), i = new mr(o);
    return o.fields.forEach((s) => {
      if (s.name == "doc")
        i.doc = bn.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        i.selection = K.fromJSON(i.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let a = r[l], c = a.spec.state;
            if (a.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, l)) {
              i[s.name] = c.fromJSON.call(a, e, n[l], i);
              return;
            }
          }
        i[s.name] = s.init(e, i);
      }
    }), i;
  }
}
function pp(t, e, n) {
  for (let r in t) {
    let o = t[r];
    o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = pp(o, e, {})), n[r] = o;
  }
  return n;
}
class ue {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && pp(e.props, this, this.props), this.key = e.key ? e.key.key : mp("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const pl = /* @__PURE__ */ Object.create(null);
function mp(t) {
  return t in pl ? t + "$" + ++pl[t] : (pl[t] = 0, t + "$");
}
class pe {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = mp(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Oe = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, wr = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let aa = null;
const Wt = function(t, e, n) {
  let r = aa || (aa = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, bb = function() {
  aa = null;
}, qn = function(t, e, n, r) {
  return n && (wd(t, e, n, r, -1) || wd(t, e, n, r, 1));
}, Cb = /^(img|br|input|textarea|hr)$/i;
function wd(t, e, n, r, o) {
  for (var i; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (o < 0 ? 0 : rt(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || bo(t) || Cb.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = Oe(t) + (o < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      let s = t.childNodes[e + (o < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((i = s.pmViewDesc) === null || i === void 0) && i.ignoreForSelection)
          e += o;
        else
          return !1;
      else
        t = s, e = o < 0 ? rt(t) : 0;
    } else
      return !1;
  }
}
function rt(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function vb(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = rt(t);
    } else if (t.parentNode && !bo(t))
      e = Oe(t), t = t.parentNode;
    else
      return null;
  }
}
function wb(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !bo(t))
      e = Oe(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function Sb(t, e, n) {
  for (let r = e == 0, o = e == rt(t); r || o; ) {
    if (t == n)
      return !0;
    let i = Oe(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && i == 0, o = o && i == rt(t);
  }
}
function bo(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const xs = function(t) {
  return t.focusNode && qn(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Bn(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function xb(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function kb(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(rt(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(rt(r.startContainer), r.startOffset) };
  }
}
const Lt = typeof navigator < "u" ? navigator : null, Sd = typeof document < "u" ? document : null, Nn = Lt && Lt.userAgent || "", ca = /Edge\/(\d+)/.exec(Nn), gp = /MSIE \d/.exec(Nn), ua = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Nn), We = !!(gp || ua || ca), vn = gp ? document.documentMode : ua ? +ua[1] : ca ? +ca[1] : 0, gt = !We && /gecko\/(\d+)/i.test(Nn);
gt && +(/Firefox\/(\d+)/.exec(Nn) || [0, 0])[1];
const da = !We && /Chrome\/(\d+)/.exec(Nn), Pe = !!da, yp = da ? +da[1] : 0, _e = !We && !!Lt && /Apple Computer/.test(Lt.vendor), Sr = _e && (/Mobile\/\w+/.test(Nn) || !!Lt && Lt.maxTouchPoints > 2), nt = Sr || (Lt ? /Mac/.test(Lt.platform) : !1), Eb = Lt ? /Win/.test(Lt.platform) : !1, jt = /Android \d/.test(Nn), Co = !!Sd && "webkitFontSmoothing" in Sd.documentElement.style, Mb = Co ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function Tb(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function _t(t, e) {
  return typeof t == "number" ? t : t[e];
}
function Rb(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function xd(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, o = t.someProp("scrollMargin") || 5, i = t.dom.ownerDocument;
  for (let s = n || t.dom; s; ) {
    if (s.nodeType != 1) {
      s = wr(s);
      continue;
    }
    let l = s, a = l == i.body, c = a ? Tb(i) : Rb(l), u = 0, d = 0;
    if (e.top < c.top + _t(r, "top") ? d = -(c.top - e.top + _t(o, "top")) : e.bottom > c.bottom - _t(r, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + _t(o, "top") - c.top : e.bottom - c.bottom + _t(o, "bottom")), e.left < c.left + _t(r, "left") ? u = -(c.left - e.left + _t(o, "left")) : e.right > c.right - _t(r, "right") && (u = e.right - c.right + _t(o, "right")), u || d)
      if (a)
        i.defaultView.scrollBy(u, d);
      else {
        let h = l.scrollLeft, p = l.scrollTop;
        d && (l.scrollTop += d), u && (l.scrollLeft += u);
        let m = l.scrollLeft - h, b = l.scrollTop - p;
        e = { left: e.left - m, top: e.top - b, right: e.right - m, bottom: e.bottom - b };
      }
    let f = a ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    s = f == "absolute" ? s.offsetParent : wr(s);
  }
}
function Ab(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, o;
  for (let i = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let l = t.root.elementFromPoint(i, s);
    if (!l || l == t.dom || !t.dom.contains(l))
      continue;
    let a = l.getBoundingClientRect();
    if (a.top >= n - 20) {
      r = l, o = a.top;
      break;
    }
  }
  return { refDOM: r, refTop: o, stack: bp(t.dom) };
}
function bp(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = wr(r))
    ;
  return e;
}
function Ob({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  Cp(n, r == 0 ? 0 : r - e);
}
function Cp(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: o, left: i } = t[n];
    r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != i && (r.scrollLeft = i);
  }
}
let ir = null;
function Nb(t) {
  if (t.setActive)
    return t.setActive();
  if (ir)
    return t.focus(ir);
  let e = bp(t);
  t.focus(ir == null ? {
    get preventScroll() {
      return ir = { preventScroll: !0 }, !0;
    }
  } : void 0), ir || (ir = !1, Cp(e, 0));
}
function vp(t, e) {
  let n, r = 2e8, o, i = 0, s = e.top, l = e.top, a, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Wt(u).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let p = f[h];
      if (p.top <= s && p.bottom >= l) {
        s = Math.max(p.bottom, s), l = Math.min(p.top, l);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < r) {
          n = u, r = m, o = m && n.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (i = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !a && p.left <= e.left && p.right >= e.left && (a = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !n && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (i = d + 1);
    }
  }
  return !n && a && (n = a, o = c, r = 0), n && n.nodeType == 3 ? Ib(n, o) : !n || r && n.nodeType == 1 ? { node: t, offset: i } : vp(n, o);
}
function Ib(t, e) {
  let n = t.nodeValue.length, r = document.createRange();
  for (let o = 0; o < n; o++) {
    r.setEnd(t, o + 1), r.setStart(t, o);
    let i = ln(r, 1);
    if (i.top != i.bottom && hc(e, i))
      return { node: t, offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0) };
  }
  return { node: t, offset: 0 };
}
function hc(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function Lb(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function Db(t, e, n) {
  let { node: r, offset: o } = vp(e, n), i = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, o, i);
}
function Pb(t, e, n, r) {
  let o = -1;
  for (let i = e, s = !1; i != t.dom; ) {
    let l = t.docView.nearestDesc(i, !0), a;
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!s && a.left > r.left || a.top > r.top ? o = l.posBefore : (!s && a.right < r.left || a.bottom < r.top) && (o = l.posAfter), s = !0), !l.contentDOM && o < 0 && !l.node.isText))
      return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter;
    i = l.dom.parentNode;
  }
  return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function wp(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ; ) {
      let s = t.childNodes[i];
      if (s.nodeType == 1) {
        let l = s.getClientRects();
        for (let a = 0; a < l.length; a++) {
          let c = l[a];
          if (hc(e, c))
            return wp(s, e, c);
        }
      }
      if ((i = (i + 1) % r) == o)
        break;
    }
  return t;
}
function Bb(t, e) {
  let n = t.dom.ownerDocument, r, o = 0, i = kb(n, e.left, e.top);
  i && ({ node: r, offset: o } = i);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), l;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = t.dom.getBoundingClientRect();
    if (!hc(e, c) || (s = wp(t.dom, e, c), !s))
      return null;
  }
  if (_e)
    for (let c = s; r && c; c = wr(c))
      c.draggable && (r = void 0);
  if (s = Lb(s, e), r) {
    if (gt && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
      let u = r.childNodes[o], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && o++;
    }
    let c;
    Co && o && r.nodeType == 1 && (c = r.childNodes[o - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && o--, r == t.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = t.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (l = Pb(t, r, o, e));
  }
  l == null && (l = Db(t, s, e));
  let a = t.docView.nearestDesc(s, !0);
  return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function kd(t) {
  return t.top < t.bottom || t.left < t.right;
}
function ln(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (kd(r))
      return r;
  }
  return Array.prototype.find.call(n, kd) || t.getBoundingClientRect();
}
const Hb = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Sp(t, e, n) {
  let { node: r, offset: o, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = Co || gt;
  if (r.nodeType == 3)
    if (s && (Hb.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
      let a = ln(Wt(r, o, o), n);
      if (gt && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let c = ln(Wt(r, o - 1, o - 1), -1);
        if (c.top == a.top) {
          let u = ln(Wt(r, o, o + 1), -1);
          if (u.top != a.top)
            return Pr(u, u.left < c.left);
        }
      }
      return a;
    } else {
      let a = o, c = o, u = n < 0 ? 1 : -1;
      return n < 0 && !o ? (c++, u = -1) : n >= 0 && o == r.nodeValue.length ? (a--, u = 1) : n < 0 ? a-- : c++, Pr(ln(Wt(r, a, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && o && (n < 0 || o == rt(r))) {
      let a = r.childNodes[o - 1];
      if (a.nodeType == 1)
        return ml(a.getBoundingClientRect(), !1);
    }
    if (i == null && o < rt(r)) {
      let a = r.childNodes[o];
      if (a.nodeType == 1)
        return ml(a.getBoundingClientRect(), !0);
    }
    return ml(r.getBoundingClientRect(), n >= 0);
  }
  if (i == null && o && (n < 0 || o == rt(r))) {
    let a = r.childNodes[o - 1], c = a.nodeType == 3 ? Wt(a, rt(a) - (s ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null;
    if (c)
      return Pr(ln(c, 1), !1);
  }
  if (i == null && o < rt(r)) {
    let a = r.childNodes[o];
    for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
      a = a.nextSibling;
    let c = a ? a.nodeType == 3 ? Wt(a, 0, s ? 0 : 1) : a.nodeType == 1 ? a : null : null;
    if (c)
      return Pr(ln(c, -1), !0);
  }
  return Pr(ln(r.nodeType == 3 ? Wt(r) : r, -n), n >= 0);
}
function Pr(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function ml(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function xp(t, e, n) {
  let r = t.state, o = t.root.activeElement;
  r != e && t.updateState(e), o != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), o != t.dom && o && o.focus();
  }
}
function Fb(t, e, n) {
  let r = e.selection, o = n == "up" ? r.$from : r.$to;
  return xp(t, e, () => {
    let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let l = t.docView.nearestDesc(i, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        i = l.contentDOM || l.dom;
        break;
      }
      i = l.dom.parentNode;
    }
    let s = Sp(t, o.pos, 1);
    for (let l = i.firstChild; l; l = l.nextSibling) {
      let a;
      if (l.nodeType == 1)
        a = l.getClientRects();
      else if (l.nodeType == 3)
        a = Wt(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < a.length; c++) {
        let u = a[c];
        if (u.bottom > u.top + 1 && (n == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const _b = /[\u0590-\u08ac]/;
function zb(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let o = r.parentOffset, i = !o, s = o == r.parent.content.size, l = t.domSelection();
  return l ? !_b.test(r.parent.textContent) || !l.modify ? n == "left" || n == "backward" ? i : s : xp(t, e, () => {
    let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), f = l.caretBidiLevel;
    l.modify("move", n, "character");
    let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: p, focusOffset: m } = t.domSelectionRange(), b = p && !h.contains(p.nodeType == 1 ? p : p.parentNode) || a == p && c == m;
    try {
      l.collapse(u, d), a && (a != u || c != d) && l.extend && l.extend(a, c);
    } catch {
    }
    return f != null && (l.caretBidiLevel = f), b;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Ed = null, Md = null, Td = !1;
function Vb(t, e, n) {
  return Ed == e && Md == n ? Td : (Ed = e, Md = n, Td = n == "up" || n == "down" ? Fb(t, e, n) : zb(t, e, n));
}
const ot = 0, Rd = 1, Hn = 2, Dt = 3;
class vo {
  constructor(e, n, r, o) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = o, this.dirty = ot, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let o = this.children[n];
      if (o == e)
        return r;
      r += o.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let o;
    if (e == this.dom && this.contentDOM)
      o = n > Oe(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      o = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !1;
            break;
          }
          if (i.previousSibling)
            break;
        }
      if (o == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !0;
            break;
          }
          if (i.nextSibling)
            break;
        }
    }
    return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, o = e; o; o = o.parentNode) {
      let i = this.getDesc(o), s;
      if (i && (!n || i.node))
        if (r && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          r = !1;
        else
          return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let o = e; o; o = o.parentNode) {
      let i = this.getDesc(o);
      if (i)
        return i.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let o = this.children[n], i = r + o.size;
      if (r == e && i != r) {
        for (; !o.border && o.children.length; )
          for (let s = 0; s < o.children.length; s++) {
            let l = o.children[s];
            if (l.size) {
              o = l;
              break;
            }
          }
        return o;
      }
      if (e < i)
        return o.descAt(e - r - o.border);
      r = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, o = 0;
    for (let i = 0; r < this.children.length; r++) {
      let s = this.children[r], l = i + s.size;
      if (l > e || s instanceof Ep) {
        o = e - i;
        break;
      }
      i = l;
    }
    if (o)
      return this.children[r].domFromPos(o - this.children[r].border, n);
    for (let i; r && !(i = this.children[r - 1]).size && i instanceof kp && i.side >= 0; r--)
      ;
    if (n <= 0) {
      let i, s = !0;
      for (; i = r ? this.children[r - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : { node: this.contentDOM, offset: i ? Oe(i.dom) + 1 : 0 };
    } else {
      let i, s = !0;
      for (; i = r < this.children.length ? this.children[r] : null, !(!i || i.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : { node: this.contentDOM, offset: i ? Oe(i.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let o = -1, i = -1;
    for (let s = r, l = 0; ; l++) {
      let a = this.children[l], c = s + a.size;
      if (o == -1 && e <= c) {
        let u = s + a.border;
        if (e >= u && n <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM))
          return a.parseRange(e, n, u);
        e = s;
        for (let d = l; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            o = Oe(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        o == -1 && (o = 0);
      }
      if (o > -1 && (c > n || l == this.children.length - 1)) {
        n = c;
        for (let u = l + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            i = Oe(d.dom);
            break;
          }
          n += d.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      s = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: o, toOffset: i };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, o = !1) {
    let i = Math.min(e, n), s = Math.max(e, n);
    for (let h = 0, p = 0; h < this.children.length; h++) {
      let m = this.children[h], b = p + m.size;
      if (i > p && s < b)
        return m.setSelection(e - p - m.border, n - p - m.border, r, o);
      p = b;
    }
    let l = this.domFromPos(e, e ? -1 : 1), a = n == e ? l : this.domFromPos(n, n ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), d = !1;
    if ((gt || _e) && e == n) {
      let { node: h, offset: p } = l;
      if (h.nodeType == 3) {
        if (d = !!(p && h.nodeValue[p - 1] == `
`), d && p == h.nodeValue.length)
          for (let m = h, b; m; m = m.parentNode) {
            if (b = m.nextSibling) {
              b.nodeName == "BR" && (l = a = { node: b.parentNode, offset: Oe(b) + 1 });
              break;
            }
            let C = m.pmViewDesc;
            if (C && C.node && C.node.isBlock)
              break;
          }
      } else {
        let m = h.childNodes[p - 1];
        d = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (gt && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
      let h = u.focusNode.childNodes[u.focusOffset];
      h && h.contentEditable == "false" && (o = !0);
    }
    if (!(o || d && _e) && qn(l.node, l.offset, u.anchorNode, u.anchorOffset) && qn(a.node, a.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !d) {
      c.collapse(l.node, l.offset);
      try {
        e != n && c.extend(a.node, a.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let p = l;
        l = a, a = p;
      }
      let h = document.createRange();
      h.setEnd(a.node, a.offset), h.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let i = this.children[o], s = r + i.size;
      if (r == s ? e <= s && n >= r : e < s && n > r) {
        let l = r + i.border, a = s - i.border;
        if (e >= l && n <= a) {
          this.dirty = e == r || n == s ? Hn : Rd, e == l && n == a && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = Dt : i.markDirty(e - l, n - l);
          return;
        } else
          i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? Hn : Dt;
      }
      r = s;
    }
    this.dirty = Hn;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Hn : Rd;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class kp extends vo {
  constructor(e, n, r, o) {
    let i, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!i)
        return o;
      if (i.parent)
        return i.parent.posBeforeChild(i);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(s), s = l;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, i = this;
  }
  matchesWidget(e) {
    return this.dirty == ot && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class $b extends vo {
  constructor(e, n, r, o) {
    super(e, [], n, null), this.textDOM = r, this.text = o;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Gn extends vo {
  constructor(e, n, r, o, i) {
    super(e, [], r, o), this.mark = n, this.spec = i;
  }
  static create(e, n, r, o) {
    let i = o.nodeViews[n.type.name], s = i && i(n, o, r);
    return (!s || !s.dom) && (s = Qn.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new Gn(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & Dt || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Dt && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != ot) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = ot;
    }
  }
  slice(e, n, r) {
    let o = Gn.create(this.parent, this.mark, !0, r), i = this.children, s = this.size;
    n < s && (i = ha(i, n, s, r)), e > 0 && (i = ha(i, 0, e, r));
    for (let l = 0; l < i.length; l++)
      i[l].parent = o;
    return o.children = i, o;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class wn extends vo {
  constructor(e, n, r, o, i, s, l, a, c) {
    super(e, [], i, s), this.node = n, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, o, i, s) {
    let l = i.nodeViews[n.type.name], a, c = l && l(n, i, () => {
      if (!a)
        return s;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    }, r, o), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = Qn.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = Rp(u, r, n), c ? a = new Ub(e, n, r, o, u, d || null, f, c, i, s + 1) : n.isText ? new ks(e, n, r, o, u, f, i) : new wn(e, n, r, o, u, d || null, f, i, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => A.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == ot && e.eq(this.node) && Si(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, o = n, i = e.composing ? this.localCompositionInfo(e, n) : null, s = i && i.pos > -1 ? i : null, l = i && i.pos < 0, a = new Kb(this, s && s.node, e);
    Gb(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? a.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !d && a.syncToMarks(u == this.node.childCount ? ie.none : this.node.child(u).marks, r, e), a.placeWidget(c, e, o);
    }, (c, u, d, f) => {
      a.syncToMarks(c.marks, r, e);
      let h;
      a.findNodeMatch(c, u, d, f) || l && e.state.selection.from > o && e.state.selection.to < o + c.nodeSize && (h = a.findIndexWithChild(i.node)) > -1 && a.updateNodeAt(c, u, d, h, e) || a.updateNextNode(c, u, d, e, f, o) || a.addNode(c, u, d, e, o), o += c.nodeSize;
    }), a.syncToMarks([], r, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == Hn) && (s && this.protectLocalComposition(e, s), Mp(this.contentDOM, this.children, e), Sr && Zb(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: o } = e.state.selection;
    if (!(e.state.selection instanceof V) || r < n || o > n + this.node.content.size)
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = i.nodeValue, l = Jb(this.node.content, s, r - n, o - n);
      return l < 0 ? null : { node: i, pos: l, text: s };
    } else
      return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: o }) {
    if (this.getDesc(n))
      return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; )
        i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; )
        i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let s = new $b(this, i, n, o);
    e.input.compositionNodes.push(s), this.children = ha(this.children, r, r + o.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, o) {
    return this.dirty == Dt || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, o), !0);
  }
  updateInner(e, n, r, o) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = ot;
  }
  updateOuterDeco(e) {
    if (Si(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = Tp(this.dom, this.nodeDOM, fa(this.outerDeco, this.node, n), fa(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Ad(t, e, n, r, o) {
  Rp(r, e, t);
  let i = new wn(void 0, t, e, n, r, r, r, o, 0);
  return i.contentDOM && i.updateChildren(o, 0), i;
}
class ks extends wn {
  constructor(e, n, r, o, i, s, l) {
    super(e, n, r, o, i, null, s, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, o) {
    return this.dirty == Dt || this.dirty != ot && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != ot || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = ot, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let o = this.node.cut(e, n), i = document.createTextNode(o.text);
    return new ks(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Dt);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class Ep extends vo {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == ot && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class Ub extends wn {
  constructor(e, n, r, o, i, s, l, a, c, u) {
    super(e, n, r, o, i, s, l, c, u), this.spec = a;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, o) {
    if (this.dirty == Dt)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, r);
      return i && this.updateInner(e, n, r, o), i;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, o) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, o);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function Mp(t, e, n) {
  let r = t.firstChild, o = !1;
  for (let i = 0; i < e.length; i++) {
    let s = e[i], l = s.dom;
    if (l.parentNode == t) {
      for (; l != r; )
        r = Od(r), o = !0;
      r = r.nextSibling;
    } else
      o = !0, t.insertBefore(l, r);
    if (s instanceof Gn) {
      let a = r ? r.previousSibling : t.lastChild;
      Mp(s.contentDOM, s.children, n), r = a ? a.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = Od(r), o = !0;
  o && n.trackWrites == t && (n.trackWrites = null);
}
const Wr = function(t) {
  t && (this.nodeName = t);
};
Wr.prototype = /* @__PURE__ */ Object.create(null);
const Fn = [new Wr()];
function fa(t, e, n) {
  if (t.length == 0)
    return Fn;
  let r = n ? Fn[0] : new Wr(), o = [r];
  for (let i = 0; i < t.length; i++) {
    let s = t[i].type.attrs;
    if (s) {
      s.nodeName && o.push(r = new Wr(s.nodeName));
      for (let l in s) {
        let a = s[l];
        a != null && (n && o.length == 1 && o.push(r = new Wr(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a));
      }
    }
  }
  return o;
}
function Tp(t, e, n, r) {
  if (n == Fn && r == Fn)
    return e;
  let o = e;
  for (let i = 0; i < r.length; i++) {
    let s = r[i], l = n[i];
    if (i) {
      let a;
      l && l.nodeName == s.nodeName && o != t && (a = o.parentNode) && a.nodeName.toLowerCase() == s.nodeName || (a = document.createElement(s.nodeName), a.pmIsDeco = !0, a.appendChild(o), l = Fn[0]), o = a;
    }
    Wb(o, l || Fn[0], s);
  }
  return o;
}
function Wb(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
      for (; o = r.exec(e.style); )
        t.style.removeProperty(o[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function Rp(t, e, n) {
  return Tp(t, t, Fn, fa(e, n, t.nodeType != 1));
}
function Si(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function Od(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class Kb {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = jb(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r) {
    let o = 0, i = this.stack.length >> 1, s = Math.min(i, e.length);
    for (; o < s && (o == i - 1 ? this.top : this.stack[o + 1 << 1]).matchesMark(e[o]) && e[o].type.spec.spanning !== !1; )
      o++;
    for (; o < i; )
      this.destroyRest(), this.top.dirty = ot, this.index = this.stack.pop(), this.top = this.stack.pop(), i--;
    for (; i < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
        let c = this.top.children[a];
        if (c.matchesMark(e[i]) && !this.isLocked(c.dom)) {
          l = a;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let a = Gn.create(this.top, e[i], n, r);
        this.top.children.splice(this.index, 0, a), this.top = a, this.changed = !0;
      }
      this.index = 0, i++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, o) {
    let i = -1, s;
    if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, r))
      i = this.top.children.indexOf(s, this.index);
    else
      for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
        let c = this.top.children[l];
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          i = l;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, r, o, i) {
    let s = this.top.children[o];
    return s.dirty == Dt && s.dom == s.contentDOM && (s.dirty = Hn), s.update(e, n, r, i) ? (this.destroyBetween(this.index, o), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r)
              return o;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, o, i, s) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let a = this.top.children[l];
      if (a instanceof wn) {
        let c = this.preMatch.matched.get(a);
        if (c != null && c != i)
          return !1;
        let u = a.dom, d, f = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != Dt && Si(n, a.outerDeco));
        if (!f && a.update(e, n, r, o))
          return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(a, e, n, r, o, s)))
          return this.destroyBetween(this.index, l), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Hn, d.updateChildren(o, s + 1), d.dirty = ot), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, o, i, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Si(r, e.outerDeco) || !o.eq(e.innerDeco))
      return null;
    let l = wn.create(this.top, n, r, o, i, s);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let a of l.children)
        a.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, o, i) {
    let s = wn.create(this.top, e, n, r, o, i);
    s.contentDOM && s.updateChildren(o, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let i = new kp(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Gn; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof ks) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((_e || Pe) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let o = new Ep(this.top, [], r, null);
      n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function jb(t, e) {
  let n = e, r = n.children.length, o = t.childCount, i = /* @__PURE__ */ new Map(), s = [];
  e: for (; o > 0; ) {
    let l;
    for (; ; )
      if (r) {
        let c = n.children[r - 1];
        if (c instanceof Gn)
          n = c, r = c.children.length;
        else {
          l = c, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let a = l.node;
    if (a) {
      if (a != t.child(o - 1))
        break;
      --o, i.set(l, o), s.push(l);
    }
  }
  return { index: o, matched: i, matches: s.reverse() };
}
function qb(t, e) {
  return t.type.side - e.type.side;
}
function Gb(t, e, n, r) {
  let o = e.locals(t), i = 0;
  if (o.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      r(u, o, e.forChild(i, u), c), i += u.nodeSize;
    }
    return;
  }
  let s = 0, l = [], a = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; s < o.length && o[s].to == i; ) {
      let b = o[s++];
      b.widget && (u ? (d || (d = [u])).push(b) : u = b);
    }
    if (u)
      if (d) {
        d.sort(qb);
        for (let b = 0; b < d.length; b++)
          n(d[b], c, !!a);
      } else
        n(u, c, !!a);
    let f, h;
    if (a)
      h = -1, f = a, a = null;
    else if (c < t.childCount)
      h = c, f = t.child(c++);
    else
      break;
    for (let b = 0; b < l.length; b++)
      l[b].to <= i && l.splice(b--, 1);
    for (; s < o.length && o[s].from <= i && o[s].to > i; )
      l.push(o[s++]);
    let p = i + f.nodeSize;
    if (f.isText) {
      let b = p;
      s < o.length && o[s].from < b && (b = o[s].from);
      for (let C = 0; C < l.length; C++)
        l[C].to < b && (b = l[C].to);
      b < p && (a = f.cut(b - i), f = f.cut(0, b - i), p = b, h = -1);
    } else
      for (; s < o.length && o[s].to < p; )
        s++;
    let m = f.isInline && !f.isLeaf ? l.filter((b) => !b.inline) : l.slice();
    r(f, m, e.forChild(i, f), h), i = p;
  }
}
function Zb(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function Jb(t, e, n, r) {
  for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
    let s = t.child(o++), l = i;
    if (i += s.nodeSize, !s.isText)
      continue;
    let a = s.text;
    for (; o < t.childCount; ) {
      let c = t.child(o++);
      if (i += c.nodeSize, !c.isText)
        break;
      a += c.text;
    }
    if (i >= n) {
      if (i >= r && a.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
      if (c >= 0 && c + e.length + l >= n)
        return l + c;
      if (n == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function ha(t, e, n, r, o) {
  let i = [];
  for (let s = 0, l = 0; s < t.length; s++) {
    let a = t[s], c = l, u = l += a.size;
    c >= n || u <= e ? i.push(a) : (c < e && i.push(a.slice(0, e - c, r)), o && (i.push(o), o = void 0), u > n && i.push(a.slice(n - c, a.size, r)));
  }
  return i;
}
function pc(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let o = t.docView.nearestDesc(n.focusNode), i = o && o.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let l = r.resolve(s), a, c;
  if (xs(n)) {
    for (a = s; o && !o.node; )
      o = o.parent;
    let d = o.node;
    if (o && d.isAtom && z.isSelectable(d) && o.parent && !(d.isInline && Sb(n.focusNode, n.focusOffset, o.dom))) {
      let f = o.posBefore;
      c = new z(s == f ? l : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = s, f = s;
      for (let h = 0; h < n.rangeCount; h++) {
        let p = n.getRangeAt(h);
        d = Math.min(d, t.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (d < 0)
        return null;
      [a, s] = f == t.state.selection.anchor ? [f, d] : [d, f], l = r.resolve(s);
    } else
      a = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (a < 0)
      return null;
  }
  let u = r.resolve(a);
  if (!c) {
    let d = e == "pointer" || t.state.selection.head < l.pos && !i ? 1 : -1;
    c = mc(t, u, l, d);
  }
  return c;
}
function Ap(t) {
  return t.editable ? t.hasFocus() : Np(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Yt(t, e = !1) {
  let n = t.state.selection;
  if (Op(t, n), !!Ap(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Pe) {
      let r = t.domSelectionRange(), o = t.domObserver.currentSelection;
      if (r.anchorNode && o.anchorNode && qn(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      Xb(t);
    else {
      let { anchor: r, head: o } = n, i, s;
      Nd && !(n instanceof V) && (n.$from.parent.inlineContent || (i = Id(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = Id(t, n.to))), t.docView.setSelection(r, o, t, e), Nd && (i && Ld(i), s && Ld(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Yb(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const Nd = _e || Pe && yp < 63;
function Id(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), o = r < n.childNodes.length ? n.childNodes[r] : null, i = r ? n.childNodes[r - 1] : null;
  if (_e && o && o.contentEditable == "false")
    return gl(o);
  if ((!o || o.contentEditable == "false") && (!i || i.contentEditable == "false")) {
    if (o)
      return gl(o);
    if (i)
      return gl(i);
  }
}
function gl(t) {
  return t.contentEditable = "true", _e && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function Ld(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function Yb(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, o = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != o) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!Ap(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function Xb(t) {
  let e = t.domSelection(), n = document.createRange();
  if (!e)
    return;
  let r = t.cursorWrapper.dom, o = r.nodeName == "IMG";
  o ? n.setStart(r.parentNode, Oe(r) + 1) : n.setStart(r, 0), n.collapse(!0), e.removeAllRanges(), e.addRange(n), !o && !t.state.selection.visible && We && vn <= 11 && (r.disabled = !0, r.disabled = !1);
}
function Op(t, e) {
  if (e instanceof z) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (Dd(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    Dd(t);
}
function Dd(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function mc(t, e, n, r) {
  return t.someProp("createSelectionBetween", (o) => o(t, e, n)) || V.between(e, n, r);
}
function Pd(t) {
  return t.editable && !t.hasFocus() ? !1 : Np(t);
}
function Np(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Qb(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return qn(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function pa(t, e) {
  let { $anchor: n, $head: r } = t.selection, o = e > 0 ? n.max(r) : n.min(r), i = o.parent.inlineContent ? o.depth ? t.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
  return i && K.findFrom(i, e);
}
function cn(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Bd(t, e, n) {
  let r = t.state.selection;
  if (r instanceof V)
    if (n.indexOf("s") > -1) {
      let { $head: o } = r, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!i || i.isText || !i.isLeaf)
        return !1;
      let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return cn(t, new V(r.$anchor, s));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = pa(t.state, e);
        return o && o instanceof z ? cn(t, o) : !1;
      } else if (!(nt && n.indexOf("m") > -1)) {
        let o = r.$head, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, s;
        if (!i || i.isText)
          return !1;
        let l = e < 0 ? o.pos - i.nodeSize : o.pos;
        return i.isAtom || (s = t.docView.descAt(l)) && !s.contentDOM ? z.isSelectable(i) ? cn(t, new z(e < 0 ? t.state.doc.resolve(o.pos - i.nodeSize) : o)) : Co ? cn(t, new V(t.state.doc.resolve(e < 0 ? l : l + i.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof z && r.node.isInline)
      return cn(t, new V(e > 0 ? r.$to : r.$from));
    {
      let o = pa(t.state, e);
      return o ? cn(t, o) : !1;
    }
  }
}
function xi(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Kr(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function sr(t, e) {
  return e < 0 ? eC(t) : tC(t);
}
function eC(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let o, i, s = !1;
  for (gt && n.nodeType == 1 && r < xi(n) && Kr(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let l = n.childNodes[r - 1];
        if (Kr(l, -1))
          o = n, i = --r;
        else if (l.nodeType == 3)
          n = l, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (Ip(n))
        break;
      {
        let l = n.previousSibling;
        for (; l && Kr(l, -1); )
          o = n.parentNode, i = Oe(l), l = l.previousSibling;
        if (l)
          n = l, r = xi(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  s ? ma(t, n, r) : o && ma(t, o, i);
}
function tC(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let o = xi(n), i, s;
  for (; ; )
    if (r < o) {
      if (n.nodeType != 1)
        break;
      let l = n.childNodes[r];
      if (Kr(l, 1))
        i = n, s = ++r;
      else
        break;
    } else {
      if (Ip(n))
        break;
      {
        let l = n.nextSibling;
        for (; l && Kr(l, 1); )
          i = l.parentNode, s = Oe(l) + 1, l = l.nextSibling;
        if (l)
          n = l, r = 0, o = xi(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = o = 0;
        }
      }
    }
  i && ma(t, i, s);
}
function Ip(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function nC(t, e) {
  for (; t && e == t.childNodes.length && !bo(t); )
    e = Oe(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function rC(t, e) {
  for (; t && !e && !bo(t); )
    e = Oe(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function ma(t, e, n) {
  if (e.nodeType != 3) {
    let i, s;
    (s = nC(e, n)) ? (e = s, n = 0) : (i = rC(e, n)) && (e = i, n = i.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (xs(r)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: o } = t;
  setTimeout(() => {
    t.state == o && Yt(t);
  }, 50);
}
function Hd(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(Pe || Eb) && n.parent.inlineContent) {
    let o = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left < o.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Fd(t, e, n) {
  let r = t.state.selection;
  if (r instanceof V && !r.empty || n.indexOf("s") > -1 || nt && n.indexOf("m") > -1)
    return !1;
  let { $from: o, $to: i } = r;
  if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = pa(t.state, e);
    if (s && s instanceof z)
      return cn(t, s);
  }
  if (!o.parent.inlineContent) {
    let s = e < 0 ? o : i, l = r instanceof Ge ? K.near(s, e) : K.findFrom(s, e);
    return l ? cn(t, l) : !1;
  }
  return !1;
}
function _d(t, e) {
  if (!(t.state.selection instanceof V))
    return !0;
  let { $head: n, $anchor: r, empty: o } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!o)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function zd(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function oC(t) {
  if (!_e || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    zd(t, r, "true"), setTimeout(() => zd(t, r, "false"), 20);
  }
  return !1;
}
function iC(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function sC(t, e) {
  let n = e.keyCode, r = iC(e);
  if (n == 8 || nt && n == 72 && r == "c")
    return _d(t, -1) || sr(t, -1);
  if (n == 46 && !e.shiftKey || nt && n == 68 && r == "c")
    return _d(t, 1) || sr(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || nt && n == 66 && r == "c") {
    let o = n == 37 ? Hd(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Bd(t, o, r) || sr(t, o);
  } else if (n == 39 || nt && n == 70 && r == "c") {
    let o = n == 39 ? Hd(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Bd(t, o, r) || sr(t, o);
  } else {
    if (n == 38 || nt && n == 80 && r == "c")
      return Fd(t, -1, r) || sr(t, -1);
    if (n == 40 || nt && n == 78 && r == "c")
      return oC(t) || Fd(t, 1, r) || sr(t, 1);
    if (r == (nt ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function gc(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: r, openStart: o, openEnd: i } = e;
  for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    o--, i--;
    let h = r.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content;
  }
  let s = t.someProp("clipboardSerializer") || Qn.fromSchema(t.state.schema), l = Fp(), a = l.createElement("div");
  a.appendChild(s.serializeFragment(r, { document: l }));
  let c = a.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = Hp[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let p = l.createElement(u[h]);
      for (; a.firstChild; )
        p.appendChild(a.firstChild);
      a.appendChild(p), d++;
    }
    c = a.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: a, text: f, slice: e };
}
function Lp(t, e, n, r, o) {
  let i = o.parent.type.spec.code, s, l;
  if (!n && !e)
    return null;
  let a = e && (r || i || !n);
  if (a) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, i || r, t);
    }), i)
      return e ? new B(A.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : B.empty;
    let d = t.someProp("clipboardTextParser", (f) => f(e, o, r, t));
    if (d)
      l = d;
    else {
      let f = o.marks(), { schema: h } = t.state, p = Qn.fromSchema(h);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let b = s.appendChild(document.createElement("p"));
        m && b.appendChild(p.serializeNode(h.text(m, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), s = uC(n), Co && dC(s);
  let c = s && s.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      s = f;
    }
  if (l || (l = (t.someProp("clipboardParser") || t.someProp("domParser") || Cn.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(a || u),
    context: o,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !lC.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    l = fC(Vd(l, +u[1], +u[2]), u[4]);
  else if (l = B.maxOpen(aC(l.content, o), !0), l.openStart || l.openEnd) {
    let d = 0, f = 0;
    for (let h = l.content.firstChild; d < l.openStart && !h.type.spec.isolating; d++, h = h.firstChild)
      ;
    for (let h = l.content.lastChild; f < l.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    l = Vd(l, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    l = d(l, t);
  }), l;
}
const lC = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function aC(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let o = e.node(n).contentMatchAt(e.index(n)), i, s = [];
    if (t.forEach((l) => {
      if (!s)
        return;
      let a = o.findWrapping(l.type), c;
      if (!a)
        return s = null;
      if (c = s.length && i.length && Pp(a, i, l, s[s.length - 1], 0))
        s[s.length - 1] = c;
      else {
        s.length && (s[s.length - 1] = Bp(s[s.length - 1], i.length));
        let u = Dp(l, a);
        s.push(u), o = o.matchType(u.type), i = a;
      }
    }), s)
      return A.from(s);
  }
  return t;
}
function Dp(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, A.from(t));
  return t;
}
function Pp(t, e, n, r, o) {
  if (o < t.length && o < e.length && t[o] == e[o]) {
    let i = Pp(t, e, n, r.lastChild, o + 1);
    if (i)
      return r.copy(r.content.replaceChild(r.childCount - 1, i));
    if (r.contentMatchAt(r.childCount).matchType(o == t.length - 1 ? n.type : t[o + 1]))
      return r.copy(r.content.append(A.from(Dp(n, t, o + 1))));
  }
}
function Bp(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, Bp(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(A.empty, !0);
  return t.copy(n.append(r));
}
function ga(t, e, n, r, o, i) {
  let s = e < 0 ? t.firstChild : t.lastChild, l = s.content;
  return t.childCount > 1 && (i = 0), o < r - 1 && (l = ga(l, e, n, r, o + 1, i)), o >= n && (l = e < 0 ? s.contentMatchAt(0).fillBefore(l, i <= o).append(l) : l.append(s.contentMatchAt(s.childCount).fillBefore(A.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(l));
}
function Vd(t, e, n) {
  return e < t.openStart && (t = new B(ga(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new B(ga(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const Hp = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let $d = null;
function Fp() {
  return $d || ($d = document.implementation.createHTMLDocument("title"));
}
let yl = null;
function cC(t) {
  let e = window.trustedTypes;
  return e ? (yl || (yl = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), yl.createHTML(t)) : t;
}
function uC(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = Fp().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), o;
  if ((o = r && Hp[r[1].toLowerCase()]) && (t = o.map((i) => "<" + i + ">").join("") + t + o.map((i) => "</" + i + ">").reverse().join("")), n.innerHTML = cC(t), o)
    for (let i = 0; i < o.length; i++)
      n = n.querySelector(o[i]) || n;
  return n;
}
function dC(t) {
  let e = t.querySelectorAll(Pe ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function fC(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: o, openStart: i, openEnd: s } = t;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let a = n.nodes[r[l]];
    if (!a || a.hasRequiredAttrs())
      break;
    o = A.from(a.create(r[l + 1], o)), i++, s++;
  }
  return new B(o, i, s);
}
const ze = {}, Ve = {}, hC = { touchstart: !0, touchmove: !0 };
class pC {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function mC(t) {
  for (let e in ze) {
    let n = ze[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      yC(t, r) && !yc(t, r) && (t.editable || !(r.type in Ve)) && n(t, r);
    }, hC[e] ? { passive: !0 } : void 0);
  }
  _e && t.dom.addEventListener("input", () => null), ya(t);
}
function yn(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function gC(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function ya(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => yc(t, r));
  });
}
function yc(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function yC(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function bC(t, e) {
  !yc(t, e) && ze[e.type] && (t.editable || !(e.type in Ve)) && ze[e.type](t, e);
}
Ve.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !zp(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(jt && Pe && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), Sr && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (o) => o(t, Bn(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || sC(t, n) ? n.preventDefault() : yn(t, "key");
};
Ve.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Ve.keypress = (t, e) => {
  let n = e;
  if (zp(t, n) || !n.charCode || n.ctrlKey && !n.altKey || nt && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (o) => o(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof V) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(n.charCode), i = () => t.state.tr.insertText(o).scrollIntoView();
    !/[\r\n]/.test(o) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, o, i)) && t.dispatch(i()), n.preventDefault();
  }
};
function Es(t) {
  return { left: t.clientX, top: t.clientY };
}
function CC(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function bc(t, e, n, r, o) {
  if (r == -1)
    return !1;
  let i = t.state.doc.resolve(r);
  for (let s = i.depth + 1; s > 0; s--)
    if (t.someProp(e, (l) => s > i.depth ? l(t, n, i.nodeAfter, i.before(s), o, !0) : l(t, n, i.node(s), i.before(s), o, !1)))
      return !0;
  return !1;
}
function yr(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function vC(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && z.isSelectable(r) ? (yr(t, new z(n)), !0) : !1;
}
function wC(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, o;
  n instanceof z && (r = n.node);
  let i = t.state.doc.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let l = s > i.depth ? i.nodeAfter : i.node(s);
    if (z.isSelectable(l)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? o = i.before(n.$from.depth) : o = i.before(s);
      break;
    }
  }
  return o != null ? (yr(t, z.create(t.state.doc, o)), !0) : !1;
}
function SC(t, e, n, r, o) {
  return bc(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (i) => i(t, e, r)) || (o ? wC(t, n) : vC(t, n));
}
function xC(t, e, n, r) {
  return bc(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (o) => o(t, e, r));
}
function kC(t, e, n, r) {
  return bc(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (o) => o(t, e, r)) || EC(t, n, r);
}
function EC(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (yr(t, V.create(r, 0, r.content.size)), !0) : !1;
  let o = r.resolve(e);
  for (let i = o.depth + 1; i > 0; i--) {
    let s = i > o.depth ? o.nodeAfter : o.node(i), l = o.before(i);
    if (s.inlineContent)
      yr(t, V.create(r, l + 1, l + 1 + s.content.size));
    else if (z.isSelectable(s))
      yr(t, z.create(r, l));
    else
      continue;
    return !0;
  }
}
function Cc(t) {
  return ki(t);
}
const _p = nt ? "metaKey" : "ctrlKey";
ze.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = Cc(t), o = Date.now(), i = "singleClick";
  o - t.input.lastClick.time < 500 && CC(n, t.input.lastClick) && !n[_p] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? i = "doubleClick" : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")), t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i, button: n.button };
  let s = t.posAtCoords(Es(n));
  s && (i == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new MC(t, s, n, !!r)) : (i == "doubleClick" ? xC : kC)(t, s.pos, s.inside, n) ? n.preventDefault() : yn(t, "pointer"));
};
class MC {
  constructor(e, n, r, o) {
    this.view = e, this.pos = n, this.event = r, this.flushed = o, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[_p], this.allowDefault = r.shiftKey;
    let i, s;
    if (n.inside > -1)
      i = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      i = u.parent, s = u.depth ? u.before() : 0;
    }
    const l = o ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = a && a.dom.nodeType == 1 ? a.dom : null;
    let { selection: c } = e.state;
    (r.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== !1 || c instanceof z && c.from <= s && c.to > s) && (this.mightDrag = {
      node: i,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gt && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), yn(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Yt(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Es(e))), this.updateAllowDefault(e), this.allowDefault || !n ? yn(this.view, "pointer") : SC(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    _e && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Pe && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (yr(this.view, K.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : yn(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), yn(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
ze.touchstart = (t) => {
  t.input.lastTouch = Date.now(), Cc(t), yn(t, "pointer");
};
ze.touchmove = (t) => {
  t.input.lastTouch = Date.now(), yn(t, "pointer");
};
ze.contextmenu = (t) => Cc(t);
function zp(t, e) {
  return t.composing ? !0 : _e && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const TC = jt ? 5e3 : -1;
Ve.compositionstart = Ve.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof V && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      t.markCursor = t.state.storedMarks || n.marks(), ki(t, !0), t.markCursor = null;
    else if (ki(t, !e.selection.empty), gt && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let o = r.focusNode, i = r.focusOffset; o && o.nodeType == 1 && i != 0; ) {
        let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let l = t.domSelection();
          l && l.collapse(s, s.nodeValue.length);
          break;
        } else
          o = s, i = -1;
      }
    }
    t.input.composing = !0;
  }
  Vp(t, TC);
};
Ve.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, Vp(t, 20));
};
function Vp(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => ki(t), e));
}
function $p(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = AC()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function RC(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = vb(e.focusNode, e.focusOffset), r = wb(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let o = r.pmViewDesc, i = t.domObserver.lastChangedTextNode;
    if (n == i || r == i)
      return i;
    if (!o || !o.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function AC() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function ki(t, e = !1) {
  if (!(jt && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), $p(t), e || t.docView && t.docView.dirty) {
      let n = pc(t), r = t.state.selection;
      return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function OC(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), o = document.createRange();
  o.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const ro = We && vn < 15 || Sr && Mb < 604;
ze.copy = Ve.cut = (t, e) => {
  let n = e, r = t.state.selection, o = n.type == "cut";
  if (r.empty)
    return;
  let i = ro ? null : n.clipboardData, s = r.content(), { dom: l, text: a } = gc(t, s);
  i ? (n.preventDefault(), i.clearData(), i.setData("text/html", l.innerHTML), i.setData("text/plain", a)) : OC(t, l), o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function NC(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function IC(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let o = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? oo(t, r.value, null, o, e) : oo(t, r.textContent, r.innerHTML, o, e);
  }, 50);
}
function oo(t, e, n, r, o) {
  let i = Lp(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (a) => a(t, o, i || B.empty)))
    return !0;
  if (!i)
    return !1;
  let s = NC(i), l = s ? t.state.tr.replaceSelectionWith(s, r) : t.state.tr.replaceSelection(i);
  return t.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function Up(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Ve.paste = (t, e) => {
  let n = e;
  if (t.composing && !jt)
    return;
  let r = ro ? null : n.clipboardData, o = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && oo(t, Up(r), r.getData("text/html"), o, n) ? n.preventDefault() : IC(t, n);
};
class Wp {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const LC = nt ? "altKey" : "ctrlKey";
function Kp(t, e) {
  let n = t.someProp("dragCopies", (r) => !r(e));
  return n ?? !e[LC];
}
ze.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let o = t.state.selection, i = o.empty ? null : t.posAtCoords(Es(n)), s;
  if (!(i && i.pos >= o.from && i.pos <= (o instanceof z ? o.to - 1 : o.to))) {
    if (r && r.mightDrag)
      s = z.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (s = z.create(t.state.doc, d.posBefore));
    }
  }
  let l = (s || t.state.selection).content(), { dom: a, text: c, slice: u } = gc(t, l);
  (!n.dataTransfer.files.length || !Pe || yp > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(ro ? "Text" : "text/html", a.innerHTML), n.dataTransfer.effectAllowed = "copyMove", ro || n.dataTransfer.setData("text/plain", c), t.dragging = new Wp(u, Kp(t, n), s);
};
ze.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Ve.dragover = Ve.dragenter = (t, e) => e.preventDefault();
Ve.drop = (t, e) => {
  let n = e, r = t.dragging;
  if (t.dragging = null, !n.dataTransfer)
    return;
  let o = t.posAtCoords(Es(n));
  if (!o)
    return;
  let i = t.state.doc.resolve(o.pos), s = r && r.slice;
  s ? t.someProp("transformPasted", (p) => {
    s = p(s, t);
  }) : s = Lp(t, Up(n.dataTransfer), ro ? null : n.dataTransfer.getData("text/html"), !1, i);
  let l = !!(r && Kp(t, n));
  if (t.someProp("handleDrop", (p) => p(t, n, s || B.empty, l))) {
    n.preventDefault();
    return;
  }
  if (!s)
    return;
  n.preventDefault();
  let a = s ? ap(t.state.doc, i.pos, s) : i.pos;
  a == null && (a = i.pos);
  let c = t.state.tr;
  if (l) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, s.content.firstChild) : c.replaceRange(u, u, s), c.doc.eq(f))
    return;
  let h = c.doc.resolve(u);
  if (d && z.isSelectable(s.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(s.content.firstChild))
    c.setSelection(new z(h));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, b, C, v) => p = v), c.setSelection(mc(t, h, c.doc.resolve(p)));
  }
  t.focus(), t.dispatch(c.setMeta("uiEvent", "drop"));
};
ze.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Yt(t);
  }, 20));
};
ze.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
ze.beforeinput = (t, e) => {
  if (Pe && jt && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (i) => i(t, Bn(8, "Backspace")))))
        return;
      let { $cursor: o } = t.state.selection;
      o && o.pos > 0 && t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Ve)
  ze[t] = Ve[t];
function io(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class Ei {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || $n, this.side = this.spec.side || 0;
  }
  map(e, n, r, o) {
    let { pos: i, deleted: s } = e.mapResult(n.from + o, this.side < 0 ? -1 : 1);
    return s ? null : new Ee(i - r, i - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Ei && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && io(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Sn {
  constructor(e, n) {
    this.attrs = e, this.spec = n || $n;
  }
  map(e, n, r, o) {
    let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
    return i >= s ? null : new Ee(i, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Sn && io(this.attrs, e.attrs) && io(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Sn;
  }
  destroy() {
  }
}
class vc {
  constructor(e, n) {
    this.attrs = e, this.spec = n || $n;
  }
  map(e, n, r, o) {
    let i = e.mapResult(n.from + o, 1);
    if (i.deleted)
      return null;
    let s = e.mapResult(n.to + o, -1);
    return s.deleted || s.pos <= i.pos ? null : new Ee(i.pos - r, s.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: o } = e.content.findIndex(n.from), i;
    return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof vc && io(this.attrs, e.attrs) && io(this.spec, e.spec);
  }
  destroy() {
  }
}
class Ee {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Ee(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Ee(e, e, new Ei(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, o) {
    return new Ee(e, n, new Sn(r, o));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, o) {
    return new Ee(e, n, new vc(r, o));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Sn;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Ei;
  }
}
const dr = [], $n = {};
class ae {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : dr, this.children = n.length ? n : dr;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? Mi(n, e, 0, $n) : Le;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let o = [];
    return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
  }
  findInner(e, n, r, o, i) {
    for (let s = 0; s < this.local.length; s++) {
      let l = this.local[s];
      l.from <= n && l.to >= e && (!i || i(l.spec)) && r.push(l.copy(l.from + o, l.to + o));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let l = this.children[s] + 1;
        this.children[s + 2].findInner(e - l, n - l, r, o + l, i);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Le || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || $n);
  }
  /**
  @internal
  */
  mapInner(e, n, r, o, i) {
    let s;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l].map(e, r, o);
      a && a.type.valid(n, a) ? (s || (s = [])).push(a) : i.onRemove && i.onRemove(this.local[l].spec);
    }
    return this.children.length ? DC(this.children, s || [], e, n, r, o, i) : s ? new ae(s.sort(Un), dr) : Le;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Le ? ae.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let o, i = 0;
    e.forEach((l, a) => {
      let c = a + r, u;
      if (u = qp(n, l, c)) {
        for (o || (o = this.children.slice()); i < o.length && o[i] < a; )
          i += 3;
        o[i] == a ? o[i + 2] = o[i + 2].addInner(l, u, c + 1) : o.splice(i, 0, a, a + l.nodeSize, Mi(u, l, c + 1, $n)), i += 3;
      }
    });
    let s = jp(i ? Gp(n) : n, -r);
    for (let l = 0; l < s.length; l++)
      s[l].type.valid(e, s[l]) || s.splice(l--, 1);
    return new ae(s.length ? this.local.concat(s).sort(Un) : this.local, o || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Le ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, o = this.local;
    for (let i = 0; i < r.length; i += 3) {
      let s, l = r[i] + n, a = r[i + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > l && d.to < a && (e[u] = null, (s || (s = [])).push(d));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[i + 2].removeInner(s, l + 1);
      c != Le ? r[i + 2] = c : (r.splice(i, 3), i -= 3);
    }
    if (o.length) {
      for (let i = 0, s; i < e.length; i++)
        if (s = e[i])
          for (let l = 0; l < o.length; l++)
            o[l].eq(s, n) && (o == this.local && (o = this.local.slice()), o.splice(l--, 1));
    }
    return r == this.children && o == this.local ? this : o.length || r.length ? new ae(o, r) : Le;
  }
  forChild(e, n) {
    if (this == Le)
      return this;
    if (n.isLeaf)
      return ae.empty;
    let r, o;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let i = e + 1, s = i + n.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l];
      if (a.from < s && a.to > i && a.type instanceof Sn) {
        let c = Math.max(i, a.from) - i, u = Math.min(s, a.to) - i;
        c < u && (o || (o = [])).push(a.copy(c, u));
      }
    }
    if (o) {
      let l = new ae(o.sort(Un), dr);
      return r ? new fn([l, r]) : l;
    }
    return r || Le;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof ae) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return wc(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Le)
      return dr;
    if (e.inlineContent || !this.local.some(Sn.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Sn || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
ae.empty = new ae([], []);
ae.removeOverlap = wc;
const Le = ae.empty;
class fn {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((o) => o.map(e, n, $n));
    return fn.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return ae.empty;
    let r = [];
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].forChild(e, n);
      i != Le && (i instanceof fn ? r = r.concat(i.members) : r.push(i));
    }
    return fn.from(r);
  }
  eq(e) {
    if (!(e instanceof fn) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].localsInner(e);
      if (i.length)
        if (!n)
          n = i;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < i.length; s++)
            n.push(i[s]);
        }
    }
    return n ? wc(r ? n : n.sort(Un)) : dr;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Le;
      case 1:
        return e[0];
      default:
        return new fn(e.every((n) => n instanceof ae) ? e : e.reduce((n, r) => n.concat(r instanceof ae ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function DC(t, e, n, r, o, i, s) {
  let l = t.slice();
  for (let c = 0, u = i; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, h, p, m) => {
      let b = m - p - (h - f);
      for (let C = 0; C < l.length; C += 3) {
        let v = l[C + 1];
        if (v < 0 || f > v + u - d)
          continue;
        let S = l[C] + u - d;
        h >= S ? l[C + 1] = f <= S ? -2 : -1 : f >= u && b && (l[C] += b, l[C + 1] += b);
      }
      d += b;
    }), u = n.maps[c].map(u, -1);
  }
  let a = !1;
  for (let c = 0; c < l.length; c += 3)
    if (l[c + 1] < 0) {
      if (l[c + 1] == -2) {
        a = !0, l[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + i), d = u - o;
      if (d < 0 || d >= r.content.size) {
        a = !0;
        continue;
      }
      let f = n.map(t[c + 1] + i, -1), h = f - o, { index: p, offset: m } = r.content.findIndex(d), b = r.maybeChild(p);
      if (b && m == d && m + b.nodeSize == h) {
        let C = l[c + 2].mapInner(n, b, u + 1, t[c] + i + 1, s);
        C != Le ? (l[c] = d, l[c + 1] = h, l[c + 2] = C) : (l[c + 1] = -2, a = !0);
      } else
        a = !0;
    }
  if (a) {
    let c = PC(l, t, e, n, o, i, s), u = Mi(c, r, 0, s);
    e = u.local;
    for (let d = 0; d < l.length; d += 3)
      l[d + 1] < 0 && (l.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h = u.children[d];
      for (; f < l.length && l[f] < h; )
        f += 3;
      l.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new ae(e.sort(Un), l);
}
function jp(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    n.push(new Ee(o.from + e, o.to + e, o.type));
  }
  return n;
}
function PC(t, e, n, r, o, i, s) {
  function l(a, c) {
    for (let u = 0; u < a.local.length; u++) {
      let d = a.local[u].map(r, o, c);
      d ? n.push(d) : s.onRemove && s.onRemove(a.local[u].spec);
    }
    for (let u = 0; u < a.children.length; u += 3)
      l(a.children[u + 2], a.children[u] + c + 1);
  }
  for (let a = 0; a < t.length; a += 3)
    t[a + 1] == -1 && l(t[a + 2], e[a] + i + 1);
  return n;
}
function qp(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, o = null;
  for (let i = 0, s; i < t.length; i++)
    (s = t[i]) && s.from > n && s.to < r && ((o || (o = [])).push(s), t[i] = null);
  return o;
}
function Gp(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function Mi(t, e, n, r) {
  let o = [], i = !1;
  e.forEach((l, a) => {
    let c = qp(t, l, a + n);
    if (c) {
      i = !0;
      let u = Mi(c, l, n + a + 1, r);
      u != Le && o.push(a, a + l.nodeSize, u);
    }
  });
  let s = jp(i ? Gp(t) : t, -n).sort(Un);
  for (let l = 0; l < s.length; l++)
    s[l].type.valid(e, s[l]) || (r.onRemove && r.onRemove(s[l].spec), s.splice(l--, 1));
  return s.length || o.length ? new ae(s, o) : Le;
}
function Un(t, e) {
  return t.from - e.from || t.to - e.to;
}
function wc(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let o = n + 1; o < e.length; o++) {
        let i = e[o];
        if (i.from == r.from) {
          i.to != r.to && (e == t && (e = t.slice()), e[o] = i.copy(i.from, r.to), Ud(e, o + 1, i.copy(r.to, i.to)));
          continue;
        } else {
          i.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, i.from), Ud(e, o, r.copy(i.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Ud(t, e, n) {
  for (; e < t.length && Un(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function bl(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Le && e.push(r);
  }), t.cursorWrapper && e.push(ae.create(t.state.doc, [t.cursorWrapper.deco])), fn.from(e);
}
const BC = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, HC = We && vn <= 11;
class FC {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class _C {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new FC(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let o = 0; o < r.length; o++)
        this.queue.push(r[o]);
      We && vn <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), HC && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, BC)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (Pd(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Yt(this.view);
      if (We && vn <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && qn(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let i = e.focusNode; i; i = wr(i))
      n.add(i);
    for (let i = e.anchorNode; i; i = wr(i))
      if (n.has(i)) {
        r = i;
        break;
      }
    let o = r && this.view.docView.nearestDesc(r);
    if (o && o.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && Pd(e) && !this.ignoreSelectionChange(r), i = -1, s = -1, l = !1, a = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], a);
        d && (i = i < 0 ? d.from : Math.min(d.from, i), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (l = !0));
      }
    if (gt && a.length) {
      let u = a.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let h = f.parentNode;
          h && h.nodeName == "LI" && (!d || $C(e, d) != h) && f.remove();
        }
      }
    }
    let c = null;
    i < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && xs(r) && (c = pc(e)) && c.eq(K.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Yt(e), this.currentSelection.set(r), e.scrollToSelection()) : (i > -1 || o) && (i > -1 && (e.docView.markDirty(i, s), zC(e)), this.handleDOMChange(i, s, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Yt(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let o = e.previousSibling, i = e.nextSibling;
      if (We && vn <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (o = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f);
        }
      let s = o && o.parentNode == e.target ? Oe(o) + 1 : 0, l = r.localPosFromDOM(e.target, s, -1), a = i && i.parentNode == e.target ? Oe(i) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1);
      return { from: l, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let Wd = /* @__PURE__ */ new WeakMap(), Kd = !1;
function zC(t) {
  if (!Wd.has(t) && (Wd.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = gt, Kd)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Kd = !0;
  }
}
function jd(t, e) {
  let n = e.startContainer, r = e.startOffset, o = e.endContainer, i = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return qn(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]), { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i };
}
function VC(t, e) {
  if (e.getComposedRanges) {
    let o = e.getComposedRanges(t.root)[0];
    if (o)
      return jd(t, o);
  }
  let n;
  function r(o) {
    o.preventDefault(), o.stopImmediatePropagation(), n = o.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? jd(t, n) : null;
}
function $C(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function UC(t, e, n) {
  let { node: r, fromOffset: o, toOffset: i, from: s, to: l } = t.docView.parseRange(e, n), a = t.domSelectionRange(), c, u = a.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], xs(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), Pe && t.input.lastKeyCode === 8)
    for (let b = i; b > o; b--) {
      let C = r.childNodes[b - 1], v = C.pmViewDesc;
      if (C.nodeName == "BR" && !v) {
        i = b;
        break;
      }
      if (!v || v.size)
        break;
    }
  let d = t.state.doc, f = t.someProp("domParser") || Cn.fromSchema(t.state.schema), h = d.resolve(s), p = null, m = f.parse(r, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: o,
    to: i,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: WC,
    context: h
  });
  if (c && c[0].pos != null) {
    let b = c[0].pos, C = c[1] && c[1].pos;
    C == null && (C = b), p = { anchor: b + s, head: C + s };
  }
  return { doc: m, sel: p, from: s, to: l };
}
function WC(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (_e && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || _e && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const KC = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function jC(t, e, n, r, o) {
  let i = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let M = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, N = pc(t, M);
    if (N && !t.state.selection.eq(N)) {
      if (Pe && jt && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (P) => P(t, Bn(13, "Enter"))))
        return;
      let T = t.state.tr.setSelection(N);
      M == "pointer" ? T.setMeta("pointer", !0) : M == "key" && T.scrollIntoView(), i && T.setMeta("composition", i), t.dispatch(T);
    }
    return;
  }
  let s = t.state.doc.resolve(e), l = s.sharedDepth(n);
  e = s.before(l + 1), n = t.state.doc.resolve(n).after(l + 1);
  let a = t.state.selection, c = UC(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), f, h;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, h = "end") : (f = t.state.selection.from, h = "start"), t.input.lastKeyCode = null;
  let p = ZC(d.content, c.doc.content, c.from, f, h);
  if (p && t.input.domChangeCount++, (Sr && t.input.lastIOSEnter > Date.now() - 225 || jt) && o.some((M) => M.nodeType == 1 && !KC.test(M.nodeName)) && (!p || p.endA >= p.endB) && t.someProp("handleKeyDown", (M) => M(t, Bn(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && a instanceof V && !a.empty && a.$head.sameParent(a.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (c.sel) {
        let M = qd(t, t.state.doc, c.sel);
        if (M && !M.eq(t.state.selection)) {
          let N = t.state.tr.setSelection(M);
          i && N.setMeta("composition", i), t.dispatch(N);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && p.start == p.endB && t.state.selection instanceof V && (p.start > t.state.selection.from && p.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? p.start = t.state.selection.from : p.endA < t.state.selection.to && p.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (p.endB += t.state.selection.to - p.endA, p.endA = t.state.selection.to)), We && vn <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), b = c.doc.resolveNoCache(p.endB - c.from), C = u.resolve(p.start), v = m.sameParent(b) && m.parent.inlineContent && C.end() >= p.endA, S;
  if ((Sr && t.input.lastIOSEnter > Date.now() - 225 && (!v || o.some((M) => M.nodeName == "DIV" || M.nodeName == "P")) || !v && m.pos < c.doc.content.size && (!m.sameParent(b) || !m.parent.inlineContent) && !/\S/.test(c.doc.textBetween(m.pos, b.pos, "", "")) && (S = K.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && S.head > m.pos) && t.someProp("handleKeyDown", (M) => M(t, Bn(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > p.start && GC(u, p.start, p.endA, m, b) && t.someProp("handleKeyDown", (M) => M(t, Bn(8, "Backspace")))) {
    jt && Pe && t.domObserver.suppressSelectionUpdates();
    return;
  }
  Pe && p.endB == p.start && (t.input.lastChromeDelete = Date.now()), jt && !v && m.start() != b.start() && b.parentOffset == 0 && m.depth == b.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, b = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(M) {
      return M(t, Bn(13, "Enter"));
    });
  }, 20));
  let w = p.start, x = p.endA, k = (M) => {
    let N = M || t.state.tr.replace(w, x, c.doc.slice(p.start - c.from, p.endB - c.from));
    if (c.sel) {
      let T = qd(t, N.doc, c.sel);
      T && !(Pe && t.composing && T.empty && (p.start != p.endB || t.input.lastChromeDelete < Date.now() - 100) && (T.head == w || T.head == N.mapping.map(x) - 1) || We && T.empty && T.head == w) && N.setSelection(T);
    }
    return i && N.setMeta("composition", i), N.scrollIntoView();
  }, E;
  if (v) {
    if (m.pos == b.pos) {
      We && vn <= 11 && m.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Yt(t), 20));
      let M = k(t.state.tr.delete(w, x)), N = u.resolve(p.start).marksAcross(u.resolve(p.endA));
      N && M.ensureMarks(N), t.dispatch(M);
    } else if (
      // Adding or removing a mark
      p.endA == p.endB && (E = qC(m.parent.content.cut(m.parentOffset, b.parentOffset), C.parent.content.cut(C.parentOffset, p.endA - C.start())))
    ) {
      let M = k(t.state.tr);
      E.type == "add" ? M.addMark(w, x, E.mark) : M.removeMark(w, x, E.mark), t.dispatch(M);
    } else if (m.parent.child(m.index()).isText && m.index() == b.index() - (b.textOffset ? 0 : 1)) {
      let M = m.parent.textBetween(m.parentOffset, b.parentOffset), N = () => k(t.state.tr.insertText(M, w, x));
      t.someProp("handleTextInput", (T) => T(t, w, x, M, N)) || t.dispatch(N());
    }
  } else
    t.dispatch(k());
}
function qd(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : mc(t, e.resolve(n.anchor), e.resolve(n.head));
}
function qC(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, o = n, i = r, s, l, a;
  for (let u = 0; u < r.length; u++)
    o = r[u].removeFromSet(o);
  for (let u = 0; u < n.length; u++)
    i = n[u].removeFromSet(i);
  if (o.length == 1 && i.length == 0)
    l = o[0], s = "add", a = (u) => u.mark(l.addToSet(u.marks));
  else if (o.length == 0 && i.length == 1)
    l = i[0], s = "remove", a = (u) => u.mark(l.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(a(e.child(u)));
  if (A.from(c).eq(t))
    return { mark: l, type: s };
}
function GC(t, e, n, r, o) {
  if (
    // The content must have shrunk
    n - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Cl(r, !0, !1) < o.pos
  )
    return !1;
  let i = t.resolve(e);
  if (!r.parent.isTextblock) {
    let l = i.nodeAfter;
    return l != null && n == e + l.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let s = t.resolve(Cl(i, !0, !0));
  return !s.parent.isTextblock || s.pos > n || Cl(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Cl(t, e, n) {
  let r = t.depth, o = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, o++, e = !1;
  if (n) {
    let i = t.node(r).maybeChild(t.indexAfter(r));
    for (; i && !i.isLeaf; )
      i = i.firstChild, o++;
  }
  return o;
}
function ZC(t, e, n, r, o) {
  let i = t.findDiffStart(e, n);
  if (i == null)
    return null;
  let { a: s, b: l } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (o == "end") {
    let a = Math.max(0, i - Math.min(s, l));
    r -= s + a - i;
  }
  if (s < i && t.size < e.size) {
    let a = r <= i && r >= s ? i - r : 0;
    i -= a, i && i < e.size && Gd(e.textBetween(i - 1, i + 1)) && (i += a ? 1 : -1), l = i + (l - s), s = i;
  } else if (l < i) {
    let a = r <= i && r >= l ? i - r : 0;
    i -= a, i && i < t.size && Gd(t.textBetween(i - 1, i + 1)) && (i += a ? 1 : -1), s = i + (s - l), l = i;
  }
  return { start: i, endA: s, endB: l };
}
function Gd(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Zp {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new pC(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Qd), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Yd(this), Jd(this), this.nodeViews = Xd(this), this.docView = Ad(this.state.doc, Zd(this), bl(this), this.dom, this), this.domObserver = new _C(this, (r, o, i, s) => jC(this, r, o, i, s)), this.domObserver.start(), mC(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && ya(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Qd), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let o = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && ($p(this), s = !0), this.state = e;
    let l = o.plugins != e.plugins || this._props.plugins != n.plugins;
    if (l || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h = Xd(this);
      YC(h, this.nodeViews) && (this.nodeViews = h, i = !0);
    }
    (l || n.handleDOMEvents != this._props.handleDOMEvents) && ya(this), this.editable = Yd(this), Jd(this);
    let a = bl(this), c = Zd(this), u = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", d = i || !this.docView.matchesNode(e.doc, c, a);
    (d || !e.selection.eq(o.selection)) && (s = !0);
    let f = u == "preserve" && s && this.dom.style.overflowAnchor == null && Ab(this);
    if (s) {
      this.domObserver.stop();
      let h = d && (We || Pe) && !this.composing && !o.selection.empty && !e.selection.empty && JC(o.selection, e.selection);
      if (d) {
        let p = Pe ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = RC(this)), (i || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Ad(e.doc, c, a, this.dom, this)), p && !this.trackWrites && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Qb(this)) ? Yt(this, h) : (Op(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && Ob(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof z) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && xd(this, n.getBoundingClientRect(), e);
      } else
        xd(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, o = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      o = r.from;
    else {
      let i = r.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
    }
    this.dragging = new Wp(e.slice, e.move, o < 0 ? void 0 : z.create(this.state.doc, o));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], o;
    if (r != null && (o = n ? n(r) : r))
      return o;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let l = this.directPlugins[s].props[e];
      if (l != null && (o = n ? n(l) : l))
        return o;
    }
    let i = this.state.plugins;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let l = i[s].props[e];
        if (l != null && (o = n ? n(l) : l))
          return o;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (We) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && Nb(this.dom), Yt(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return Bb(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return Sp(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let o = this.docView.posFromDOM(e, n, r);
    if (o == null)
      throw new RangeError("DOM position not inside the editor");
    return o;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return Vb(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return oo(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return oo(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return gc(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (gC(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], bl(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, bb());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return bC(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? _e && this.root.nodeType === 11 && xb(this.dom.ownerDocument) == this.dom && VC(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
Zp.prototype.dispatch = function(t) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, t) : this.updateState(this.state.apply(t));
};
function Zd(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [Ee.node(0, t.state.doc.content.size, e)];
}
function Jd(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: Ee.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function Yd(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function JC(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function Xd(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let o in r)
      Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function YC(t, e) {
  let n = 0, r = 0;
  for (let o in t) {
    if (t[o] != e[o])
      return !0;
    n++;
  }
  for (let o in e)
    r++;
  return n != r;
}
function Qd(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Mn = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ti = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, XC = typeof navigator < "u" && /Mac/.test(navigator.platform), QC = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ne = 0; Ne < 10; Ne++) Mn[48 + Ne] = Mn[96 + Ne] = String(Ne);
for (var Ne = 1; Ne <= 24; Ne++) Mn[Ne + 111] = "F" + Ne;
for (var Ne = 65; Ne <= 90; Ne++)
  Mn[Ne] = String.fromCharCode(Ne + 32), Ti[Ne] = String.fromCharCode(Ne);
for (var vl in Mn) Ti.hasOwnProperty(vl) || (Ti[vl] = Mn[vl]);
function ev(t) {
  var e = XC && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || QC && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Ti : Mn)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const tv = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), nv = typeof navigator < "u" && /Win/.test(navigator.platform);
function rv(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, o, i, s;
  for (let l = 0; l < e.length - 1; l++) {
    let a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      s = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      o = !0;
    else if (/^s(hift)?$/i.test(a))
      i = !0;
    else if (/^mod$/i.test(a))
      tv ? s = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return r && (n = "Alt-" + n), o && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i && (n = "Shift-" + n), n;
}
function ov(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[rv(n)] = t[n];
  return e;
}
function wl(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function iv(t) {
  return new ue({ props: { handleKeyDown: Sc(t) } });
}
function Sc(t) {
  let e = ov(t);
  return function(n, r) {
    let o = ev(r), i, s = e[wl(o, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let l = e[wl(o, r, !1)];
        if (l && l(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(nv && r.ctrlKey && r.altKey) && (i = Mn[r.keyCode]) && i != o) {
        let l = e[wl(i, r)];
        if (l && l(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
const xc = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Jp(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const Yp = (t, e, n) => {
  let r = Jp(t, n);
  if (!r)
    return !1;
  let o = kc(r);
  if (!o) {
    let s = r.blockRange(), l = s && Ar(s);
    return l == null ? !1 : (e && e(t.tr.lift(s, l).scrollIntoView()), !0);
  }
  let i = o.nodeBefore;
  if (sm(t, o, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (xr(i, "end") || z.isSelectable(i)))
    for (let s = r.depth; ; s--) {
      let l = ws(t.doc, r.before(s), r.after(s), B.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let a = t.tr.step(l);
          a.setSelection(xr(i, "end") ? K.findFrom(a.doc.resolve(a.mapping.map(o.pos, -1)), -1) : z.create(a.doc, o.pos - i.nodeSize)), e(a.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return i.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0) : !1;
}, sv = (t, e, n) => {
  let r = Jp(t, n);
  if (!r)
    return !1;
  let o = kc(r);
  return o ? Xp(t, o, e) : !1;
}, lv = (t, e, n) => {
  let r = em(t, n);
  if (!r)
    return !1;
  let o = Ec(r);
  return o ? Xp(t, o, e) : !1;
};
function Xp(t, e, n) {
  let r = e.nodeBefore, o = r, i = e.pos - 1;
  for (; !o.isTextblock; i--) {
    if (o.type.spec.isolating)
      return !1;
    let u = o.lastChild;
    if (!u)
      return !1;
    o = u;
  }
  let s = e.nodeAfter, l = s, a = e.pos + 1;
  for (; !l.isTextblock; a++) {
    if (l.type.spec.isolating)
      return !1;
    let u = l.firstChild;
    if (!u)
      return !1;
    l = u;
  }
  let c = ws(t.doc, i, a, B.empty);
  if (!c || c.from != i || c instanceof ke && c.slice.size >= a - i)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(V.create(u.doc, i)), n(u.scrollIntoView());
  }
  return !0;
}
function xr(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const Qp = (t, e, n) => {
  let { $head: r, empty: o } = t.selection, i = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    i = kc(r);
  }
  let s = i && i.nodeBefore;
  return !s || !z.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(z.create(t.doc, i.pos - s.nodeSize)).scrollIntoView()), !0);
};
function kc(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function em(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const tm = (t, e, n) => {
  let r = em(t, n);
  if (!r)
    return !1;
  let o = Ec(r);
  if (!o)
    return !1;
  let i = o.nodeAfter;
  if (sm(t, o, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (xr(i, "start") || z.isSelectable(i))) {
    let s = ws(t.doc, r.before(), r.after(), B.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let l = t.tr.step(s);
        l.setSelection(xr(i, "start") ? K.findFrom(l.doc.resolve(l.mapping.map(o.pos)), 1) : z.create(l.doc, l.mapping.map(o.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0) : !1;
}, nm = (t, e, n) => {
  let { $head: r, empty: o } = t.selection, i = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    i = Ec(r);
  }
  let s = i && i.nodeAfter;
  return !s || !z.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(z.create(t.doc, i.pos)).scrollIntoView()), !0);
};
function Ec(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const av = (t, e) => {
  let n = t.selection, r = n instanceof z, o;
  if (r) {
    if (n.node.isTextblock || !On(t.doc, n.from))
      return !1;
    o = n.from;
  } else if (o = vs(t.doc, n.from, -1), o == null)
    return !1;
  if (e) {
    let i = t.tr.join(o);
    r && i.setSelection(z.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)), e(i.scrollIntoView());
  }
  return !0;
}, cv = (t, e) => {
  let n = t.selection, r;
  if (n instanceof z) {
    if (n.node.isTextblock || !On(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = vs(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, uv = (t, e) => {
  let { $from: n, $to: r } = t.selection, o = n.blockRange(r), i = o && Ar(o);
  return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
}, rm = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Mc(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const dv = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let o = n.node(-1), i = n.indexAfter(-1), s = Mc(o.contentMatchAt(i));
  if (!s || !o.canReplaceWith(i, i, s))
    return !1;
  if (e) {
    let l = n.after(), a = t.tr.replaceWith(l, l, s.createAndFill());
    a.setSelection(K.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
  }
  return !0;
}, om = (t, e) => {
  let n = t.selection, { $from: r, $to: o } = n;
  if (n instanceof Ge || r.parent.inlineContent || o.parent.inlineContent)
    return !1;
  let i = Mc(o.parent.contentMatchAt(o.indexAfter()));
  if (!i || !i.isTextblock)
    return !1;
  if (e) {
    let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, l = t.tr.insert(s, i.createAndFill());
    l.setSelection(V.create(l.doc, s + 1)), e(l.scrollIntoView());
  }
  return !0;
}, im = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let i = n.before();
    if (Jt(t.doc, i))
      return e && e(t.tr.split(i).scrollIntoView()), !0;
  }
  let r = n.blockRange(), o = r && Ar(r);
  return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
};
function fv(t) {
  return (e, n) => {
    let { $from: r, $to: o } = e.selection;
    if (e.selection instanceof z && e.selection.node.isBlock)
      return !r.parentOffset || !Jt(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let i = [], s, l, a = !1, c = !1;
    for (let h = r.depth; ; h--)
      if (r.node(h).isBlock) {
        a = r.end(h) == r.pos + (r.depth - h), c = r.start(h) == r.pos - (r.depth - h), l = Mc(r.node(h - 1).contentMatchAt(r.indexAfter(h - 1))), i.unshift(a && l ? { type: l } : null), s = h;
        break;
      } else {
        if (h == 1)
          return !1;
        i.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof V || e.selection instanceof Ge) && u.deleteSelection();
    let d = u.mapping.map(r.pos), f = Jt(u.doc, d, i.length, i);
    if (f || (i[0] = l ? { type: l } : null, f = Jt(u.doc, d, i.length, i)), !f)
      return !1;
    if (u.split(d, i.length, i), !a && c && r.node(s).type != l) {
      let h = u.mapping.map(r.before(s)), p = u.doc.resolve(h);
      l && r.node(s - 1).canReplaceWith(p.index(), p.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(s)), l);
    }
    return n && n(u.scrollIntoView()), !0;
  };
}
const hv = fv(), pv = (t, e) => {
  let { $from: n, to: r } = t.selection, o, i = n.sharedDepth(r);
  return i == 0 ? !1 : (o = n.before(i), e && e(t.tr.setSelection(z.create(t.doc, o))), !0);
};
function mv(t, e, n) {
  let r = e.nodeBefore, o = e.nodeAfter, i = e.index();
  return !r || !o || !r.type.compatibleContent(o.type) ? !1 : !r.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || On(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function sm(t, e, n, r) {
  let o = e.nodeBefore, i = e.nodeAfter, s, l, a = o.type.spec.isolating || i.type.spec.isolating;
  if (!a && mv(t, e, n))
    return !0;
  let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (s = (l = o.contentMatchAt(o.childCount)).findWrapping(i.type)) && l.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let h = e.pos + i.nodeSize, p = A.empty;
      for (let C = s.length - 1; C >= 0; C--)
        p = A.from(s[C].create(null, p));
      p = A.from(o.copy(p));
      let m = t.tr.step(new Me(e.pos - 1, h, e.pos, h, new B(p, 1, 0), s.length, !0)), b = m.doc.resolve(h + 2 * s.length);
      b.nodeAfter && b.nodeAfter.type == o.type && On(m.doc, b.pos) && m.join(b.pos), n(m.scrollIntoView());
    }
    return !0;
  }
  let u = i.type.spec.isolating || r > 0 && a ? null : K.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Ar(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (c && xr(i, "start", !0) && xr(o, "end")) {
    let h = o, p = [];
    for (; p.push(h), !h.isTextblock; )
      h = h.lastChild;
    let m = i, b = 1;
    for (; !m.isTextblock; m = m.firstChild)
      b++;
    if (h.canReplace(h.childCount, h.childCount, m.content)) {
      if (n) {
        let C = A.empty;
        for (let S = p.length - 1; S >= 0; S--)
          C = A.from(p[S].copy(C));
        let v = t.tr.step(new Me(e.pos - p.length, e.pos + i.nodeSize, e.pos + b, e.pos + i.nodeSize - b, new B(C, p.length, 0), 0, !0));
        n(v.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function lm(t) {
  return function(e, n) {
    let r = e.selection, o = t < 0 ? r.$from : r.$to, i = o.depth;
    for (; o.node(i).isInline; ) {
      if (!i)
        return !1;
      i--;
    }
    return o.node(i).isTextblock ? (n && n(e.tr.setSelection(V.create(e.doc, t < 0 ? o.start(i) : o.end(i)))), !0) : !1;
  };
}
const gv = lm(-1), yv = lm(1);
function bv(t, e = null) {
  return function(n, r) {
    let { $from: o, $to: i } = n.selection, s = o.blockRange(i), l = s && uc(s, t, e);
    return l ? (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) : !1;
  };
}
function ef(t, e = null) {
  return function(n, r) {
    let o = !1;
    for (let i = 0; i < n.selection.ranges.length && !o; i++) {
      let { $from: { pos: s }, $to: { pos: l } } = n.selection.ranges[i];
      n.doc.nodesBetween(s, l, (a, c) => {
        if (o)
          return !1;
        if (!(!a.isTextblock || a.hasMarkup(t, e)))
          if (a.type == t)
            o = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            o = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!o)
      return !1;
    if (r) {
      let i = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: l }, $to: { pos: a } } = n.selection.ranges[s];
        i.setBlockType(l, a, t, e);
      }
      r(i.scrollIntoView());
    }
    return !0;
  };
}
function Tc(...t) {
  return function(e, n, r) {
    for (let o = 0; o < t.length; o++)
      if (t[o](e, n, r))
        return !0;
    return !1;
  };
}
Tc(xc, Yp, Qp);
Tc(xc, tm, nm);
Tc(rm, om, im, hv);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function Cv(t, e = null) {
  return function(n, r) {
    let { $from: o, $to: i } = n.selection, s = o.blockRange(i);
    if (!s)
      return !1;
    let l = r ? n.tr : null;
    return vv(l, s, t, e) ? (r && r(l.scrollIntoView()), !0) : !1;
  };
}
function vv(t, e, n, r = null) {
  let o = !1, i = e, s = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let a = s.resolve(e.start - 2);
    i = new vi(a, a, e.depth), e.endIndex < e.parent.childCount && (e = new vi(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), o = !0;
  }
  let l = uc(i, n, r, e);
  return l ? (t && wv(t, e, l, o, n), !0) : !1;
}
function wv(t, e, n, r, o) {
  let i = A.empty;
  for (let u = n.length - 1; u >= 0; u--)
    i = A.from(n[u].type.create(n[u].attrs, i));
  t.step(new Me(e.start - (r ? 2 : 0), e.end, e.start, e.end, new B(i, 0, 0), n.length, !0));
  let s = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == o && (s = u + 1);
  let l = n.length - s, a = e.start + n.length - (r ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && Jt(t.doc, a, l) && (t.split(a, l), a += 2 * l), a += c.child(u).nodeSize;
  return t;
}
function Sv(t) {
  return function(e, n) {
    let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t);
    return i ? n ? r.node(i.depth - 1).type == t ? xv(e, n, t, i) : kv(e, n, i) : !0 : !1;
  };
}
function xv(t, e, n, r) {
  let o = t.tr, i = r.end, s = r.$to.end(r.depth);
  i < s && (o.step(new Me(i - 1, s, i, s, new B(A.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new vi(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
  const l = Ar(r);
  if (l == null)
    return !1;
  o.lift(r, l);
  let a = o.doc.resolve(o.mapping.map(i, -1) - 1);
  return On(o.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && o.join(a.pos), e(o.scrollIntoView()), !0;
}
function kv(t, e, n) {
  let r = t.tr, o = n.parent;
  for (let h = n.end, p = n.endIndex - 1, m = n.startIndex; p > m; p--)
    h -= o.child(p).nodeSize, r.delete(h - 1, h + 1);
  let i = r.doc.resolve(n.start), s = i.nodeAfter;
  if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
    return !1;
  let l = n.startIndex == 0, a = n.endIndex == o.childCount, c = i.node(-1), u = i.index(-1);
  if (!c.canReplace(u + (l ? 0 : 1), u + 1, s.content.append(a ? A.empty : A.from(o))))
    return !1;
  let d = i.pos, f = d + s.nodeSize;
  return r.step(new Me(d - (l ? 1 : 0), f + (a ? 1 : 0), d + 1, f - 1, new B((l ? A.empty : A.from(o.copy(A.empty))).append(a ? A.empty : A.from(o.copy(A.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function Ev(t) {
  return function(e, n) {
    let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!i)
      return !1;
    let s = i.startIndex;
    if (s == 0)
      return !1;
    let l = i.parent, a = l.child(s - 1);
    if (a.type != t)
      return !1;
    if (n) {
      let c = a.lastChild && a.lastChild.type == l.type, u = A.from(c ? t.create() : null), d = new B(A.from(t.create(null, A.from(l.type.create(null, u)))), c ? 3 : 1, 0), f = i.start, h = i.end;
      n(e.tr.step(new Me(f - (c ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
var Mv = Object.defineProperty, am = (t, e) => {
  for (var n in e)
    Mv(t, n, { get: e[n], enumerable: !0 });
};
function Ms(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: o } = n, { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return r = n.selection, o = n.doc, i = n.storedMarks, n;
    }
  };
}
var Ts = class {
  constructor(t) {
    this.editor = t.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = t.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: t, editor: e, state: n } = this, { view: r } = e, { tr: o } = n, i = this.buildProps(o);
    return Object.fromEntries(
      Object.entries(t).map(([s, l]) => [s, (...c) => {
        const u = l(...c)(i);
        return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o), u;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(t, e = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = [], l = !!t, a = t || o.tr, c = () => (!l && e && !a.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(a), s.every((d) => d === !0)), u = {
      ...Object.fromEntries(
        Object.entries(n).map(([d, f]) => [d, (...p) => {
          const m = this.buildProps(a, e), b = f(...p)(m);
          return s.push(b), u;
        }])
      ),
      run: c
    };
    return u;
  }
  createCan(t) {
    const { rawCommands: e, state: n } = this, r = !1, o = t || n.tr, i = this.buildProps(o, r);
    return {
      ...Object.fromEntries(
        Object.entries(e).map(([l, a]) => [l, (...c) => a(...c)({ ...i, dispatch: void 0 })])
      ),
      chain: () => this.createChain(o, r)
    };
  }
  buildProps(t, e = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = {
      tr: t,
      editor: r,
      view: i,
      state: Ms({
        state: o,
        transaction: t
      }),
      dispatch: e ? () => {
      } : void 0,
      chain: () => this.createChain(t, e),
      can: () => this.createCan(t),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([l, a]) => [l, (...c) => a(...c)(s)])
        );
      }
    };
    return s;
  }
}, Tv = class {
  constructor() {
    this.callbacks = {};
  }
  on(t, e) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), this;
  }
  emit(t, ...e) {
    const n = this.callbacks[t];
    return n && n.forEach((r) => r.apply(this, e)), this;
  }
  off(t, e) {
    const n = this.callbacks[t];
    return n && (e ? this.callbacks[t] = n.filter((r) => r !== e) : delete this.callbacks[t]), this;
  }
  once(t, e) {
    const n = (...r) => {
      this.off(t, n), e.apply(this, r);
    };
    return this.on(t, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function cm(t, e) {
  const n = new dc(t);
  return e.forEach((r) => {
    r.steps.forEach((o) => {
      n.step(o);
    });
  }), n;
}
var um = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && um(r);
  }
  return t;
};
function Fo(t) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return um(n);
}
function so(t, e, n) {
  if (t instanceof bn || t instanceof A)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, o = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return A.fromArray(t.map((l) => e.nodeFromJSON(l)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", i), so("", e, n);
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1, l = "";
      const a = new Yh({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, l = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Cn.fromSchema(a).parseSlice(Fo(t), n.parseOptions) : Cn.fromSchema(a).parse(Fo(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${l}`)
        });
    }
    const i = Cn.fromSchema(e);
    return n.slice ? i.parseSlice(Fo(t), n.parseOptions).content : i.parse(Fo(t), n.parseOptions);
  }
  return so("", e, n);
}
function ba(t, e, n = {}, r = {}) {
  return so(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
function Rv(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Av(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (o, i) => {
    n(o) && r.push({
      node: o,
      pos: i
    });
  }), r;
}
function dm(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function Rs(t) {
  return (e) => dm(e.$from, t);
}
function U(t, e, n) {
  return t.config[e] === void 0 && t.parent ? U(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? U(t.parent, e, n) : null
  }) : t.config[e];
}
function Rc(t) {
  return t.map((e) => {
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    }, r = U(e, "addExtensions", n);
    return r ? [e, ...Rc(r())] : e;
  }).flat(10);
}
function Ac(t, e) {
  const n = Qn.fromSchema(e).serializeFragment(t), o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(n), o.innerHTML;
}
function fm(t) {
  return typeof t == "function";
}
function ee(t, e = void 0, ...n) {
  return fm(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function Ov(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function lo(t) {
  const e = t.filter((o) => o.type === "extension"), n = t.filter((o) => o.type === "node"), r = t.filter((o) => o.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function hm(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = lo(t), o = [...n, ...r], i = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const l = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: o
    }, a = U(
      s,
      "addGlobalAttributes",
      l
    );
    if (!a)
      return;
    a().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...i,
              ...h
            }
          });
        });
      });
    });
  }), o.forEach((s) => {
    const l = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, a = U(
      s,
      "addAttributes",
      l
    );
    if (!a)
      return;
    const c = a();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...i,
        ...d
      };
      typeof f?.default == "function" && (f.default = f.default()), f?.isRequired && f?.default === void 0 && delete f.default, e.push({
        type: s.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function X(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([o, i]) => {
      if (!r[o]) {
        r[o] = i;
        return;
      }
      if (o === "class") {
        const l = i ? String(i).split(" ") : [], a = r[o] ? r[o].split(" ") : [], c = l.filter((u) => !a.includes(u));
        r[o] = [...a, ...c].join(" ");
      } else if (o === "style") {
        const l = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], a = r[o] ? r[o].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        a.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), l.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), r[o] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        r[o] = i;
    }), r;
  }, {});
}
function ao(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => X(n, r), {});
}
function Nv(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function tf(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const o = e.reduce((i, s) => {
        const l = s.attribute.parseHTML ? s.attribute.parseHTML(n) : Nv(n.getAttribute(s.name));
        return l == null ? i : {
          ...i,
          [s.name]: l
        };
      }, {});
      return { ...r, ...o };
    }
  };
}
function nf(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && Ov(n) ? !1 : n != null)
  );
}
function Iv(t, e) {
  var n;
  const r = hm(t), { nodeExtensions: o, markExtensions: i } = lo(t), s = (n = o.find((c) => U(c, "topNode"))) == null ? void 0 : n.name, l = Object.fromEntries(
    o.map((c) => {
      const u = r.filter((C) => C.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = t.reduce((C, v) => {
        const S = U(v, "extendNodeSchema", d);
        return {
          ...C,
          ...S ? S(c) : {}
        };
      }, {}), h = nf({
        ...f,
        content: ee(U(c, "content", d)),
        marks: ee(U(c, "marks", d)),
        group: ee(U(c, "group", d)),
        inline: ee(U(c, "inline", d)),
        atom: ee(U(c, "atom", d)),
        selectable: ee(U(c, "selectable", d)),
        draggable: ee(U(c, "draggable", d)),
        code: ee(U(c, "code", d)),
        whitespace: ee(U(c, "whitespace", d)),
        linebreakReplacement: ee(
          U(c, "linebreakReplacement", d)
        ),
        defining: ee(U(c, "defining", d)),
        isolating: ee(U(c, "isolating", d)),
        attrs: Object.fromEntries(
          u.map((C) => {
            var v, S;
            return [
              C.name,
              { default: (v = C?.attribute) == null ? void 0 : v.default, validate: (S = C?.attribute) == null ? void 0 : S.validate }
            ];
          })
        )
      }), p = ee(U(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (C) => tf(C, u)
      ));
      const m = U(c, "renderHTML", d);
      m && (h.toDOM = (C) => m({
        node: C,
        HTMLAttributes: ao(C, u)
      }));
      const b = U(c, "renderText", d);
      return b && (h.toText = b), [c.name, h];
    })
  ), a = Object.fromEntries(
    i.map((c) => {
      const u = r.filter((b) => b.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = t.reduce((b, C) => {
        const v = U(C, "extendMarkSchema", d);
        return {
          ...b,
          ...v ? v(c) : {}
        };
      }, {}), h = nf({
        ...f,
        inclusive: ee(U(c, "inclusive", d)),
        excludes: ee(U(c, "excludes", d)),
        group: ee(U(c, "group", d)),
        spanning: ee(U(c, "spanning", d)),
        code: ee(U(c, "code", d)),
        attrs: Object.fromEntries(
          u.map((b) => {
            var C, v;
            return [
              b.name,
              { default: (C = b?.attribute) == null ? void 0 : C.default, validate: (v = b?.attribute) == null ? void 0 : v.validate }
            ];
          })
        )
      }), p = ee(U(c, "parseHTML", d));
      p && (h.parseDOM = p.map(
        (b) => tf(b, u)
      ));
      const m = U(c, "renderHTML", d);
      return m && (h.toDOM = (b) => m({
        mark: b,
        HTMLAttributes: ao(b, u)
      })), [c.name, h];
    })
  );
  return new Yh({
    topNode: s,
    nodes: l,
    marks: a
  });
}
function Lv(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
function Oc(t) {
  return t.sort((n, r) => {
    const o = U(n, "priority") || 100, i = U(r, "priority") || 100;
    return o > i ? -1 : o < i ? 1 : 0;
  });
}
function pm(t) {
  const e = Oc(Rc(t)), n = Lv(e.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), e;
}
function mm(t, e, n) {
  const { from: r, to: o } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let l = "";
  return t.nodesBetween(r, o, (a, c, u, d) => {
    var f;
    a.isBlock && c > r && (l += i);
    const h = s?.[a.type.name];
    if (h)
      return u && (l += h({
        node: a,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    a.isText && (l += (f = a?.text) == null ? void 0 : f.slice(Math.max(r, c) - c, o - c));
  }), l;
}
function gm(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return mm(t, n, e);
}
function Nc(t) {
  return Object.fromEntries(
    Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText])
  );
}
function tn(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
function ym(t, e) {
  const n = tn(e, t.schema), { from: r, to: o, empty: i } = t.selection, s = [];
  i ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, o, (a) => {
    s.push(...a.marks);
  });
  const l = s.find((a) => a.type.name === n.name);
  return l ? { ...l.attrs } : {};
}
function Se(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
function Dv(t, e) {
  const n = Se(e, t.schema), { from: r, to: o } = t.selection, i = [];
  t.doc.nodesBetween(r, o, (l) => {
    i.push(l);
  });
  const s = i.reverse().find((l) => l.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function As(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function bm(t, e) {
  const n = As(
    typeof e == "string" ? e : e.name,
    t.schema
  );
  return n === "node" ? Dv(t, e) : n === "mark" ? ym(t, e) : {};
}
function Pv(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const o = e(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0;
  });
}
function Bv(t) {
  const e = Pv(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((i, s) => s !== r).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function Cm(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((o, i) => {
    const s = [];
    if (o.ranges.length)
      o.forEach((l, a) => {
        s.push({ from: l, to: a });
      });
    else {
      const { from: l, to: a } = n[i];
      if (l === void 0 || a === void 0)
        return;
      s.push({ from: l, to: a });
    }
    s.forEach(({ from: l, to: a }) => {
      const c = e.slice(i).map(l, -1), u = e.slice(i).map(a), d = e.invert().map(c, -1), f = e.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), Bv(r);
}
function Ic(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
function Ri(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((o) => n.strict ? e[o] === t[o] : Ic(e[o]) ? e[o].test(t[o]) : e[o] === t[o]) : !0;
}
function vm(t, e, n = {}) {
  return t.find((r) => r.type === e && Ri(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
    n
  ));
}
function rf(t, e, n = {}) {
  return !!vm(t, e, n);
}
function Lc(t, e, n) {
  var r;
  if (!t || !e)
    return;
  let o = t.parent.childAfter(t.parentOffset);
  if ((!o.node || !o.node.marks.some((u) => u.type === e)) && (o = t.parent.childBefore(t.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === e) || (n = n || ((r = o.node.marks[0]) == null ? void 0 : r.attrs), !vm([...o.node.marks], e, n)))
    return;
  let s = o.index, l = t.start() + o.offset, a = s + 1, c = l + o.node.nodeSize;
  for (; s > 0 && rf([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, l -= t.parent.child(s).nodeSize;
  for (; a < t.parent.childCount && rf([...t.parent.child(a).marks], e, n); )
    c += t.parent.child(a).nodeSize, a += 1;
  return {
    from: l,
    to: c
  };
}
function Dc(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((o) => {
    const i = n.resolve(t), s = Lc(i, o.type);
    s && r.push({
      mark: o,
      ...s
    });
  }) : n.nodesBetween(t, e, (o, i) => {
    !o || o?.nodeSize === void 0 || r.push(
      ...o.marks.map((s) => ({
        from: i,
        to: i + o.nodeSize,
        mark: s
      }))
    );
  }), r;
}
var Hv = (t, e, n, r = 20) => {
  const o = t.doc.resolve(n);
  let i = r, s = null;
  for (; i > 0 && s === null; ) {
    const l = o.node(i);
    l?.type.name === e ? s = l : i -= 1;
  }
  return [s, i];
};
function Sl(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function li(t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = t.find((i) => i.type === e && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
var Fv = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, l) => {
    var a, c;
    const u = ((c = (a = o.type.spec).toText) == null ? void 0 : c.call(a, {
      node: o,
      pos: i,
      parent: s,
      index: l
    })) || o.textContent || "%leaf%";
    n += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i));
  }), n;
};
function Ca(t, e, n = {}) {
  const { empty: r, ranges: o } = t.selection, i = e ? tn(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : !0).find((d) => Ri(d.attrs, n, { strict: !1 }));
  let s = 0;
  const l = [];
  if (o.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, p = f.pos;
    t.doc.nodesBetween(h, p, (m, b) => {
      if (!m.isText && !m.marks.length)
        return;
      const C = Math.max(h, b), v = Math.min(p, b + m.nodeSize), S = v - C;
      s += S, l.push(
        ...m.marks.map((w) => ({
          mark: w,
          from: C,
          to: v
        }))
      );
    });
  }), s === 0)
    return !1;
  const a = l.filter((d) => i ? i.name === d.mark.type.name : !0).filter((d) => Ri(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = l.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (a > 0 ? a + c : a) >= s;
}
function Tn(t, e, n = {}) {
  const { from: r, to: o, empty: i } = t.selection, s = e ? Se(e, t.schema) : null, l = [];
  t.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(r, f), p = Math.min(o, f + d.nodeSize);
    l.push({
      node: d,
      from: h,
      to: p
    });
  });
  const a = o - r, c = l.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => Ri(d.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= a;
}
function _v(t, e, n = {}) {
  if (!e)
    return Tn(t, null, n) || Ca(t, null, n);
  const r = As(e, t.schema);
  return r === "node" ? Tn(t, e, n) : r === "mark" ? Ca(t, e, n) : !1;
}
var zv = (t, e) => {
  const { $from: n, $to: r, $anchor: o } = t.selection;
  if (e) {
    const i = Rs((l) => l.type.name === e)(t.selection);
    if (!i)
      return !1;
    const s = t.doc.resolve(i.pos + 1);
    return o.pos + 1 === s.end();
  }
  return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
}, Vv = (t) => {
  const { $from: e, $to: n } = t.selection;
  return !(e.parentOffset > 0 || e.pos !== n.pos);
};
function of(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function sf(t, e) {
  const { nodeExtensions: n } = lo(e), r = n.find((s) => s.name === t);
  if (!r)
    return !1;
  const o = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, i = ee(U(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function Os(t, {
  checkChildren: e = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) != null ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let o = !0;
    return t.content.forEach((i) => {
      o !== !1 && (Os(i, { ignoreWhitespace: n, checkChildren: e }) || (o = !1));
    }), o;
  }
  return !1;
}
function wm(t) {
  return t instanceof z;
}
function Pc(t) {
  return t instanceof V;
}
function qt(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function Sm(t, e, n) {
  const o = t.state.doc.content.size, i = qt(e, 0, o), s = qt(n, 0, o), l = t.coordsAtPos(i), a = t.coordsAtPos(s, -1), c = Math.min(l.top, a.top), u = Math.max(l.bottom, a.bottom), d = Math.min(l.left, a.left), f = Math.max(l.right, a.right), h = f - d, p = u - c, C = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: p,
    x: d,
    y: c
  };
  return {
    ...C,
    toJSON: () => C
  };
}
function xm(t, e = null) {
  if (!e)
    return null;
  const n = K.atStart(t), r = K.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const o = n.from, i = r.to;
  return e === "all" ? V.create(t, qt(0, o, i), qt(t.content.size, o, i)) : V.create(t, qt(e, o, i), qt(e, o, i));
}
function $v(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const o = t.steps[r];
  if (!(o instanceof ke || o instanceof Me))
    return;
  const i = t.mapping.maps[r];
  let s = 0;
  i.forEach((l, a, c, u) => {
    s === 0 && (s = u);
  }), t.setSelection(K.near(t.doc.resolve(s), n));
}
var wo = class {
  constructor(t) {
    var e;
    this.find = t.find, this.handler = t.handler, this.undoable = (e = t.undoable) != null ? e : !0;
  }
}, Uv = (t, e) => {
  if (Ic(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function _o(t) {
  var e;
  const { editor: n, from: r, to: o, text: i, rules: s, plugin: l } = t, { view: a } = n;
  if (a.composing)
    return !1;
  const c = a.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || (e = c.nodeBefore || c.nodeAfter) != null && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = Fv(c) + i;
  return s.forEach((f) => {
    if (u)
      return;
    const h = Uv(d, f.find);
    if (!h)
      return;
    const p = a.state.tr, m = Ms({
      state: a.state,
      transaction: p
    }), b = {
      from: r - (h[0].length - i.length),
      to: o
    }, { commands: C, chain: v, can: S } = new Ts({
      editor: n,
      state: m
    });
    f.handler({
      state: m,
      range: b,
      match: h,
      commands: C,
      chain: v,
      can: S
    }) === null || !p.steps.length || (f.undoable && p.setMeta(l, {
      transform: p,
      from: r,
      to: o,
      text: i
    }), a.dispatch(p), u = !0);
  }), u;
}
function Wv(t) {
  const { editor: e, rules: n } = t, r = new ue({
    state: {
      init() {
        return null;
      },
      apply(o, i, s) {
        const l = o.getMeta(r);
        if (l)
          return l;
        const a = o.getMeta("applyInputRules");
        return !!a && setTimeout(() => {
          let { text: u } = a;
          typeof u == "string" ? u = u : u = Ac(A.from(u), s.schema);
          const { from: d } = a, f = d + u.length;
          _o({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: r
          });
        }), o.selectionSet || o.docChanged ? null : i;
      }
    },
    props: {
      handleTextInput(o, i, s, l) {
        return _o({
          editor: e,
          from: i,
          to: s,
          text: l,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (o) => (setTimeout(() => {
          const { $cursor: i } = o.state.selection;
          i && _o({
            editor: e,
            from: i.pos,
            to: i.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(o, i) {
        if (i.key !== "Enter")
          return !1;
        const { $cursor: s } = o.state.selection;
        return s ? _o({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function Kv(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function zo(t) {
  return Kv(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function km(t, e) {
  const n = { ...t };
  return zo(t) && zo(e) && Object.keys(e).forEach((r) => {
    zo(e[r]) && zo(t[r]) ? n[r] = km(t[r], e[r]) : n[r] = e[r];
  }), n;
}
var Bc = class {
  constructor(t = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...ee(
        U(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...ee(
        U(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(t = {}) {
    const e = this.extend({
      ...this.config,
      addOptions: () => km(this.options, t)
    });
    return e.name = this.name, e.parent = this.parent, e;
  }
  extend(t = {}) {
    const e = new this.constructor({ ...this.config, ...t });
    return e.parent = this, this.child = e, e.name = "name" in t ? t.name : e.parent.name, e;
  }
}, Ct = class Em extends Bc {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new Em(n);
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const s = o.marks();
      if (!!!s.find((c) => c?.type.name === n.name))
        return !1;
      const a = s.find((c) => c?.type.name === n.name);
      return a && r.removeStoredMark(a), r.insertText(" ", o.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
};
function jv(t) {
  return typeof t == "number";
}
var qv = class {
  constructor(t) {
    this.find = t.find, this.handler = t.handler;
  }
}, Gv = (t, e, n) => {
  if (Ic(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((o) => {
    const i = [o.text];
    return i.index = o.index, i.input = t, i.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(o.replaceWith)), i;
  }) : [];
};
function Zv(t) {
  const { editor: e, state: n, from: r, to: o, rule: i, pasteEvent: s, dropEvent: l } = t, { commands: a, chain: c, can: u } = new Ts({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(r, o, (h, p) => {
    var m, b, C, v, S;
    if ((b = (m = h.type) == null ? void 0 : m.spec) != null && b.code || !(h.isText || h.isTextblock || h.isInline))
      return;
    const w = (S = (v = (C = h.content) == null ? void 0 : C.size) != null ? v : h.nodeSize) != null ? S : 0, x = Math.max(r, p), k = Math.min(o, p + w);
    if (x >= k)
      return;
    const E = h.isText ? h.text || "" : h.textBetween(x - p, k - p, void 0, "￼");
    Gv(E, i.find, s).forEach((N) => {
      if (N.index === void 0)
        return;
      const T = x + N.index + 1, P = T + N[0].length, _ = {
        from: n.tr.mapping.map(T),
        to: n.tr.mapping.map(P)
      }, F = i.handler({
        state: n,
        range: _,
        match: N,
        commands: a,
        chain: c,
        can: u,
        pasteEvent: s,
        dropEvent: l
      });
      d.push(F);
    });
  }), d.every((h) => h !== null);
}
var Vo = null, Jv = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) == null || e.setData("text/html", t), n;
};
function Yv(t) {
  const { editor: e, rules: n } = t;
  let r = null, o = !1, i = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, l;
  try {
    l = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    l = null;
  }
  const a = ({
    state: u,
    from: d,
    to: f,
    rule: h,
    pasteEvt: p
  }) => {
    const m = u.tr, b = Ms({
      state: u,
      transaction: m
    });
    if (!(!Zv({
      editor: e,
      state: b,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: p,
      dropEvent: l
    }) || !m.steps.length)) {
      try {
        l = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        l = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m;
    }
  };
  return n.map((u) => new ue({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (p) => {
        var m;
        r = (m = d.dom.parentElement) != null && m.contains(p.target) ? d.dom.parentElement : null, r && (Vo = e);
      }, h = () => {
        Vo && (Vo = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (i = r === d.dom.parentElement, l = f, !i) {
            const h = Vo;
            h?.isEditable && setTimeout(() => {
              const p = h.state.selection;
              p && h.commands.deleteRange({ from: p.from, to: p.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var h;
          const p = (h = f.clipboardData) == null ? void 0 : h.getData("text/html");
          return s = f, o = !!p?.includes("data-pm-slice"), !1;
        }
      }
    },
    appendTransaction: (d, f, h) => {
      const p = d[0], m = p.getMeta("uiEvent") === "paste" && !o, b = p.getMeta("uiEvent") === "drop" && !i, C = p.getMeta("applyPasteRules"), v = !!C;
      if (!m && !b && !v)
        return;
      if (v) {
        let { text: x } = C;
        typeof x == "string" ? x = x : x = Ac(A.from(x), h.schema);
        const { from: k } = C, E = k + x.length, M = Jv(x);
        return a({
          rule: u,
          state: h,
          from: k,
          to: { b: E },
          pasteEvt: M
        });
      }
      const S = f.doc.content.findDiffStart(h.doc.content), w = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!jv(S) || !w || S === w.b))
        return a({
          rule: u,
          state: h,
          from: S,
          to: w,
          pasteEvt: s
        });
    }
  }));
}
var Ns = class {
  constructor(t, e) {
    this.splittableMarks = [], this.editor = e, this.extensions = pm(t), this.schema = Iv(this.extensions, e), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((t, e) => {
      const n = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: Sl(e.name, this.schema)
      }, r = U(e, "addCommands", n);
      return r ? {
        ...t,
        ...r()
      } : t;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: t } = this;
    return Oc([...this.extensions].reverse()).flatMap((r) => {
      const o = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: t,
        type: Sl(r.name, this.schema)
      }, i = [], s = U(
        r,
        "addKeyboardShortcuts",
        o
      );
      let l = {};
      if (r.type === "mark" && U(r, "exitable", o) && (l.ArrowRight = () => Ct.handleExit({ editor: t, mark: r })), s) {
        const f = Object.fromEntries(
          Object.entries(s()).map(([h, p]) => [h, () => p({ editor: t })])
        );
        l = { ...l, ...f };
      }
      const a = iv(l);
      i.push(a);
      const c = U(r, "addInputRules", o);
      if (of(r, t.options.enableInputRules) && c) {
        const f = c();
        if (f && f.length) {
          const h = Wv({
            editor: t,
            rules: f
          }), p = Array.isArray(h) ? h : [h];
          i.push(...p);
        }
      }
      const u = U(r, "addPasteRules", o);
      if (of(r, t.options.enablePasteRules) && u) {
        const f = u();
        if (f && f.length) {
          const h = Yv({ editor: t, rules: f });
          i.push(...h);
        }
      }
      const d = U(
        r,
        "addProseMirrorPlugins",
        o
      );
      if (d) {
        const f = d();
        i.push(...f);
      }
      return i;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return hm(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: t } = this, { nodeExtensions: e } = lo(this.extensions);
    return Object.fromEntries(
      e.filter((n) => !!U(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((l) => l.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: t,
          type: Se(n.name, this.schema)
        }, i = U(n, "addNodeView", o);
        if (!i)
          return [];
        const s = (l, a, c, u, d) => {
          const f = ao(l, r);
          return i()({
            // pass-through
            node: l,
            view: a,
            getPos: c,
            decorations: u,
            innerDecorations: d,
            // tiptap-specific
            editor: t,
            extension: n,
            HTMLAttributes: f
          });
        };
        return [n.name, s];
      })
    );
  }
  get markViews() {
    const { editor: t } = this, { markExtensions: e } = lo(this.extensions);
    return Object.fromEntries(
      e.filter((n) => !!U(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((l) => l.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: t,
          type: tn(n.name, this.schema)
        }, i = U(n, "addMarkView", o);
        if (!i)
          return [];
        const s = (l, a, c) => {
          const u = ao(l, r);
          return i()({
            // pass-through
            mark: l,
            view: a,
            inline: c,
            // tiptap-specific
            editor: t,
            extension: n,
            HTMLAttributes: u,
            updateAttributes: (d) => {
              d7(l, t, d);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const t = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      t.map((e) => [e.name, e.storage])
    ), t.forEach((e) => {
      var n;
      const r = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: Sl(e.name, this.schema)
      };
      e.type === "mark" && ((n = ee(U(e, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(e.name);
      const o = U(e, "onBeforeCreate", r), i = U(e, "onCreate", r), s = U(e, "onUpdate", r), l = U(
        e,
        "onSelectionUpdate",
        r
      ), a = U(e, "onTransaction", r), c = U(e, "onFocus", r), u = U(e, "onBlur", r), d = U(e, "onDestroy", r);
      o && this.editor.on("beforeCreate", o), i && this.editor.on("create", i), s && this.editor.on("update", s), l && this.editor.on("selectionUpdate", l), a && this.editor.on("transaction", a), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
};
Ns.resolve = pm;
Ns.sort = Oc;
Ns.flatten = Rc;
var Xv = {};
am(Xv, {
  ClipboardTextSerializer: () => Tm,
  Commands: () => Nm,
  Delete: () => Im,
  Drop: () => Lm,
  Editable: () => Dm,
  FocusEvents: () => Bm,
  Keymap: () => Hm,
  Paste: () => Fm,
  Tabindex: () => _m,
  focusEventsPluginKey: () => Pm
});
var Q = class Mm extends Bc {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new Mm(n);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
}, Tm = Q.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: o } = e, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), l = Math.max(...i.map((u) => u.$to.pos)), a = Nc(n);
            return mm(r, { from: s, to: l }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: a
            });
          }
        }
      })
    ];
  }
}), Rm = {};
am(Rm, {
  blur: () => Qv,
  clearContent: () => ew,
  clearNodes: () => tw,
  command: () => nw,
  createParagraphNear: () => rw,
  cut: () => ow,
  deleteCurrentNode: () => iw,
  deleteNode: () => sw,
  deleteRange: () => lw,
  deleteSelection: () => aw,
  enter: () => cw,
  exitCode: () => uw,
  extendMarkRange: () => dw,
  first: () => fw,
  focus: () => hw,
  forEach: () => pw,
  insertContent: () => mw,
  insertContentAt: () => yw,
  joinBackward: () => vw,
  joinDown: () => Cw,
  joinForward: () => ww,
  joinItemBackward: () => Sw,
  joinItemForward: () => xw,
  joinTextblockBackward: () => kw,
  joinTextblockForward: () => Ew,
  joinUp: () => bw,
  keyboardShortcut: () => Tw,
  lift: () => Rw,
  liftEmptyBlock: () => Aw,
  liftListItem: () => Ow,
  newlineInCode: () => Nw,
  resetAttributes: () => Iw,
  scrollIntoView: () => Lw,
  selectAll: () => Dw,
  selectNodeBackward: () => Pw,
  selectNodeForward: () => Bw,
  selectParentNode: () => Hw,
  selectTextblockEnd: () => Fw,
  selectTextblockStart: () => _w,
  setContent: () => zw,
  setMark: () => $w,
  setMeta: () => Uw,
  setNode: () => Ww,
  setNodeSelection: () => Kw,
  setTextSelection: () => jw,
  sinkListItem: () => qw,
  splitBlock: () => Gw,
  splitListItem: () => Zw,
  toggleList: () => Jw,
  toggleMark: () => Yw,
  toggleNode: () => Xw,
  toggleWrap: () => Qw,
  undoInputRule: () => e7,
  unsetAllMarks: () => t7,
  unsetMark: () => n7,
  updateAttributes: () => r7,
  wrapIn: () => o7,
  wrapInList: () => i7
});
var Qv = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window?.getSelection()) == null || n.removeAllRanges());
}), !0), ew = (t = !0) => ({ commands: e }) => e.setContent("", { emitUpdate: t }), tw = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: o } = r;
  return n && o.forEach(({ $from: i, $to: s }) => {
    t.doc.nodesBetween(i.pos, s.pos, (l, a) => {
      if (l.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(a)), f = c.resolve(u.map(a + l.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const p = Ar(h);
      if (l.type.isTextblock) {
        const { defaultType: m } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(h.start, m);
      }
      (p || p === 0) && e.lift(h, p);
    });
  }), !0;
}, nw = (t) => (e) => t(e), rw = () => ({ state: t, dispatch: e }) => om(t, e), ow = (t, e) => ({ editor: n, tr: r }) => {
  const { state: o } = n, i = o.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const s = r.mapping.map(e);
  return r.insert(s, i.content), r.setSelection(new V(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, iw = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const o = t.selection.$anchor;
  for (let i = o.depth; i > 0; i -= 1)
    if (o.node(i).type === r.type) {
      if (e) {
        const l = o.before(i), a = o.after(i);
        t.delete(l, a).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, sw = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const o = Se(t, n.schema), i = e.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === o) {
      if (r) {
        const a = i.before(s), c = i.after(s);
        e.delete(a, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, lw = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: o } = t;
  return n && e.delete(r, o), !0;
}, aw = () => ({ state: t, dispatch: e }) => xc(t, e), cw = () => ({ commands: t }) => t.keyboardShortcut("Enter"), uw = () => ({ state: t, dispatch: e }) => dv(t, e), dw = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const i = tn(t, r.schema), { doc: s, selection: l } = n, { $from: a, from: c, to: u } = l;
  if (o) {
    const d = Lc(a, i, e);
    if (d && d.from <= c && d.to >= u) {
      const f = V.create(s, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, fw = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function Am() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function Is() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var hw = (t = null, e = {}) => ({ editor: n, view: r, tr: o, dispatch: i }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    (Is() || Am()) && r.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e?.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (r.hasFocus() && t === null || t === !1)
    return !0;
  if (i && t === null && !Pc(n.state.selection))
    return s(), !0;
  const l = xm(o.doc, t) || n.state.selection, a = n.state.selection.eq(l);
  return i && (a || o.setSelection(l), a && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), !0;
}, pw = (t, e) => (n) => t.every((r, o) => e(r, { ...n, index: o })), mw = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), gw = (t) => !("type" in t), yw = (t, e, n) => ({ tr: r, dispatch: o, editor: i }) => {
  var s;
  if (o) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let l;
    const a = (b) => {
      i.emit("contentError", {
        editor: i,
        error: b,
        disableCollaboration: () => {
          "collaboration" in i.storage && typeof i.storage.collaboration == "object" && i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      });
    }, c = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !i.options.enableContentCheck && i.options.emitContentError)
      try {
        so(e, i.schema, {
          parseOptions: c,
          errorOnInvalidContent: !0
        });
      } catch (b) {
        a(b);
      }
    try {
      l = so(e, i.schema, {
        parseOptions: c,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : i.options.enableContentCheck
      });
    } catch (b) {
      return a(b), !1;
    }
    let { from: u, to: d } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, f = !0, h = !0;
    if ((gw(l) ? l : [l]).forEach((b) => {
      b.check(), f = f ? b.isText && b.marks.length === 0 : !1, h = h ? b.isBlock : !1;
    }), u === d && h) {
      const { parent: b } = r.doc.resolve(u);
      b.isTextblock && !b.type.spec.code && !b.childCount && (u -= 1, d += 1);
    }
    let m;
    if (f) {
      if (Array.isArray(e))
        m = e.map((b) => b.text || "").join("");
      else if (e instanceof A) {
        let b = "";
        e.forEach((C) => {
          C.text && (b += C.text);
        }), m = b;
      } else typeof e == "object" && e && e.text ? m = e.text : m = e;
      r.insertText(m, u, d);
    } else {
      m = l;
      const b = r.doc.resolve(u), C = b.node(), v = b.parentOffset === 0, S = C.isText || C.isTextblock, w = C.content.size > 0;
      v && S && w && (u = Math.max(0, u - 1)), r.replaceWith(u, d, m);
    }
    n.updateSelection && $v(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: u, text: m }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: u, text: m });
  }
  return !0;
}, bw = () => ({ state: t, dispatch: e }) => av(t, e), Cw = () => ({ state: t, dispatch: e }) => cv(t, e), vw = () => ({ state: t, dispatch: e }) => Yp(t, e), ww = () => ({ state: t, dispatch: e }) => tm(t, e), Sw = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = vs(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, xw = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = vs(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, kw = () => ({ state: t, dispatch: e }) => sv(t, e), Ew = () => ({ state: t, dispatch: e }) => lv(t, e);
function Om() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function Mw(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, s;
  for (let l = 0; l < e.length - 1; l += 1) {
    const a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      s = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      o = !0;
    else if (/^s(hift)?$/i.test(a))
      i = !0;
    else if (/^mod$/i.test(a))
      Is() || Om() ? s = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${a}`);
  }
  return r && (n = `Alt-${n}`), o && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
var Tw = (t) => ({ editor: e, view: n, tr: r, dispatch: o }) => {
  const i = Mw(t).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), l = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), a = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, l));
  });
  return a?.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && o && r.maybeStep(u);
  }), !0;
}, Rw = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = Se(t, n.schema);
  return Tn(n, o, e) ? uv(n, r) : !1;
}, Aw = () => ({ state: t, dispatch: e }) => im(t, e), Ow = (t) => ({ state: e, dispatch: n }) => {
  const r = Se(t, e.schema);
  return Sv(r)(e, n);
}, Nw = () => ({ state: t, dispatch: e }) => rm(t, e);
function lf(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, o) => (n.includes(o) || (r[o] = t[o]), r), {});
}
var Iw = (t, e) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const l = As(
    typeof t == "string" ? t : t.name,
    r.schema
  );
  return l ? (l === "node" && (i = Se(t, r.schema)), l === "mark" && (s = tn(t, r.schema)), o && n.selection.ranges.forEach((a) => {
    r.doc.nodesBetween(a.$from.pos, a.$to.pos, (c, u) => {
      i && i === c.type && n.setNodeMarkup(u, void 0, lf(c.attrs, e)), s && c.marks.length && c.marks.forEach((d) => {
        s === d.type && n.addMark(u, u + c.nodeSize, s.create(lf(d.attrs, e)));
      });
    });
  }), !0) : !1;
}, Lw = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), Dw = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new Ge(t.doc);
    t.setSelection(n);
  }
  return !0;
}, Pw = () => ({ state: t, dispatch: e }) => Qp(t, e), Bw = () => ({ state: t, dispatch: e }) => nm(t, e), Hw = () => ({ state: t, dispatch: e }) => pv(t, e), Fw = () => ({ state: t, dispatch: e }) => yv(t, e), _w = () => ({ state: t, dispatch: e }) => gv(t, e), zw = (t, { errorOnInvalidContent: e, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: o, tr: i, dispatch: s, commands: l }) => {
  const { doc: a } = i;
  if (r.preserveWhitespace !== "full") {
    const c = ba(t, o.schema, r, {
      errorOnInvalidContent: e ?? o.options.enableContentCheck
    });
    return s && i.replaceWith(0, a.content.size, c).setMeta("preventUpdate", !n), !0;
  }
  return s && i.setMeta("preventUpdate", !n), l.insertContentAt({ from: 0, to: a.content.size }, t, {
    parseOptions: r,
    errorOnInvalidContent: e ?? o.options.enableContentCheck
  });
};
function Vw(t, e, n) {
  var r;
  const { selection: o } = e;
  let i = null;
  if (Pc(o) && (i = o.$cursor), i) {
    const l = (r = t.storedMarks) != null ? r : i.marks();
    return i.parent.type.allowsMarkType(n) && (!!n.isInSet(l) || !l.some((c) => c.type.excludes(n)));
  }
  const { ranges: s } = o;
  return s.some(({ $from: l, $to: a }) => {
    let c = l.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(l.pos, a.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((m) => m.type.excludes(n));
        c = h && p;
      }
      return !c;
    }), c;
  });
}
var $w = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = n, { empty: s, ranges: l } = i, a = tn(t, r.schema);
  if (o)
    if (s) {
      const c = ym(r, a);
      n.addStoredMark(
        a.create({
          ...c,
          ...e
        })
      );
    } else
      l.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, h) => {
          const p = Math.max(h, u), m = Math.min(h + f.nodeSize, d);
          f.marks.find((C) => C.type === a) ? f.marks.forEach((C) => {
            a === C.type && n.addMark(
              p,
              m,
              a.create({
                ...C.attrs,
                ...e
              })
            );
          }) : n.addMark(p, m, a.create(e));
        });
      });
  return Vw(r, n, a);
}, Uw = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), Ww = (t, e = {}) => ({ state: n, dispatch: r, chain: o }) => {
  const i = Se(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: l }) => ef(i, { ...s, ...e })(n) ? !0 : l.clearNodes()).command(({ state: l }) => ef(i, { ...s, ...e })(l, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, Kw = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, o = qt(t, 0, r.content.size), i = z.create(r, o);
    e.setSelection(i);
  }
  return !0;
}, jw = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : t, s = V.atStart(r).from, l = V.atEnd(r).to, a = qt(o, s, l), c = qt(i, s, l), u = V.create(r, a, c);
    e.setSelection(u);
  }
  return !0;
}, qw = (t) => ({ state: e, dispatch: n }) => {
  const r = Se(t, e.schema);
  return Ev(r)(e, n);
};
function af(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((o) => e?.includes(o.type.name));
    t.tr.ensureMarks(r);
  }
}
var Gw = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: o }) => {
  const { selection: i, doc: s } = e, { $from: l, $to: a } = i, c = o.extensionManager.attributes, u = li(c, l.node().type.name, l.node().attrs);
  if (i instanceof z && i.node.isBlock)
    return !l.parentOffset || !Jt(s, l.pos) ? !1 : (r && (t && af(n, o.extensionManager.splittableMarks), e.split(l.pos).scrollIntoView()), !0);
  if (!l.parent.isBlock)
    return !1;
  const d = a.parentOffset === a.parent.content.size, f = l.depth === 0 ? void 0 : Rv(l.node(-1).contentMatchAt(l.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = Jt(e.doc, e.mapping.map(l.pos), 1, h);
  if (!h && !p && Jt(e.doc, e.mapping.map(l.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (p && (i instanceof V && e.deleteSelection(), e.split(e.mapping.map(l.pos), 1, h), f && !d && !l.parentOffset && l.parent.type !== f)) {
      const m = e.mapping.map(l.before()), b = e.doc.resolve(m);
      l.node(-1).canReplaceWith(b.index(), b.index() + 1, f) && e.setNodeMarkup(e.mapping.map(l.before()), f);
    }
    t && af(n, o.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
}, Zw = (t, e = {}) => ({ tr: n, state: r, dispatch: o, editor: i }) => {
  var s;
  const l = Se(t, r.schema), { $from: a, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || a.depth < 2 || !a.sameParent(c))
    return !1;
  const d = a.node(-1);
  if (d.type !== l)
    return !1;
  const f = i.extensionManager.attributes;
  if (a.parent.content.size === 0 && a.node(-1).childCount === a.indexAfter(-1)) {
    if (a.depth === 2 || a.node(-3).type !== l || a.index(-2) !== a.node(-2).childCount - 1)
      return !1;
    if (o) {
      let C = A.empty;
      const v = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
      for (let M = a.depth - v; M >= a.depth - 3; M -= 1)
        C = A.from(a.node(M).copy(C));
      const S = (
        // eslint-disable-next-line no-nested-ternary
        a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3
      ), w = {
        ...li(f, a.node().type.name, a.node().attrs),
        ...e
      }, x = ((s = l.contentMatch.defaultType) == null ? void 0 : s.createAndFill(w)) || void 0;
      C = C.append(A.from(l.createAndFill(null, x) || void 0));
      const k = a.before(a.depth - (v - 1));
      n.replace(k, a.after(-S), new B(C, 4 - v, 0));
      let E = -1;
      n.doc.nodesBetween(k, n.doc.content.size, (M, N) => {
        if (E > -1)
          return !1;
        M.isTextblock && M.content.size === 0 && (E = N + 1);
      }), E > -1 && n.setSelection(V.near(n.doc.resolve(E))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === a.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...li(f, d.type.name, d.attrs),
    ...e
  }, m = {
    ...li(f, a.node().type.name, a.node().attrs),
    ...e
  };
  n.delete(a.pos, c.pos);
  const b = h ? [
    { type: l, attrs: p },
    { type: h, attrs: m }
  ] : [{ type: l, attrs: p }];
  if (!Jt(n.doc, a.pos, 2))
    return !1;
  if (o) {
    const { selection: C, storedMarks: v } = r, { splittableMarks: S } = i.extensionManager, w = v || C.$to.parentOffset && C.$from.marks();
    if (n.split(a.pos, 2, b).scrollIntoView(), !w || !o)
      return !0;
    const x = w.filter((k) => S.includes(k.type.name));
    n.ensureMarks(x);
  }
  return !0;
}, xl = (t, e) => {
  const n = Rs((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const o = t.doc.nodeAt(r);
  return n.node.type === o?.type && On(t.doc, n.pos) && t.join(n.pos), !0;
}, kl = (t, e) => {
  const n = Rs((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const o = t.doc.nodeAt(r);
  return n.node.type === o?.type && On(t.doc, r) && t.join(r), !0;
}, Jw = (t, e, n, r = {}) => ({ editor: o, tr: i, state: s, dispatch: l, chain: a, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = o.extensionManager, h = Se(t, s.schema), p = Se(e, s.schema), { selection: m, storedMarks: b } = s, { $from: C, $to: v } = m, S = C.blockRange(v), w = b || m.$to.parentOffset && m.$from.marks();
  if (!S)
    return !1;
  const x = Rs((k) => sf(k.type.name, d))(m);
  if (S.depth >= 1 && x && S.depth - x.depth <= 1) {
    if (x.node.type === h)
      return c.liftListItem(p);
    if (sf(x.node.type.name, d) && h.validContent(x.node.content) && l)
      return a().command(() => (i.setNodeMarkup(x.pos, h), !0)).command(() => xl(i, h)).command(() => kl(i, h)).run();
  }
  return !n || !w || !l ? a().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => xl(i, h)).command(() => kl(i, h)).run() : a().command(() => {
    const k = u().wrapInList(h, r), E = w.filter((M) => f.includes(M.type.name));
    return i.ensureMarks(E), k ? !0 : c.clearNodes();
  }).wrapInList(h, r).command(() => xl(i, h)).command(() => kl(i, h)).run();
}, Yw = (t, e = {}, n = {}) => ({ state: r, commands: o }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = tn(t, r.schema);
  return Ca(r, s, e) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, e);
}, Xw = (t, e, n = {}) => ({ state: r, commands: o }) => {
  const i = Se(t, r.schema), s = Se(e, r.schema), l = Tn(r, i, n);
  let a;
  return r.selection.$anchor.sameParent(r.selection.$head) && (a = r.selection.$anchor.parent.attrs), l ? o.setNode(s, a) : o.setNode(i, { ...a, ...n });
}, Qw = (t, e = {}) => ({ state: n, commands: r }) => {
  const o = Se(t, n.schema);
  return Tn(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
}, e7 = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const o = n[r];
    let i;
    if (o.spec.isInputRules && (i = o.getState(t))) {
      if (e) {
        const s = t.tr, l = i.transform;
        for (let a = l.steps.length - 1; a >= 0; a -= 1)
          s.step(l.steps[a].invert(l.docs[a]));
        if (i.text) {
          const a = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, t.schema.text(i.text, a));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, t7 = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: o } = n;
  return r || e && o.forEach((i) => {
    t.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, n7 = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: l } = n, a = tn(t, r.schema), { $from: c, empty: u, ranges: d } = l;
  if (!o)
    return !0;
  if (u && s) {
    let { from: f, to: h } = l;
    const p = (i = c.marks().find((b) => b.type === a)) == null ? void 0 : i.attrs, m = Lc(c, a, p);
    m && (f = m.from, h = m.to), n.removeMark(f, h, a);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, a);
    });
  return n.removeStoredMark(a), !0;
}, r7 = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const l = As(
    typeof t == "string" ? t : t.name,
    r.schema
  );
  return l ? (l === "node" && (i = Se(t, r.schema)), l === "mark" && (s = tn(t, r.schema)), o && n.selection.ranges.forEach((a) => {
    const c = a.$from.pos, u = a.$to.pos;
    let d, f, h, p;
    n.selection.empty ? r.doc.nodesBetween(c, u, (m, b) => {
      i && i === m.type && (h = Math.max(b, c), p = Math.min(b + m.nodeSize, u), d = b, f = m);
    }) : r.doc.nodesBetween(c, u, (m, b) => {
      b < c && i && i === m.type && (h = Math.max(b, c), p = Math.min(b + m.nodeSize, u), d = b, f = m), b >= c && b <= u && (i && i === m.type && n.setNodeMarkup(b, void 0, {
        ...m.attrs,
        ...e
      }), s && m.marks.length && m.marks.forEach((C) => {
        if (s === C.type) {
          const v = Math.max(b, c), S = Math.min(b + m.nodeSize, u);
          n.addMark(
            v,
            S,
            s.create({
              ...C.attrs,
              ...e
            })
          );
        }
      }));
    }), f && (d !== void 0 && n.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), s && f.marks.length && f.marks.forEach((m) => {
      s === m.type && n.addMark(
        h,
        p,
        s.create({
          ...m.attrs,
          ...e
        })
      );
    }));
  }), !0) : !1;
}, o7 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = Se(t, n.schema);
  return bv(o, e)(n, r);
}, i7 = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = Se(t, n.schema);
  return Cv(o, e)(n, r);
}, Nm = Q.create({
  name: "commands",
  addCommands() {
    return {
      ...Rm
    };
  }
}), Im = Q.create({
  name: "delete",
  onUpdate({ transaction: t, appendedTransactions: e }) {
    var n, r, o;
    const i = () => {
      var s, l, a, c;
      if ((c = (a = (l = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : l.filterTransaction) == null ? void 0 : a.call(l, t)) != null ? c : t.getMeta("y-sync$"))
        return;
      const u = cm(t.before, [t, ...e]);
      Cm(u).forEach((h) => {
        u.mapping.mapResult(h.oldRange.from).deletedAfter && u.mapping.mapResult(h.oldRange.to).deletedBefore && u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (p, m) => {
          const b = m + p.nodeSize - 2, C = h.oldRange.from <= m && b <= h.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: p,
            from: m,
            to: b,
            newFrom: u.mapping.map(m),
            newTo: u.mapping.map(b),
            deletedRange: h.oldRange,
            newRange: h.newRange,
            partial: !C,
            editor: this.editor,
            transaction: t,
            combinedTransform: u
          });
        });
      });
      const f = u.mapping;
      u.steps.forEach((h, p) => {
        var m, b;
        if (h instanceof ft) {
          const C = f.slice(p).map(h.from, -1), v = f.slice(p).map(h.to), S = f.invert().map(C, -1), w = f.invert().map(v), x = (m = u.doc.nodeAt(C - 1)) == null ? void 0 : m.marks.some((E) => E.eq(h.mark)), k = (b = u.doc.nodeAt(v)) == null ? void 0 : b.marks.some((E) => E.eq(h.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: h.mark,
            from: h.from,
            to: h.to,
            deletedRange: {
              from: S,
              to: w
            },
            newRange: {
              from: C,
              to: v
            },
            partial: !!(k || x),
            editor: this.editor,
            transaction: t,
            combinedTransform: u
          });
        }
      });
    };
    (o = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || o ? setTimeout(i, 0) : i();
  }
}), Lm = Q.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), Dm = Q.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), Pm = new pe("focusEvents"), Bm = Q.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new ue({
        key: Pm,
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), Hm = Q.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: l }) => {
        const { selection: a, doc: c } = l, { empty: u, $anchor: d } = a, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? l.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, b = d.pos - d.parentOffset, C = m && p.parent.childCount === 1 ? b === d.pos : K.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !C || C && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...r
    }, i = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return Is() || Om() ? i : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new ue({
        key: new pe("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((m) => m.getMeta("composition")))
            return;
          const r = t.some((m) => m.docChanged) && !e.doc.eq(n.doc), o = t.some((m) => m.getMeta("preventClearDocument"));
          if (!r || o)
            return;
          const { empty: i, from: s, to: l } = e.selection, a = K.atStart(e.doc).from, c = K.atEnd(e.doc).to;
          if (i || !(s === a && l === c) || !Os(n.doc))
            return;
          const f = n.tr, h = Ms({
            state: n,
            transaction: f
          }), { commands: p } = new Ts({
            editor: this.editor,
            state: h
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), Fm = Q.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), _m = Q.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), s7 = class fr {
  constructor(e, n, r = !1, o = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = o;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) != null ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new fr(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new fr(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new fr(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const o = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = this.pos + r + (i ? 0 : 1);
      if (s < 0 || s > this.resolvedPos.doc.nodeSize - 2)
        return;
      const l = this.resolvedPos.doc.resolve(s);
      if (!o && l.depth <= this.depth)
        return;
      const a = new fr(l, this.editor, o, o ? n : null);
      o && (a.actualDepth = this.depth + 1), e.push(new fr(l, this.editor, o, o ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs, s = Object.keys(n);
          for (let l = 0; l < s.length; l += 1) {
            const a = s[l];
            if (i[a] !== n[a])
              break;
          }
        } else
          r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0)
      return o;
    const i = Object.keys(n);
    return this.children.forEach((s) => {
      r && o.length > 0 || (s.node.type.name === e && i.every((a) => n[a] === s.node.attrs[a]) && o.push(s), !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(e, n, r))));
    }), o;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}, l7 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function a7(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const o = document.createElement("style");
  return e && o.setAttribute("nonce", e), o.setAttribute("data-tiptap-style", ""), o.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(o), o;
}
var c7 = class extends Tv {
  constructor(t = {}) {
    super(), this.css = null, this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(t), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: o, moved: i }) => this.options.onDrop(r, o, i)), this.on("paste", ({ event: r, slice: o }) => this.options.onPaste(r, o)), this.on("delete", this.options.onDelete);
    const e = this.createDoc(), n = xm(e, this.options.autofocus);
    this.editorState = mr.create({
      doc: e,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(t) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(t), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const t = this.editorView.dom;
      t?.editor && delete t.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (t) {
        console.warn("Failed to remove CSS element:", t);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = a7(l7, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(t = {}) {
    this.options = {
      ...this.options,
      ...t
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(t, e = !0) {
    this.setOptions({ editable: t }), e && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (t) => {
          this.editorState = t;
        },
        dispatch: (t) => {
          this.editorState = this.state.apply(t);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (t, e) => {
          if (e === "state")
            return this.editorState;
          if (e in t)
            return Reflect.get(t, e);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${e}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(t, e) {
    const n = fm(e) ? e(t, [...this.state.plugins]) : [...this.state.plugins, t], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(t) {
    if (this.isDestroyed)
      return;
    const e = this.state.plugins;
    let n = e;
    if ([].concat(t).forEach((o) => {
      const i = typeof o == "string" ? `${o}$` : o.key;
      n = n.filter((s) => !s.key.startsWith(i));
    }), e.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var t, e;
    const r = [...this.options.enableCoreExtensions ? [
      Dm,
      Tm.configure({
        blockSeparator: (e = (t = this.options.coreExtensionOptions) == null ? void 0 : t.clipboardTextSerializer) == null ? void 0 : e.blockSeparator
      }),
      Nm,
      Bm,
      Hm,
      _m,
      Lm,
      Fm,
      Im
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o?.type));
    this.extensionManager = new Ns(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Ts({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let t;
    try {
      t = ba(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message))
        throw e;
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), t = ba(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return t;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(t) {
    var e;
    this.editorView = new Zp(t, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) == null ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const n = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(n), this.prependClass(), this.injectCSS();
    const r = this.view.dom;
    r.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(t) {
    this.isCapturingTransaction = !0, t(), this.isCapturingTransaction = !1;
    const e = this.capturedTransaction;
    return this.capturedTransaction = null, e;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(t) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = t;
        return;
      }
      t.steps.forEach((c) => {
        var u;
        return (u = this.capturedTransaction) == null ? void 0 : u.step(c);
      });
      return;
    }
    const { state: e, transactions: n } = this.state.applyTransaction(t), r = !this.state.selection.eq(e.selection), o = n.includes(t), i = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: t,
      nextState: e
    }), !o)
      return;
    this.view.updateState(e), this.emit("transaction", {
      editor: this,
      transaction: t,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: t
    });
    const s = n.findLast((c) => c.getMeta("focus") || c.getMeta("blur")), l = s?.getMeta("focus"), a = s?.getMeta("blur");
    l && this.emit("focus", {
      editor: this,
      event: l.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), a && this.emit("blur", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(t.getMeta("preventUpdate") || !n.some((c) => c.docChanged) || i.doc.eq(e.doc)) && this.emit("update", {
      editor: this,
      transaction: t,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(t) {
    return bm(this.state, t);
  }
  isActive(t, e) {
    const n = typeof t == "string" ? t : null, r = typeof t == "string" ? e : t;
    return _v(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return Ac(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(t) {
    const { blockSeparator: e = `

`, textSerializers: n = {} } = t || {};
    return gm(this.state.doc, {
      blockSeparator: e,
      textSerializers: {
        ...Nc(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Os(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var t, e;
    return (e = (t = this.editorView) == null ? void 0 : t.isDestroyed) != null ? e : !0;
  }
  $node(t, e) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(t, e)) || null;
  }
  $nodes(t, e) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(t, e)) || null;
  }
  $pos(t) {
    const e = this.state.doc.resolve(t);
    return new s7(e, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Zn(t) {
  return new wo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = ee(t.getAttributes, void 0, r);
      if (o === !1 || o === null)
        return null;
      const { tr: i } = e, s = r[r.length - 1], l = r[0];
      if (s) {
        const a = l.search(/\S/), c = n.from + l.indexOf(s), u = c + s.length;
        if (Dc(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((m) => m === t.type && m !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        u < n.to && i.delete(u, n.to), c > n.from && i.delete(n.from + a, c);
        const f = n.from + a + s.length;
        i.addMark(n.from + a, f, t.type.create(o || {})), i.removeStoredMark(t.type);
      }
    },
    undoable: t.undoable
  });
}
function zm(t) {
  return new wo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = ee(t.getAttributes, void 0, r) || {}, { tr: i } = e, s = n.from;
      let l = n.to;
      const a = t.type.create(o);
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1]);
        let u = s + c;
        u > l ? u = l : l = u + r[1].length;
        const d = r[0][r[0].length - 1];
        i.insertText(d, s + r[0].length - 1), i.replaceWith(u, l, a);
      } else if (r[0]) {
        const c = t.type.isInline ? s : s - 1;
        i.insert(c, t.type.create(o)).delete(i.mapping.map(s), i.mapping.map(l));
      }
      i.scrollIntoView();
    },
    undoable: t.undoable
  });
}
function va(t) {
  return new wo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = e.doc.resolve(n.from), i = ee(t.getAttributes, void 0, r) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    },
    undoable: t.undoable
  });
}
function be(t) {
  return new wo({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      let o = t.replace, i = n.from;
      const s = n.to;
      if (r[1]) {
        const l = r[0].lastIndexOf(r[1]);
        o += r[0].slice(l + r[1].length), i += l;
        const a = i - s;
        a > 0 && (o = r[0].slice(l - a, l) + o, i = s);
      }
      e.tr.insertText(o, i, s);
    },
    undoable: t.undoable
  });
}
function kr(t) {
  return new wo({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: o }) => {
      const i = ee(t.getAttributes, void 0, r) || {}, s = e.tr.delete(n.from, n.to), a = s.doc.resolve(n.from).blockRange(), c = a && uc(a, t.type, i);
      if (!c)
        return null;
      if (s.wrap(a, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: h } = t.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const m = p.filter((b) => h.includes(b.type.name));
          s.ensureMarks(m);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        o().updateAttributes(d, i).run();
      }
      const u = s.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && On(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, u)) && s.join(n.from - 1);
    },
    undoable: t.undoable
  });
}
function u7(t, e) {
  const { selection: n } = t, { $from: r } = n;
  if (n instanceof z) {
    const i = r.index();
    return r.parent.canReplaceWith(i, i + 1, e);
  }
  let o = r.depth;
  for (; o >= 0; ) {
    const i = r.index(o);
    if (r.node(o).contentMatchAt(i).matchType(e))
      return !0;
    o -= 1;
  }
  return !1;
}
function d7(t, e, n = {}) {
  const { state: r } = e, { doc: o, tr: i } = r, s = t;
  o.descendants((l, a) => {
    const c = i.mapping.map(a), u = i.mapping.map(a) + l.nodeSize;
    let d = null;
    if (l.marks.forEach((h) => {
      if (h !== s)
        return !1;
      d = h;
    }), !d)
      return;
    let f = !1;
    if (Object.keys(n).forEach((h) => {
      n[h] !== d.attrs[h] && (f = !0);
    }), f) {
      const h = t.type.create({
        ...t.attrs,
        ...n
      });
      i.removeMark(c, u, t.type), i.addMark(c, u, h);
    }
  }), i.docChanged && e.view.dispatch(i);
}
var Ce = class Vm extends Bc {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new Vm(n);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
}, f7 = class {
  constructor(t, e, n) {
    this.isDragging = !1, this.component = t, this.editor = e.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...n
    }, this.extension = e.extension, this.node = e.node, this.decorations = e.decorations, this.innerDecorations = e.innerDecorations, this.view = e.view, this.HTMLAttributes = e.HTMLAttributes, this.getPos = e.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(t) {
    var e, n, r, o, i, s, l;
    const { view: a } = this.editor, c = t.target, u = c.nodeType === 3 ? (e = c.parentElement) == null ? void 0 : e.closest("[data-drag-handle]") : c.closest("[data-drag-handle]");
    if (!this.dom || (n = this.contentDOM) != null && n.contains(c) || !u)
      return;
    let d = 0, f = 0;
    if (this.dom !== u) {
      const v = this.dom.getBoundingClientRect(), S = u.getBoundingClientRect(), w = (o = t.offsetX) != null ? o : (r = t.nativeEvent) == null ? void 0 : r.offsetX, x = (s = t.offsetY) != null ? s : (i = t.nativeEvent) == null ? void 0 : i.offsetY;
      d = S.x - v.x + w, f = S.y - v.y + x;
    }
    const h = this.dom.cloneNode(!0);
    try {
      const v = this.dom.getBoundingClientRect();
      h.style.width = `${Math.round(v.width)}px`, h.style.height = `${Math.round(v.height)}px`, h.style.boxSizing = "border-box", h.style.pointerEvents = "none";
    } catch {
    }
    let p = null;
    try {
      p = document.createElement("div"), p.style.position = "absolute", p.style.top = "-9999px", p.style.left = "-9999px", p.style.pointerEvents = "none", p.appendChild(h), document.body.appendChild(p), (l = t.dataTransfer) == null || l.setDragImage(h, d, f);
    } finally {
      p && setTimeout(() => {
        try {
          p?.remove();
        } catch {
        }
      }, 0);
    }
    const m = this.getPos();
    if (typeof m != "number")
      return;
    const b = z.create(a.state.doc, m), C = a.state.tr.setSelection(b);
    a.dispatch(C);
  }
  stopEvent(t) {
    var e;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: t });
    const n = t.target;
    if (!(this.dom.contains(n) && !((e = this.contentDOM) != null && e.contains(n))))
      return !1;
    const o = t.type.startsWith("drag"), i = t.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !i && !o)
      return !0;
    const { isEditable: l } = this.editor, { isDragging: a } = this, c = !!this.node.type.spec.draggable, u = z.isSelectable(this.node), d = t.type === "copy", f = t.type === "paste", h = t.type === "cut", p = t.type === "mousedown";
    if (!c && u && o && t.target === this.dom && t.preventDefault(), c && o && !a && t.target === this.dom)
      return t.preventDefault(), !1;
    if (c && l && !a && p) {
      const m = n.closest("[data-drag-handle]");
      m && (this.dom === m || this.dom.contains(m)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(a || i || d || f || h || p && u);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(t) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: t }) : this.node.isLeaf || this.node.isAtom ? !0 : t.type === "selection" || this.dom.contains(t.target) && t.type === "childList" && (Is() || Am()) && this.editor.isFocused && [...Array.from(t.addedNodes), ...Array.from(t.removedNodes)].every((n) => n.isContentEditable) ? !1 : this.contentDOM === t.target && t.type === "attributes" ? !0 : !this.contentDOM.contains(t.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(t) {
    this.editor.commands.command(({ tr: e }) => {
      const n = this.getPos();
      return typeof n != "number" ? !1 : (e.setNodeMarkup(n, void 0, {
        ...this.node.attrs,
        ...t
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const t = this.getPos();
    if (typeof t != "number")
      return;
    const e = t + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: t, to: e });
  }
};
function Rn(t) {
  return new qv({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
      const i = ee(t.getAttributes, void 0, r, o);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, l = r[r.length - 1], a = r[0];
      let c = n.to;
      if (l) {
        const u = a.search(/\S/), d = n.from + a.indexOf(l), f = d + l.length;
        if (Dc(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((b) => b === t.type && b !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        f < n.to && s.delete(f, n.to), d > n.from && s.delete(n.from + u, d), c = n.from + u + l.length, s.addMark(n.from + u, c, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
var El, cf;
function h7() {
  return cf || (cf = 1, El = function t(e, n) {
    if (e === n) return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
      if (e.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(e)) {
        if (r = e.length, r != n.length) return !1;
        for (o = r; o-- !== 0; )
          if (!t(e[o], n[o])) return !1;
        return !0;
      }
      if (e instanceof Map && n instanceof Map) {
        if (e.size !== n.size) return !1;
        for (o of e.entries())
          if (!n.has(o[0])) return !1;
        for (o of e.entries())
          if (!t(o[1], n.get(o[0]))) return !1;
        return !0;
      }
      if (e instanceof Set && n instanceof Set) {
        if (e.size !== n.size) return !1;
        for (o of e.entries())
          if (!n.has(o[0])) return !1;
        return !0;
      }
      if (ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) {
        if (r = e.length, r != n.length) return !1;
        for (o = r; o-- !== 0; )
          if (e[o] !== n[o]) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
      if (i = Object.keys(e), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!(s === "_owner" && e.$$typeof) && !t(e[s], n[s]))
          return !1;
      }
      return !0;
    }
    return e !== e && n !== n;
  }), El;
}
var p7 = h7();
const m7 = /* @__PURE__ */ Dh(p7);
var $o = { exports: {} }, Ml = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uf;
function g7() {
  if (uf) return Ml;
  uf = 1;
  var t = ve, e = lc();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = e.useSyncExternalStore, i = t.useRef, s = t.useEffect, l = t.useMemo, a = t.useDebugValue;
  return Ml.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
    var p = i(null);
    if (p.current === null) {
      var m = { hasValue: !1, value: null };
      p.current = m;
    } else m = p.current;
    p = l(
      function() {
        function C(k) {
          if (!v) {
            if (v = !0, S = k, k = f(k), h !== void 0 && m.hasValue) {
              var E = m.value;
              if (h(E, k))
                return w = E;
            }
            return w = k;
          }
          if (E = w, r(S, k)) return E;
          var M = f(k);
          return h !== void 0 && h(E, M) ? (S = k, E) : (S = k, w = M);
        }
        var v = !1, S, w, x = d === void 0 ? null : d;
        return [
          function() {
            return C(u());
          },
          x === null ? void 0 : function() {
            return C(x());
          }
        ];
      },
      [u, d, f, h]
    );
    var b = o(c, p[0], p[1]);
    return s(
      function() {
        m.hasValue = !0, m.value = b;
      },
      [b]
    ), a(b), b;
  }, Ml;
}
var Tl = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var df;
function y7() {
  return df || (df = 1, process.env.NODE_ENV !== "production" && (function() {
    function t(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = ve, n = lc(), r = typeof Object.is == "function" ? Object.is : t, o = n.useSyncExternalStore, i = e.useRef, s = e.useEffect, l = e.useMemo, a = e.useDebugValue;
    Tl.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
      var p = i(null);
      if (p.current === null) {
        var m = { hasValue: !1, value: null };
        p.current = m;
      } else m = p.current;
      p = l(
        function() {
          function C(k) {
            if (!v) {
              if (v = !0, S = k, k = f(k), h !== void 0 && m.hasValue) {
                var E = m.value;
                if (h(E, k))
                  return w = E;
              }
              return w = k;
            }
            if (E = w, r(S, k))
              return E;
            var M = f(k);
            return h !== void 0 && h(E, M) ? (S = k, E) : (S = k, w = M);
          }
          var v = !1, S, w, x = d === void 0 ? null : d;
          return [
            function() {
              return C(u());
            },
            x === null ? void 0 : function() {
              return C(x());
            }
          ];
        },
        [u, d, f, h]
      );
      var b = o(c, p[0], p[1]);
      return s(
        function() {
          m.hasValue = !0, m.value = b;
        },
        [b]
      ), a(b), b;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), Tl;
}
var ff;
function b7() {
  return ff || (ff = 1, process.env.NODE_ENV === "production" ? $o.exports = g7() : $o.exports = y7()), $o.exports;
}
var C7 = b7(), v7 = (...t) => (e) => {
  t.forEach((n) => {
    typeof n == "function" ? n(e) : n && (n.current = e);
  });
}, w7 = ({ contentComponent: t }) => {
  const e = Ph.useSyncExternalStore(
    t.subscribe,
    t.getSnapshot,
    t.getServerSnapshot
  );
  return /* @__PURE__ */ g(le, { children: Object.values(e) });
};
function S7() {
  const t = /* @__PURE__ */ new Set();
  let e = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return t.add(n), () => {
        t.delete(n);
      };
    },
    getSnapshot() {
      return e;
    },
    getServerSnapshot() {
      return e;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      e = {
        ...e,
        [n]: Ih.createPortal(r.reactElement, r.element, n)
      }, t.forEach((o) => o());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...e };
      delete r[n], e = r, t.forEach((o) => o());
    }
  };
}
var x7 = class extends ve.Component {
  constructor(t) {
    var e;
    super(t), this.editorContentRef = ve.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!((e = t.editor) != null && e.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const t = this.props.editor;
    if (t && !t.isDestroyed && t.options.element) {
      if (t.contentComponent)
        return;
      const e = this.editorContentRef.current;
      e.append(...t.options.element.childNodes), t.setOptions({
        element: e
      }), t.contentComponent = S7(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = t.contentComponent.subscribe(() => {
        this.setState((n) => n.hasContentComponentInitialized ? n : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), t.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    var t;
    const e = this.props.editor;
    if (!e || (this.initialized = !1, e.isDestroyed || e.view.setProps({
      nodeViews: {}
    }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), e.contentComponent = null, !((t = e.options.element) != null && t.firstChild)))
      return;
    const n = document.createElement("div");
    n.append(...e.options.element.childNodes), e.setOptions({
      element: n
    });
  }
  render() {
    const { editor: t, innerRef: e, ...n } = this.props;
    return /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ g("div", { ref: v7(e, this.editorContentRef), ...n }),
      t?.contentComponent && /* @__PURE__ */ g(w7, { contentComponent: t.contentComponent })
    ] });
  }
}, k7 = vy(
  (t, e) => {
    const n = ve.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [t.editor]);
    return ve.createElement(x7, {
      key: n,
      innerRef: e,
      ...t
    });
  }
), E7 = ve.memo(k7), M7 = typeof window < "u" ? bs : Zt, T7 = class {
  constructor(t) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = t, this.lastSnapshot = { editor: t, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscribers.add(t), () => {
      this.subscribers.delete(t);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(t) {
    if (this.editor = t, this.editor) {
      const e = () => {
        this.transactionNumber += 1, this.subscribers.forEach((r) => r());
      }, n = this.editor;
      return n.on("transaction", e), () => {
        n.off("transaction", e);
      };
    }
  }
};
function $m(t) {
  var e;
  const [n] = Xr(() => new T7(t.editor)), r = C7.useSyncExternalStoreWithSelector(
    n.subscribe,
    n.getSnapshot,
    n.getServerSnapshot,
    t.selector,
    (e = t.equalityFn) != null ? e : m7
  );
  return M7(() => n.watch(t.editor), [t.editor, n]), Nh(r), r;
}
var hf = process.env.NODE_ENV !== "production", wa = typeof window > "u", R7 = wa || !!(typeof window < "u" && window.next), A7 = class Um {
  constructor(e) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = e, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(e) {
    this.editor = e, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0) {
      if (wa || R7) {
        if (hf)
          throw new Error(
            "Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches."
          );
        return null;
      }
      return this.createEditor();
    }
    if (this.options.current.immediatelyRender && wa && hf)
      throw new Error(
        "Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches."
      );
    return this.options.current.immediatelyRender ? this.createEditor() : null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const e = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBeforeCreate) == null ? void 0 : i.call(o, ...r);
      },
      onBlur: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBlur) == null ? void 0 : i.call(o, ...r);
      },
      onCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onCreate) == null ? void 0 : i.call(o, ...r);
      },
      onDestroy: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDestroy) == null ? void 0 : i.call(o, ...r);
      },
      onFocus: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onFocus) == null ? void 0 : i.call(o, ...r);
      },
      onSelectionUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onSelectionUpdate) == null ? void 0 : i.call(o, ...r);
      },
      onTransaction: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onTransaction) == null ? void 0 : i.call(o, ...r);
      },
      onUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onUpdate) == null ? void 0 : i.call(o, ...r);
      },
      onContentError: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onContentError) == null ? void 0 : i.call(o, ...r);
      },
      onDrop: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDrop) == null ? void 0 : i.call(o, ...r);
      },
      onPaste: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onPaste) == null ? void 0 : i.call(o, ...r);
      },
      onDelete: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDelete) == null ? void 0 : i.call(o, ...r);
      }
    };
    return new c7(e);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscriptions.add(e), () => {
      this.subscriptions.delete(e);
    };
  }
  static compareOptions(e, n) {
    return Object.keys(e).every((r) => [
      "onCreate",
      "onBeforeCreate",
      "onDestroy",
      "onUpdate",
      "onTransaction",
      "onFocus",
      "onBlur",
      "onSelectionUpdate",
      "onContentError",
      "onDrop",
      "onPaste"
    ].includes(r) ? !0 : r === "extensions" && e.extensions && n.extensions ? e.extensions.length !== n.extensions.length ? !1 : e.extensions.every((o, i) => {
      var s;
      return o === ((s = n.extensions) == null ? void 0 : s[i]);
    }) : e[r] === n[r]);
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(e) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && e.length === 0 ? Um.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(e), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(e) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = e;
        return;
      }
      if (this.previousDeps.length === e.length && this.previousDeps.every((r, o) => r === e[o]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = e;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const e = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === e) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === e && this.setEditor(null));
    }, 1);
  }
};
function O7(t = {}, e = []) {
  const n = Nt(t);
  n.current = t;
  const [r] = Xr(() => new A7(n)), o = Ph.useSyncExternalStore(
    r.subscribe,
    r.getEditor,
    r.getServerSnapshot
  );
  return Nh(o), Zt(r.onRender(e)), $m({
    editor: o,
    selector: ({ transactionNumber: i }) => t.shouldRerenderOnTransaction === !1 || t.shouldRerenderOnTransaction === void 0 ? null : t.immediatelyRender && i === 0 ? 0 : i + 1
  }), o;
}
var Hc = gs({
  editor: null
});
Hc.Consumer;
var Fc = () => ys(Hc), Wm = gs({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
}), Km = () => ys(Wm);
function N7({
  as: t = "div",
  ...e
}) {
  const { nodeViewContentRef: n, nodeViewContentChildren: r } = Km();
  return (
    // @ts-ignore
    /* @__PURE__ */ g(
      t,
      {
        ...e,
        ref: n,
        "data-node-view-content": "",
        style: {
          whiteSpace: "pre-wrap",
          ...e.style
        },
        children: r
      }
    )
  );
}
var Ls = ve.forwardRef((t, e) => {
  const { onDragStart: n } = Km(), r = t.as || "div";
  return (
    // @ts-ignore
    /* @__PURE__ */ g(
      r,
      {
        ...t,
        ref: e,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
          whiteSpace: "normal",
          ...t.style
        }
      }
    )
  );
});
function pf(t) {
  return !!(typeof t == "function" && t.prototype && t.prototype.isReactComponent);
}
function mf(t) {
  return !!(typeof t == "object" && t.$$typeof && (t.$$typeof.toString() === "Symbol(react.forward_ref)" || t.$$typeof.description === "react.forward_ref"));
}
function I7(t) {
  return !!(typeof t == "object" && t.$$typeof && (t.$$typeof.toString() === "Symbol(react.memo)" || t.$$typeof.description === "react.memo"));
}
function L7(t) {
  if (pf(t) || mf(t))
    return !0;
  if (I7(t)) {
    const e = t.type;
    if (e)
      return pf(e) || mf(e);
  }
  return !1;
}
function D7() {
  try {
    if (Xu)
      return parseInt(Xu.split(".")[0], 10) >= 19;
  } catch {
  }
  return !1;
}
var P7 = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(t, { editor: e, props: n = {}, as: r = "div", className: o = "" }) {
    this.ref = null, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = t, this.editor = e, this.props = n, this.element = document.createElement(r), this.element.classList.add("react-renderer"), o && this.element.classList.add(...o.split(" ")), this.editor.isInitialized ? wy(() => {
      this.render();
    }) : queueMicrotask(() => {
      this.render();
    });
  }
  /**
   * Render the React component.
   */
  render() {
    var t;
    const e = this.component, n = this.props, r = this.editor, o = D7(), i = L7(e), s = { ...n };
    s.ref && !(o || i) && delete s.ref, !s.ref && (o || i) && (s.ref = (l) => {
      this.ref = l;
    }), this.reactElement = /* @__PURE__ */ g(e, { ...s }), (t = r?.contentComponent) == null || t.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(t = {}) {
    this.props = {
      ...this.props,
      ...t
    }, this.render();
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var t;
    const e = this.editor;
    (t = e?.contentComponent) == null || t.removeRenderer(this.id);
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(t) {
    Object.keys(t).forEach((e) => {
      this.element.setAttribute(e, t[e]);
    });
  }
};
ve.createContext({
  markViewContentRef: () => {
  }
});
var B7 = class extends f7 {
  constructor(t, e, n) {
    if (super(t, e, n), !this.node.isLeaf) {
      this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.dataset.nodeViewWrapper = "", this.contentDOMElement.style.whiteSpace = "inherit";
      const r = this.dom.querySelector("[data-node-view-content]");
      if (!r)
        return;
      r.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const t = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extension,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (a = {}) => this.updateAttributes(a),
      deleteNode: () => this.deleteNode(),
      ref: yy()
    };
    if (!this.component.displayName) {
      const a = (c) => c.charAt(0).toUpperCase() + c.substring(1);
      this.component.displayName = a(this.extension.name);
    }
    const r = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (a) => {
      a && this.contentDOMElement && a.firstChild !== this.contentDOMElement && (a.hasAttribute("data-node-view-wrapper") && a.removeAttribute("data-node-view-wrapper"), a.appendChild(this.contentDOMElement));
    } }, o = this.component, i = by((a) => /* @__PURE__ */ g(Wm.Provider, { value: r, children: Cy(o, a) }));
    i.displayName = "ReactNodeView";
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: l = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.renderer = new P7(i, {
      editor: this.editor,
      props: t,
      as: s,
      className: `node-${this.node.type.name} ${l}`.trim()
    }), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var t;
    if (this.renderer.element.firstElementChild && !((t = this.renderer.element.firstElementChild) != null && t.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    const { from: t, to: e } = this.editor.state.selection, n = this.getPos();
    if (typeof n == "number")
      if (t <= n && e >= n + this.node.nodeSize) {
        if (this.renderer.props.selected)
          return;
        this.selectNode();
      } else {
        if (!this.renderer.props.selected)
          return;
        this.deselectNode();
      }
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(t, e, n) {
    const r = (o) => {
      this.renderer.updateProps(o), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (t.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const o = this.node, i = this.decorations, s = this.innerDecorations;
      return this.node = t, this.decorations = e, this.innerDecorations = n, this.options.update({
        oldNode: o,
        oldDecorations: i,
        newNode: t,
        newDecorations: e,
        oldInnerDecorations: s,
        innerDecorations: n,
        updateProps: () => r({ node: t, decorations: e, innerDecorations: n })
      });
    }
    return t === this.node && this.decorations === e && this.innerDecorations === n || (this.node = t, this.decorations = e, this.innerDecorations = n, r({ node: t, decorations: e, innerDecorations: n })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null;
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let t = {};
      if (typeof this.options.attrs == "function") {
        const e = this.editor.extensionManager.attributes, n = ao(this.node, e);
        t = this.options.attrs({ node: this.node, HTMLAttributes: n });
      } else
        t = this.options.attrs;
      this.renderer.updateAttributes(t);
    }
  }
};
function Ds(t, e) {
  return (n) => n.editor.contentComponent ? new B7(t, n, e) : {};
}
var Ai = (t, e) => {
  if (t === "slot")
    return 0;
  if (t instanceof Function)
    return t(e);
  const { children: n, ...r } = e ?? {};
  if (t === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [t, r, n];
}, H7 = /^\s*>\s$/, F7 = Ce.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ Ai("blockquote", { ...X(this.options.HTMLAttributes, t), children: /* @__PURE__ */ Ai("slot", {}) });
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      kr({
        find: H7,
        type: this.type
      })
    ];
  }
}), _7 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, z7 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, V7 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, $7 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, U7 = Ct.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ Ai("strong", { ...X(this.options.HTMLAttributes, t), children: /* @__PURE__ */ Ai("slot", {}) });
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Zn({
        find: _7,
        type: this.type
      }),
      Zn({
        find: V7,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Rn({
        find: z7,
        type: this.type
      }),
      Rn({
        find: $7,
        type: this.type
      })
    ];
  }
}), W7 = /(^|[^`])`([^`]+)`(?!`)/, K7 = /(^|[^`])`([^`]+)`(?!`)/g, j7 = Ct.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Zn({
        find: W7,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Rn({
        find: K7,
        type: this.type
      })
    ];
  }
}), q7 = /^```([a-z]+)?[\s\n]$/, G7 = /^~~~([a-z]+)?[\s\n]$/, Z7 = Ce.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options, i = [...((e = t.firstElementChild) == null ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return i || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      X(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: o } = n;
        if (!o || r.parent.type !== this.type)
          return !1;
        const i = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !i || !s ? !1 : t.chain().command(({ tr: l }) => (l.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: o, empty: i } = n;
        if (!i || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
          return !1;
        const l = o.after();
        return l === void 0 ? !1 : r.nodeAt(l) ? t.commands.command(({ tr: c }) => (c.setSelection(K.near(r.resolve(l))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      va({
        find: q7,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      va({
        find: G7,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new ue({
        key: new pe("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), o = r ? JSON.parse(r) : void 0, i = o?.mode;
            if (!n || !i)
              return !1;
            const { tr: s, schema: l } = t.state, a = l.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: i }, a)), s.selection.$from.parent.type !== this.type && s.setSelection(V.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), t.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), J7 = Ce.create({
  name: "doc",
  topNode: !0,
  content: "block+"
}), Y7 = Ce.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", X(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: o, storedMarks: i } = n;
          if (o.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: l } = r.extensionManager, a = i || o.$to.parentOffset && o.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && a && s) {
              const d = a.filter((f) => l.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), X7 = Ce.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, X(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (t, e) => ({
        ...t,
        [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((t) => va({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), jm = Ce.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", X(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        if (!u7(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: n } = e, { $to: r } = n, o = t();
        return wm(n) ? o.insertContentAt(r.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ tr: i, dispatch: s }) => {
          var l;
          if (s) {
            const { $to: a } = i.selection, c = a.end();
            if (a.nodeAfter)
              a.nodeAfter.isTextblock ? i.setSelection(V.create(i.doc, a.pos + 1)) : a.nodeAfter.isBlock ? i.setSelection(z.create(i.doc, a.pos)) : i.setSelection(V.create(i.doc, a.pos));
            else {
              const u = (l = a.parent.type.contentMatch.defaultType) == null ? void 0 : l.create();
              u && (i.insert(c, u), i.setSelection(V.create(i.doc, c + 1)));
            }
            i.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      zm({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), Q7 = jm, e4 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, t4 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, n4 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, r4 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, o4 = Ct.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Zn({
        find: e4,
        type: this.type
      }),
      Zn({
        find: n4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Rn({
        find: t4,
        type: this.type
      }),
      Rn({
        find: r4,
        type: this.type
      })
    ];
  }
});
const i4 = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", s4 = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Sa = "numeric", xa = "ascii", ka = "alpha", jr = "asciinumeric", zr = "alphanumeric", Ea = "domain", qm = "emoji", l4 = "scheme", a4 = "slashscheme", Rl = "whitespace";
function c4(t, e) {
  return t in e || (e[t] = []), e[t];
}
function _n(t, e, n) {
  e[Sa] && (e[jr] = !0, e[zr] = !0), e[xa] && (e[jr] = !0, e[ka] = !0), e[jr] && (e[zr] = !0), e[ka] && (e[zr] = !0), e[zr] && (e[Ea] = !0), e[qm] && (e[Ea] = !0);
  for (const r in e) {
    const o = c4(r, n);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function u4(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function Ue(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
Ue.groups = {};
Ue.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const o = e.jr[r][0], i = e.jr[r][1];
      if (i && o.test(t))
        return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let o = 0; o < t.length; o++)
      this.tt(t[o], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || Ue.groups;
    let o;
    return e && e.j ? o = e : (o = new Ue(e), n && r && _n(e, n, r)), this.jr.push([t, o]), o;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let o = this;
    const i = t.length;
    if (!i)
      return o;
    for (let s = 0; s < i - 1; s++)
      o = o.tt(t[s]);
    return o.tt(t[i - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || Ue.groups;
    const o = this;
    if (e && e.j)
      return o.j[t] = e, e;
    const i = e;
    let s, l = o.go(t);
    if (l ? (s = new Ue(), Object.assign(s.j, l.j), s.jr.push.apply(s.jr, l.jr), s.jd = l.jd, s.t = l.t) : s = new Ue(), i) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const a = Object.assign(u4(s.t, r), n);
          _n(i, a, r);
        } else n && _n(i, n, r);
      s.t = i;
    }
    return o.j[t] = s, s;
  }
};
const G = (t, e, n, r, o) => t.ta(e, n, r, o), me = (t, e, n, r, o) => t.tr(e, n, r, o), gf = (t, e, n, r, o) => t.ts(e, n, r, o), L = (t, e, n, r, o) => t.tt(e, n, r, o), $t = "WORD", Ma = "UWORD", Gm = "ASCIINUMERICAL", Zm = "ALPHANUMERICAL", co = "LOCALHOST", Ta = "TLD", Ra = "UTLD", ai = "SCHEME", hr = "SLASH_SCHEME", _c = "NUM", Aa = "WS", zc = "NL", qr = "OPENBRACE", Gr = "CLOSEBRACE", Oi = "OPENBRACKET", Ni = "CLOSEBRACKET", Ii = "OPENPAREN", Li = "CLOSEPAREN", Di = "OPENANGLEBRACKET", Pi = "CLOSEANGLEBRACKET", Bi = "FULLWIDTHLEFTPAREN", Hi = "FULLWIDTHRIGHTPAREN", Fi = "LEFTCORNERBRACKET", _i = "RIGHTCORNERBRACKET", zi = "LEFTWHITECORNERBRACKET", Vi = "RIGHTWHITECORNERBRACKET", $i = "FULLWIDTHLESSTHAN", Ui = "FULLWIDTHGREATERTHAN", Wi = "AMPERSAND", Ki = "APOSTROPHE", ji = "ASTERISK", un = "AT", qi = "BACKSLASH", Gi = "BACKTICK", Zi = "CARET", hn = "COLON", Vc = "COMMA", Ji = "DOLLAR", kt = "DOT", Yi = "EQUALS", $c = "EXCLAMATION", tt = "HYPHEN", Zr = "PERCENT", Xi = "PIPE", Qi = "PLUS", es = "POUND", Jr = "QUERY", Uc = "QUOTE", Jm = "FULLWIDTHMIDDLEDOT", Wc = "SEMI", Et = "SLASH", Yr = "TILDE", ts = "UNDERSCORE", Ym = "EMOJI", ns = "SYM";
var Xm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Zm,
  AMPERSAND: Wi,
  APOSTROPHE: Ki,
  ASCIINUMERICAL: Gm,
  ASTERISK: ji,
  AT: un,
  BACKSLASH: qi,
  BACKTICK: Gi,
  CARET: Zi,
  CLOSEANGLEBRACKET: Pi,
  CLOSEBRACE: Gr,
  CLOSEBRACKET: Ni,
  CLOSEPAREN: Li,
  COLON: hn,
  COMMA: Vc,
  DOLLAR: Ji,
  DOT: kt,
  EMOJI: Ym,
  EQUALS: Yi,
  EXCLAMATION: $c,
  FULLWIDTHGREATERTHAN: Ui,
  FULLWIDTHLEFTPAREN: Bi,
  FULLWIDTHLESSTHAN: $i,
  FULLWIDTHMIDDLEDOT: Jm,
  FULLWIDTHRIGHTPAREN: Hi,
  HYPHEN: tt,
  LEFTCORNERBRACKET: Fi,
  LEFTWHITECORNERBRACKET: zi,
  LOCALHOST: co,
  NL: zc,
  NUM: _c,
  OPENANGLEBRACKET: Di,
  OPENBRACE: qr,
  OPENBRACKET: Oi,
  OPENPAREN: Ii,
  PERCENT: Zr,
  PIPE: Xi,
  PLUS: Qi,
  POUND: es,
  QUERY: Jr,
  QUOTE: Uc,
  RIGHTCORNERBRACKET: _i,
  RIGHTWHITECORNERBRACKET: Vi,
  SCHEME: ai,
  SEMI: Wc,
  SLASH: Et,
  SLASH_SCHEME: hr,
  SYM: ns,
  TILDE: Yr,
  TLD: Ta,
  UNDERSCORE: ts,
  UTLD: Ra,
  UWORD: Ma,
  WORD: $t,
  WS: Aa
});
const zt = /[a-z]/, Br = new RegExp("\\p{L}", "u"), Al = new RegExp("\\p{Emoji}", "u"), Vt = /\d/, Ol = /\s/, yf = "\r", Nl = `
`, d4 = "️", f4 = "‍", Il = "￼";
let Uo = null, Wo = null;
function h4(t = []) {
  const e = {};
  Ue.groups = e;
  const n = new Ue();
  Uo == null && (Uo = bf(i4)), Wo == null && (Wo = bf(s4)), L(n, "'", Ki), L(n, "{", qr), L(n, "}", Gr), L(n, "[", Oi), L(n, "]", Ni), L(n, "(", Ii), L(n, ")", Li), L(n, "<", Di), L(n, ">", Pi), L(n, "（", Bi), L(n, "）", Hi), L(n, "「", Fi), L(n, "」", _i), L(n, "『", zi), L(n, "』", Vi), L(n, "＜", $i), L(n, "＞", Ui), L(n, "&", Wi), L(n, "*", ji), L(n, "@", un), L(n, "`", Gi), L(n, "^", Zi), L(n, ":", hn), L(n, ",", Vc), L(n, "$", Ji), L(n, ".", kt), L(n, "=", Yi), L(n, "!", $c), L(n, "-", tt), L(n, "%", Zr), L(n, "|", Xi), L(n, "+", Qi), L(n, "#", es), L(n, "?", Jr), L(n, '"', Uc), L(n, "/", Et), L(n, ";", Wc), L(n, "~", Yr), L(n, "_", ts), L(n, "\\", qi), L(n, "・", Jm);
  const r = me(n, Vt, _c, {
    [Sa]: !0
  });
  me(r, Vt, r);
  const o = me(r, zt, Gm, {
    [jr]: !0
  }), i = me(r, Br, Zm, {
    [zr]: !0
  }), s = me(n, zt, $t, {
    [xa]: !0
  });
  me(s, Vt, o), me(s, zt, s), me(o, Vt, o), me(o, zt, o);
  const l = me(n, Br, Ma, {
    [ka]: !0
  });
  me(l, zt), me(l, Vt, i), me(l, Br, l), me(i, Vt, i), me(i, zt), me(i, Br, i);
  const a = L(n, Nl, zc, {
    [Rl]: !0
  }), c = L(n, yf, Aa, {
    [Rl]: !0
  }), u = me(n, Ol, Aa, {
    [Rl]: !0
  });
  L(n, Il, u), L(c, Nl, a), L(c, Il, u), me(c, Ol, u), L(u, yf), L(u, Nl), me(u, Ol, u), L(u, Il, u);
  const d = me(n, Al, Ym, {
    [qm]: !0
  });
  L(d, "#"), me(d, Al, d), L(d, d4, d);
  const f = L(d, f4);
  L(f, "#"), me(f, Al, d);
  const h = [[zt, s], [Vt, o]], p = [[zt, null], [Br, l], [Vt, i]];
  for (let m = 0; m < Uo.length; m++)
    on(n, Uo[m], Ta, $t, h);
  for (let m = 0; m < Wo.length; m++)
    on(n, Wo[m], Ra, Ma, p);
  _n(Ta, {
    tld: !0,
    ascii: !0
  }, e), _n(Ra, {
    utld: !0,
    alpha: !0
  }, e), on(n, "file", ai, $t, h), on(n, "mailto", ai, $t, h), on(n, "http", hr, $t, h), on(n, "https", hr, $t, h), on(n, "ftp", hr, $t, h), on(n, "ftps", hr, $t, h), _n(ai, {
    scheme: !0,
    ascii: !0
  }, e), _n(hr, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((m, b) => m[0] > b[0] ? 1 : -1);
  for (let m = 0; m < t.length; m++) {
    const b = t[m][0], v = t[m][1] ? {
      [l4]: !0
    } : {
      [a4]: !0
    };
    b.indexOf("-") >= 0 ? v[Ea] = !0 : zt.test(b) ? Vt.test(b) ? v[jr] = !0 : v[xa] = !0 : v[Sa] = !0, gf(n, b, b, v);
  }
  return gf(n, "localhost", co, {
    ascii: !0
  }), n.jd = new Ue(ns), {
    start: n,
    tokens: Object.assign({
      groups: e
    }, Xm)
  };
}
function Qm(t, e) {
  const n = p4(e.replace(/[A-Z]/g, (l) => l.toLowerCase())), r = n.length, o = [];
  let i = 0, s = 0;
  for (; s < r; ) {
    let l = t, a = null, c = 0, u = null, d = -1, f = -1;
    for (; s < r && (a = l.go(n[s])); )
      l = a, l.accepts() ? (d = 0, f = 0, u = l) : d >= 0 && (d += n[s].length, f++), c += n[s].length, i += n[s].length, s++;
    i -= d, s -= f, c -= d, o.push({
      t: u.t,
      // token type/name
      v: e.slice(i - c, i),
      // string value
      s: i - c,
      // start index
      e: i
      // end index (excluding)
    });
  }
  return o;
}
function p4(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let o = t.charCodeAt(r), i, s = o < 55296 || o > 56319 || r + 1 === n || (i = t.charCodeAt(r + 1)) < 56320 || i > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(s), r += s.length;
  }
  return e;
}
function on(t, e, n, r, o) {
  let i;
  const s = e.length;
  for (let l = 0; l < s - 1; l++) {
    const a = e[l];
    t.j[a] ? i = t.j[a] : (i = new Ue(r), i.jr = o.slice(), t.j[a] = i), t = i;
  }
  return i = new Ue(n), i.jr = o.slice(), t.j[e[s - 1]] = i, i;
}
function bf(t) {
  const e = [], n = [];
  let r = 0, o = "0123456789";
  for (; r < t.length; ) {
    let i = 0;
    for (; o.indexOf(t[r + i]) >= 0; )
      i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--)
        n.pop();
      r += i;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const uo = {
  defaultProtocol: "http",
  events: null,
  format: Cf,
  formatHref: Cf,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Kc(t, e = null) {
  let n = Object.assign({}, uo);
  t && (n = Object.assign(n, t instanceof Kc ? t.o : t));
  const r = n.ignoreTags, o = [];
  for (let i = 0; i < r.length; i++)
    o.push(r[i].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = o;
}
Kc.prototype = {
  o: uo,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let o = this.o[t];
    return o && (typeof o == "object" ? (o = n.t in o ? o[n.t] : uo[t], typeof o == "function" && r && (o = o(e, n))) : typeof o == "function" && r && (o = o(e, n.t, n)), o);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function Cf(t) {
  return t;
}
function e1(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
e1.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = uo.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), o = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, l = t.get("className", n, e), a = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return s.href = r, l && (s.class = l), a && (s.target = a), c && (s.rel = c), u && Object.assign(s, u), {
      tagName: o,
      attributes: s,
      content: i,
      eventListeners: d
    };
  }
};
function Ps(t, e) {
  class n extends e1 {
    constructor(o, i) {
      super(o, i), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const vf = Ps("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), wf = Ps("text"), m4 = Ps("nl"), Ko = Ps("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = uo.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== co && t[1].t === hn;
  }
}), Qe = (t) => new Ue(t);
function g4({
  groups: t
}) {
  const e = t.domain.concat([Wi, ji, un, qi, Gi, Zi, Ji, Yi, tt, _c, Zr, Xi, Qi, es, Et, ns, Yr, ts]), n = [Ki, hn, Vc, kt, $c, Zr, Jr, Uc, Wc, Di, Pi, qr, Gr, Ni, Oi, Ii, Li, Bi, Hi, Fi, _i, zi, Vi, $i, Ui], r = [Wi, Ki, ji, qi, Gi, Zi, Ji, Yi, tt, qr, Gr, Zr, Xi, Qi, es, Jr, Et, ns, Yr, ts], o = Qe(), i = L(o, Yr);
  G(i, r, i), G(i, t.domain, i);
  const s = Qe(), l = Qe(), a = Qe();
  G(o, t.domain, s), G(o, t.scheme, l), G(o, t.slashscheme, a), G(s, r, i), G(s, t.domain, s);
  const c = L(s, un);
  L(i, un, c), L(l, un, c), L(a, un, c);
  const u = L(i, kt);
  G(u, r, i), G(u, t.domain, i);
  const d = Qe();
  G(c, t.domain, d), G(d, t.domain, d);
  const f = L(d, kt);
  G(f, t.domain, d);
  const h = Qe(vf);
  G(f, t.tld, h), G(f, t.utld, h), L(c, co, h);
  const p = L(d, tt);
  L(p, tt, p), G(p, t.domain, d), G(h, t.domain, d), L(h, kt, f), L(h, tt, p);
  const m = L(h, hn);
  G(m, t.numeric, vf);
  const b = L(s, tt), C = L(s, kt);
  L(b, tt, b), G(b, t.domain, s), G(C, r, i), G(C, t.domain, s);
  const v = Qe(Ko);
  G(C, t.tld, v), G(C, t.utld, v), G(v, t.domain, s), G(v, r, i), L(v, kt, C), L(v, tt, b), L(v, un, c);
  const S = L(v, hn), w = Qe(Ko);
  G(S, t.numeric, w);
  const x = Qe(Ko), k = Qe();
  G(x, e, x), G(x, n, k), G(k, e, x), G(k, n, k), L(v, Et, x), L(w, Et, x);
  const E = L(l, hn), M = L(a, hn), N = L(M, Et), T = L(N, Et);
  G(l, t.domain, s), L(l, kt, C), L(l, tt, b), G(a, t.domain, s), L(a, kt, C), L(a, tt, b), G(E, t.domain, x), L(E, Et, x), L(E, Jr, x), G(T, t.domain, x), G(T, e, x), L(T, Et, x);
  const P = [
    [qr, Gr],
    // {}
    [Oi, Ni],
    // []
    [Ii, Li],
    // ()
    [Di, Pi],
    // <>
    [Bi, Hi],
    // （）
    [Fi, _i],
    // 「」
    [zi, Vi],
    // 『』
    [$i, Ui]
    // ＜＞
  ];
  for (let _ = 0; _ < P.length; _++) {
    const [F, D] = P[_], W = L(x, F);
    L(k, F, W), L(W, D, x);
    const $ = Qe(Ko);
    G(W, e, $);
    const H = Qe();
    G(W, n), G($, e, $), G($, n, H), G(H, e, $), G(H, n, H), L($, D, x), L(H, D, x);
  }
  return L(o, co, v), L(o, zc, m4), {
    start: o,
    tokens: Xm
  };
}
function y4(t, e, n) {
  let r = n.length, o = 0, i = [], s = [];
  for (; o < r; ) {
    let l = t, a = null, c = null, u = 0, d = null, f = -1;
    for (; o < r && !(a = l.go(n[o].t)); )
      s.push(n[o++]);
    for (; o < r && (c = a || l.go(n[o].t)); )
      a = null, l = c, l.accepts() ? (f = 0, d = l) : f >= 0 && f++, o++, u++;
    if (f < 0)
      o -= u, o < r && (s.push(n[o]), o++);
    else {
      s.length > 0 && (i.push(Ll(wf, e, s)), s = []), o -= f, u -= f;
      const h = d.t, p = n.slice(o - u, o);
      i.push(Ll(h, e, p));
    }
  }
  return s.length > 0 && i.push(Ll(wf, e, s)), i;
}
function Ll(t, e, n) {
  const r = n[0].s, o = n[n.length - 1].e, i = e.slice(r, o);
  return new t(i, n);
}
const b4 = typeof console < "u" && console && console.warn || (() => {
}), C4 = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", de = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function v4() {
  return Ue.groups = {}, de.scanner = null, de.parser = null, de.tokenQueue = [], de.pluginQueue = [], de.customSchemes = [], de.initialized = !1, de;
}
function Sf(t, e = !1) {
  if (de.initialized && b4(`linkifyjs: already initialized - will not register custom scheme "${t}" ${C4}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  de.customSchemes.push([t, e]);
}
function w4() {
  de.scanner = h4(de.customSchemes);
  for (let t = 0; t < de.tokenQueue.length; t++)
    de.tokenQueue[t][1]({
      scanner: de.scanner
    });
  de.parser = g4(de.scanner.tokens);
  for (let t = 0; t < de.pluginQueue.length; t++)
    de.pluginQueue[t][1]({
      scanner: de.scanner,
      parser: de.parser
    });
  return de.initialized = !0, de;
}
function jc(t) {
  return de.initialized || w4(), y4(de.parser.start, t, Qm(de.scanner.start, t));
}
jc.scan = Qm;
function t1(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new Kc(n), o = jc(t), i = [];
  for (let s = 0; s < o.length; s++) {
    const l = o[s];
    l.isLink && (!e || l.t === e) && r.check(l) && i.push(l.toFormattedObject(r));
  }
  return i;
}
var qc = "[\0-   ᠎ -\u2029 　]", S4 = new RegExp(qc), x4 = new RegExp(`${qc}$`), k4 = new RegExp(qc, "g");
function E4(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function M4(t) {
  return new ue({
    key: new pe("autolink"),
    appendTransaction: (e, n, r) => {
      const o = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), i = e.some((c) => c.getMeta("preventAutolink"));
      if (!o || i)
        return;
      const { tr: s } = r, l = cm(n.doc, [...e]);
      if (Cm(l).forEach(({ newRange: c }) => {
        const u = Av(r.doc, c, (h) => h.isTextblock);
        let d, f;
        if (u.length > 1)
          d = u[0], f = r.doc.textBetween(
            d.pos,
            d.pos + d.node.nodeSize,
            void 0,
            " "
          );
        else if (u.length) {
          const h = r.doc.textBetween(c.from, c.to, " ", " ");
          if (!x4.test(h))
            return;
          d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ");
        }
        if (d && f) {
          const h = f.split(S4).filter(Boolean);
          if (h.length <= 0)
            return !1;
          const p = h[h.length - 1], m = d.pos + f.lastIndexOf(p);
          if (!p)
            return !1;
          const b = jc(p).map((C) => C.toObject(t.defaultProtocol));
          if (!E4(b))
            return !1;
          b.filter((C) => C.isLink).map((C) => ({
            ...C,
            from: m + C.start + 1,
            to: m + C.end + 1
          })).filter((C) => r.schema.marks.code ? !r.doc.rangeHasMark(C.from, C.to, r.schema.marks.code) : !0).filter((C) => t.validate(C.value)).filter((C) => t.shouldAutoLink(C.value)).forEach((C) => {
            Dc(C.from, C.to, r.doc).some((v) => v.mark.type === t.type) || s.addMark(
              C.from,
              C.to,
              t.type.create({
                href: C.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function T4(t) {
  return new ue({
    key: new pe("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var o, i;
        if (r.button !== 0 || !e.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          let u = r.target;
          const d = [];
          for (; u.nodeName !== "DIV"; )
            d.push(u), u = u.parentNode;
          s = d.find((f) => f.nodeName === "A");
        }
        if (!s)
          return !1;
        const l = bm(e.state, t.type.name), a = (o = s?.href) != null ? o : l.href, c = (i = s?.target) != null ? i : l.target;
        return t.enableClickSelection && t.editor.commands.extendMarkRange(t.type.name), s && a ? (window.open(a, c), !0) : !1;
      }
    }
  });
}
function R4(t) {
  return new ue({
    key: new pe("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { state: o } = e, { selection: i } = o, { empty: s } = i;
        if (s)
          return !1;
        let l = "";
        r.content.forEach((c) => {
          l += c.textContent;
        });
        const a = t1(l, { defaultProtocol: t.defaultProtocol }).find(
          (c) => c.isLink && c.value === l
        );
        return !l || !a ? !1 : t.editor.commands.setMark(t.type, {
          href: a.href
        });
      }
    }
  });
}
function Dn(t, e) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return e && e.forEach((r) => {
    const o = typeof r == "string" ? r : r.scheme;
    o && n.push(o);
  }), !t || t.replace(k4, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var A4 = Ct.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        Sf(t);
        return;
      }
      Sf(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    v4();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!Dn(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!Dn(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!Dn(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", X(this.options.HTMLAttributes, t), 0] : ["a", X(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Dn(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!Dn(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Rn({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: r } = this.options, o = t1(t).filter(
              (i) => i.isLink && this.options.isAllowedUri(i.value, {
                defaultValidate: (s) => !!Dn(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            o.length && o.forEach(
              (i) => e.push({
                text: i.value,
                data: {
                  href: i.href
                },
                index: i.start
              })
            );
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(
      M4({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (o) => !!Dn(o, e),
          protocols: e,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), this.options.openOnClick === !0 && t.push(
      T4({
        type: this.type,
        editor: this.editor,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      R4({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      })
    ), t;
  }
}), O4 = Object.defineProperty, N4 = (t, e) => {
  for (var n in e)
    O4(t, n, { get: e[n], enumerable: !0 });
}, I4 = "listItem", xf = "textStyle", kf = /^\s*([-+*])\s$/, n1 = Ce.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(I4, this.editor.getAttributes(xf)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = kr({
      find: kf,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = kr({
      find: kf,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(xf),
      editor: this.editor
    })), [t];
  }
}), r1 = Ce.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", X(this.options.HTMLAttributes, t), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), L4 = {};
N4(L4, {
  findListItemPos: () => So,
  getNextListDepth: () => Gc,
  handleBackspace: () => Oa,
  handleDelete: () => Na,
  hasListBefore: () => o1,
  hasListItemAfter: () => D4,
  hasListItemBefore: () => i1,
  listItemHasSubList: () => s1,
  nextListIsDeeper: () => l1,
  nextListIsHigher: () => a1
});
var So = (t, e) => {
  const { $from: n } = e.selection, r = Se(t, e.schema);
  let o = null, i = n.depth, s = n.pos, l = null;
  for (; i > 0 && l === null; )
    o = n.node(i), o.type === r ? l = i : (i -= 1, s -= 1);
  return l === null ? null : { $pos: e.doc.resolve(s), depth: l };
}, Gc = (t, e) => {
  const n = So(t, e);
  if (!n)
    return !1;
  const [, r] = Hv(e, t, n.$pos.pos + 4);
  return r;
}, o1 = (t, e, n) => {
  const { $anchor: r } = t.selection, o = Math.max(0, r.pos - 2), i = t.doc.resolve(o).node();
  return !(!i || !n.includes(i.type.name));
}, i1 = (t, e) => {
  var n;
  const { $anchor: r } = e.selection, o = e.doc.resolve(r.pos - 2);
  return !(o.index() === 0 || ((n = o.nodeBefore) == null ? void 0 : n.type.name) !== t);
}, s1 = (t, e, n) => {
  if (!n)
    return !1;
  const r = Se(t, e.schema);
  let o = !1;
  return n.descendants((i) => {
    i.type === r && (o = !0);
  }), o;
}, Oa = (t, e, n) => {
  if (t.commands.undoInputRule())
    return !0;
  if (t.state.selection.from !== t.state.selection.to)
    return !1;
  if (!Tn(t.state, e) && o1(t.state, e, n)) {
    const { $anchor: l } = t.state.selection, a = t.state.doc.resolve(l.before() - 1), c = [];
    a.node().descendants((f, h) => {
      f.type.name === e && c.push({ node: f, pos: h });
    });
    const u = c.at(-1);
    if (!u)
      return !1;
    const d = t.state.doc.resolve(a.start() + u.pos + 1);
    return t.chain().cut({ from: l.start() - 1, to: l.end() + 1 }, d.end()).joinForward().run();
  }
  if (!Tn(t.state, e) || !Vv(t.state))
    return !1;
  const r = So(e, t.state);
  if (!r)
    return !1;
  const i = t.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = s1(e, t.state, i);
  return i1(e, t.state) && !s ? t.commands.joinItemBackward() : t.chain().liftListItem(e).run();
}, l1 = (t, e) => {
  const n = Gc(t, e), r = So(t, e);
  return !r || !n ? !1 : n > r.depth;
}, a1 = (t, e) => {
  const n = Gc(t, e), r = So(t, e);
  return !r || !n ? !1 : n < r.depth;
}, Na = (t, e) => {
  if (!Tn(t.state, e) || !zv(t.state, e))
    return !1;
  const { selection: n } = t.state, { $from: r, $to: o } = n;
  return !n.empty && r.sameParent(o) ? !1 : l1(e, t.state) ? t.chain().focus(t.state.selection.from + 4).lift(e).joinBackward().run() : a1(e, t.state) ? t.chain().joinForward().joinBackward().run() : t.commands.joinItemForward();
}, D4 = (t, e) => {
  var n;
  const { $anchor: r } = e.selection, o = e.doc.resolve(r.pos - r.parentOffset - 2);
  return !(o.index() === o.parent.childCount - 1 || ((n = o.nodeAfter) == null ? void 0 : n.type.name) !== t);
}, c1 = Q.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && Na(t, n) && (e = !0);
        }), e;
      },
      "Mod-Delete": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && Na(t, n) && (e = !0);
        }), e;
      },
      Backspace: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          t.state.schema.nodes[n] !== void 0 && Oa(t, n, r) && (e = !0);
        }), e;
      },
      "Mod-Backspace": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          t.state.schema.nodes[n] !== void 0 && Oa(t, n, r) && (e = !0);
        }), e;
      }
    };
  }
}), P4 = "listItem", Ef = "textStyle", Mf = /^(\d+)\.\s$/, u1 = Ce.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", X(this.options.HTMLAttributes, n), 0] : ["ol", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(P4, this.editor.getAttributes(Ef)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = kr({
      find: Mf,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = kr({
      find: Mf,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Ef) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [t];
  }
}), B4 = /^\s*(\[([( |x])?\])\s$/, d1 = Ce.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      X(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
      const o = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), l = document.createElement("input"), a = document.createElement("div"), c = (u) => {
        var d, f;
        l.ariaLabel = ((f = (d = this.options.a11y) == null ? void 0 : d.checkboxLabel) == null ? void 0 : f.call(d, u, l.checked)) || `Task item checkbox for ${u.textContent || "empty task item"}`;
      };
      return c(t), i.contentEditable = "false", l.type = "checkbox", l.addEventListener("mousedown", (u) => u.preventDefault()), l.addEventListener("change", (u) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          l.checked = !l.checked;
          return;
        }
        const { checked: d } = u.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: f }) => {
          const h = n();
          if (typeof h != "number")
            return !1;
          const p = f.doc.nodeAt(h);
          return f.setNodeMarkup(h, void 0, {
            ...p?.attrs,
            checked: d
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, d) || (l.checked = !l.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([u, d]) => {
        o.setAttribute(u, d);
      }), o.dataset.checked = t.attrs.checked, l.checked = t.attrs.checked, i.append(l, s), o.append(i, a), Object.entries(e).forEach(([u, d]) => {
        o.setAttribute(u, d);
      }), {
        dom: o,
        contentDOM: a,
        update: (u) => u.type !== this.type ? !1 : (o.dataset.checked = u.attrs.checked, l.checked = u.attrs.checked, c(u), !0)
      };
    };
  },
  addInputRules() {
    return [
      kr({
        find: B4,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), f1 = Ce.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", X(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
Q.create({
  name: "listKit",
  addExtensions() {
    const t = [];
    return this.options.bulletList !== !1 && t.push(n1.configure(this.options.bulletList)), this.options.listItem !== !1 && t.push(r1.configure(this.options.listItem)), this.options.listKeymap !== !1 && t.push(c1.configure(this.options.listKeymap)), this.options.orderedList !== !1 && t.push(u1.configure(this.options.orderedList)), this.options.taskItem !== !1 && t.push(d1.configure(this.options.taskItem)), this.options.taskList !== !1 && t.push(f1.configure(this.options.taskList)), t;
  }
});
var H4 = Ce.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), F4 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, _4 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, z4 = Ct.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Zn({
        find: F4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Rn({
        find: _4,
        type: this.type
      })
    ];
  }
}), V4 = Ce.create({
  name: "text",
  group: "inline"
}), h1 = Ct.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
function $4(t = {}) {
  return new ue({
    view(e) {
      return new U4(e, t);
    }
  });
}
class U4 {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
      let i = (s) => {
        this[o](s);
      };
      return e.dom.addEventListener(o, i), { name: o, handler: i };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, o = this.editorView.dom, i = o.getBoundingClientRect(), s = i.width / o.offsetWidth, l = i.height / o.offsetHeight;
    if (n) {
      let d = e.nodeBefore, f = e.nodeAfter;
      if (d || f) {
        let h = this.editorView.nodeDOM(this.cursorPos - (d ? d.nodeSize : 0));
        if (h) {
          let p = h.getBoundingClientRect(), m = d ? p.bottom : p.top;
          d && f && (m = (m + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let b = this.width / 2 * l;
          r = { left: p.left, right: p.right, top: m - b, bottom: m + b };
        }
      }
    }
    if (!r) {
      let d = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * s;
      r = { left: d.left - f, right: d.left + f, top: d.top, bottom: d.bottom };
    }
    let a = this.editorView.dom.offsetParent;
    this.element || (this.element = a.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let c, u;
    if (!a || a == document.body && getComputedStyle(a).position == "static")
      c = -pageXOffset, u = -pageYOffset;
    else {
      let d = a.getBoundingClientRect(), f = d.width / a.offsetWidth, h = d.height / a.offsetHeight;
      c = d.left - a.scrollLeft * f, u = d.top - a.scrollTop * h;
    }
    this.element.style.left = (r.left - c) / s + "px", this.element.style.top = (r.top - u) / l + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / l + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), o = r && r.type.spec.disableDropCursor, i = typeof o == "function" ? o(this.editorView, n, e) : o;
    if (n && !i) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let l = ap(this.editorView.state.doc, s, this.editorView.dragging.slice);
        l != null && (s = l);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class ge extends K {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return ge.valid(r) ? new ge(r) : K.near(r);
  }
  content() {
    return B.empty;
  }
  eq(e) {
    return e instanceof ge && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new ge(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Zc(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !W4(e) || !K4(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let o = n.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && ge.valid(e))
        return e;
      let o = e.pos, i = null;
      for (let s = e.depth; ; s--) {
        let l = e.node(s);
        if (n > 0 ? e.indexAfter(s) < l.childCount : e.index(s) > 0) {
          i = l.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        o += n;
        let a = e.doc.resolve(o);
        if (ge.valid(a))
          return a;
      }
      for (; ; ) {
        let s = n > 0 ? i.firstChild : i.lastChild;
        if (!s) {
          if (i.isAtom && !i.isText && !z.isSelectable(i)) {
            e = e.doc.resolve(o + i.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        i = s, o += n;
        let l = e.doc.resolve(o);
        if (ge.valid(l))
          return l;
      }
      return null;
    }
  }
}
ge.prototype.visible = !1;
ge.findFrom = ge.findGapCursorFrom;
K.jsonID("gapcursor", ge);
class Zc {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Zc(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return ge.valid(n) ? new ge(n) : K.near(n);
  }
}
function W4(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(n - 1); ; o = o.lastChild) {
      if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function K4(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(n); ; o = o.firstChild) {
      if (o.childCount == 0 && !o.inlineContent || o.isAtom || o.type.spec.isolating)
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function j4() {
  return new ue({
    props: {
      decorations: J4,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && ge.valid(n) ? new ge(n) : null;
      },
      handleClick: G4,
      handleKeyDown: q4,
      handleDOMEvents: { beforeinput: Z4 }
    }
  });
}
const q4 = Sc({
  ArrowLeft: jo("horiz", -1),
  ArrowRight: jo("horiz", 1),
  ArrowUp: jo("vert", -1),
  ArrowDown: jo("vert", 1)
});
function jo(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, o, i) {
    let s = r.selection, l = e > 0 ? s.$to : s.$from, a = s.empty;
    if (s instanceof V) {
      if (!i.endOfTextblock(n) || l.depth == 0)
        return !1;
      a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let c = ge.findGapCursorFrom(l, e, a);
    return c ? (o && o(r.tr.setSelection(new ge(c))), !0) : !1;
  };
}
function G4(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!ge.valid(r))
    return !1;
  let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return o && o.inside > -1 && z.isSelectable(t.state.doc.nodeAt(o.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new ge(r))), !0);
}
function Z4(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof ge))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let o = A.empty;
  for (let s = r.length - 1; s >= 0; s--)
    o = A.from(r[s].createAndFill(null, o));
  let i = t.state.tr.replace(n.pos, n.pos, new B(o, 0, 0));
  return i.setSelection(V.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function J4(t) {
  if (!(t.selection instanceof ge))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", ae.create(t.doc, [Ee.widget(t.selection.head, e, { key: "gapcursor" })]);
}
var rs = 200, Te = function() {
};
Te.prototype.append = function(e) {
  return e.length ? (e = Te.from(e), !this.length && e || e.length < rs && this.leafAppend(e) || this.length < rs && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Te.prototype.prepend = function(e) {
  return e.length ? Te.from(e).append(this) : this;
};
Te.prototype.appendInner = function(e) {
  return new Y4(this, e);
};
Te.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? Te.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
Te.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Te.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
Te.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var o = [];
  return this.forEach(function(i, s) {
    return o.push(e(i, s));
  }, n, r), o;
};
Te.from = function(e) {
  return e instanceof Te ? e : e && e.length ? new p1(e) : Te.empty;
};
var p1 = /* @__PURE__ */ (function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(o, i) {
    return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
  }, e.prototype.getInner = function(o) {
    return this.values[o];
  }, e.prototype.forEachInner = function(o, i, s, l) {
    for (var a = i; a < s; a++)
      if (o(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(o, i, s, l) {
    for (var a = i - 1; a >= s; a--)
      if (o(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.leafAppend = function(o) {
    if (this.length + o.length <= rs)
      return new e(this.values.concat(o.flatten()));
  }, e.prototype.leafPrepend = function(o) {
    if (this.length + o.length <= rs)
      return new e(o.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
})(Te);
Te.empty = new p1([]);
var Y4 = /* @__PURE__ */ (function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, o, i, s) {
    var l = this.left.length;
    if (o < l && this.left.forEachInner(r, o, Math.min(i, l), s) === !1 || i > l && this.right.forEachInner(r, Math.max(o - l, 0), Math.min(this.length, i) - l, s + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, o, i, s) {
    var l = this.left.length;
    if (o > l && this.right.forEachInvertedInner(r, o - l, Math.max(i, l) - l, s + l) === !1 || i < l && this.left.forEachInvertedInner(r, Math.min(o, l), i, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, o) {
    if (r == 0 && o == this.length)
      return this;
    var i = this.left.length;
    return o <= i ? this.left.slice(r, o) : r >= i ? this.right.slice(r - i, o - i) : this.left.slice(r, i).append(this.right.slice(0, o - i));
  }, e.prototype.leafAppend = function(r) {
    var o = this.right.leafAppend(r);
    if (o)
      return new e(this.left, o);
  }, e.prototype.leafPrepend = function(r) {
    var o = this.left.leafPrepend(r);
    if (o)
      return new e(o, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
})(Te);
const X4 = 500;
class dt {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let o, i;
    n && (o = this.remapping(r, this.items.length), i = o.maps.length);
    let s = e.tr, l, a, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        o || (o = this.remapping(r, f + 1), i = o.maps.length), i--, u.push(d);
        return;
      }
      if (o) {
        u.push(new sn(d.map));
        let h = d.step.map(o.slice(i)), p;
        h && s.maybeStep(h).doc && (p = s.mapping.maps[s.mapping.maps.length - 1], c.push(new sn(p, void 0, void 0, c.length + u.length))), i--, p && o.appendMap(p, i);
      } else
        s.maybeStep(d.step);
      if (d.selection)
        return l = o ? d.selection.map(o.slice(i)) : d.selection, a = new dt(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: a, transform: s, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, o) {
    let i = [], s = this.eventCount, l = this.items, a = !o && l.length ? l.get(l.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new sn(e.mapping.maps[u], d, n), h;
      (h = a && a.merge(f)) && (f = h, u ? i.pop() : l = l.slice(0, l.length - 1)), i.push(f), n && (s++, n = void 0), o || (a = f);
    }
    let c = s - r.depth;
    return c > e5 && (l = Q4(l, c), s -= c), new dt(l.append(i), s);
  }
  remapping(e, n) {
    let r = new to();
    return this.items.forEach((o, i) => {
      let s = o.mirrorOffset != null && i - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
      r.appendMap(o.map, s);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new dt(this.items.append(e.map((n) => new sn(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], o = Math.max(0, this.items.length - n), i = e.mapping, s = e.steps.length, l = this.eventCount;
    this.items.forEach((f) => {
      f.selection && l--;
    }, o);
    let a = n;
    this.items.forEach((f) => {
      let h = i.getMirror(--a);
      if (h == null)
        return;
      s = Math.min(s, h);
      let p = i.maps[h];
      if (f.step) {
        let m = e.steps[h].invert(e.docs[h]), b = f.selection && f.selection.map(i.slice(a + 1, h));
        b && l++, r.push(new sn(p, m, b));
      } else
        r.push(new sn(p));
    }, o);
    let c = [];
    for (let f = n; f < s; f++)
      c.push(new sn(i.maps[f]));
    let u = this.items.slice(0, o).append(c).append(r), d = new dt(u, l);
    return d.emptyItemCount() > X4 && (d = d.compress(this.items.length - r.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, o = [], i = 0;
    return this.items.forEach((s, l) => {
      if (l >= e)
        o.push(s), s.selection && i++;
      else if (s.step) {
        let a = s.step.map(n.slice(r)), c = a && a.getMap();
        if (r--, c && n.appendMap(c, r), a) {
          let u = s.selection && s.selection.map(n.slice(r));
          u && i++;
          let d = new sn(c.invert(), a, u), f, h = o.length - 1;
          (f = o.length && o[h].merge(d)) ? o[h] = f : o.push(d);
        }
      } else s.map && r--;
    }, this.items.length, 0), new dt(Te.from(o.reverse()), i);
  }
}
dt.empty = new dt(Te.empty, 0);
function Q4(t, e) {
  let n;
  return t.forEach((r, o) => {
    if (r.selection && e-- == 0)
      return n = o, !1;
  }), t.slice(n);
}
let sn = class m1 {
  constructor(e, n, r, o) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = o;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new m1(n.getMap().invert(), n, this.selection);
    }
  }
};
class dn {
  constructor(e, n, r, o, i) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = o, this.prevComposition = i;
  }
}
const e5 = 20;
function t5(t, e, n, r) {
  let o = n.getMeta(Wn), i;
  if (o)
    return o.historyState;
  n.getMeta(o5) && (t = new dn(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(Wn))
    return s.getMeta(Wn).redo ? new dn(t.done.addTransform(n, void 0, r, ci(e)), t.undone, Tf(n.mapping.maps), t.prevTime, t.prevComposition) : new dn(t.done, t.undone.addTransform(n, void 0, r, ci(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let l = n.getMeta("composition"), a = t.prevTime == 0 || !s && t.prevComposition != l && (t.prevTime < (n.time || 0) - r.newGroupDelay || !n5(n, t.prevRanges)), c = s ? Dl(t.prevRanges, n.mapping) : Tf(n.mapping.maps);
    return new dn(t.done.addTransform(n, a ? e.selection.getBookmark() : void 0, r, ci(e)), dt.empty, c, n.time, l ?? t.prevComposition);
  } else return (i = n.getMeta("rebased")) ? new dn(t.done.rebased(n, i), t.undone.rebased(n, i), Dl(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new dn(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), Dl(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function n5(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, o) => {
    for (let i = 0; i < e.length; i += 2)
      r <= e[i + 1] && o >= e[i] && (n = !0);
  }), n;
}
function Tf(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, o, i, s) => e.push(i, s));
  return e;
}
function Dl(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let o = e.map(t[r], 1), i = e.map(t[r + 1], -1);
    o <= i && n.push(o, i);
  }
  return n;
}
function r5(t, e, n) {
  let r = ci(e), o = Wn.get(e).spec.config, i = (n ? t.undone : t.done).popEvent(e, r);
  if (!i)
    return null;
  let s = i.selection.resolve(i.transform.doc), l = (n ? t.done : t.undone).addTransform(i.transform, e.selection.getBookmark(), o, r), a = new dn(n ? l : i.remaining, n ? i.remaining : l, null, 0, -1);
  return i.transform.setSelection(s).setMeta(Wn, { redo: n, historyState: a });
}
let Pl = !1, Rf = null;
function ci(t) {
  let e = t.plugins;
  if (Rf != e) {
    Pl = !1, Rf = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Pl = !0;
        break;
      }
  }
  return Pl;
}
const Wn = new pe("history"), o5 = new pe("closeHistory");
function i5(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new ue({
    key: Wn,
    state: {
      init() {
        return new dn(dt.empty, dt.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return t5(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, o = r == "historyUndo" ? y1 : r == "historyRedo" ? b1 : null;
          return o ? (n.preventDefault(), o(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function g1(t, e) {
  return (n, r) => {
    let o = Wn.getState(n);
    if (!o || (t ? o.undone : o.done).eventCount == 0)
      return !1;
    if (r) {
      let i = r5(o, n, t);
      i && r(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const y1 = g1(!1, !0), b1 = g1(!0, !0);
Q.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = t?.node || this.editor.state.doc;
      if ((t?.mode || this.options.mode) === "textSize") {
        const r = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = t?.node || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new ue({
        key: new pe("characterCount"),
        appendTransaction: (e, n, r) => {
          if (t)
            return;
          const o = this.options.limit;
          if (o == null || o === 0) {
            t = !0;
            return;
          }
          const i = this.storage.characters({ node: r.doc });
          if (i > o) {
            const s = i - o, l = 0, a = s;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`
            );
            const c = r.tr.deleteRange(l, a);
            return t = !0, c;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const r = this.options.limit;
          if (!e.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const o = this.storage.characters({ node: n.doc }), i = this.storage.characters({ node: e.doc });
          if (i <= r || o > r && i > r && i <= o)
            return !0;
          if (o > r && i > r && i > o || !e.getMeta("paste"))
            return !1;
          const l = e.selection.$head.pos, a = i - r, c = l - a, u = l;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > r);
        }
      })
    ];
  }
});
var s5 = Q.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [$4(this.options)];
  }
});
Q.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: o } = e, i = [];
            if (!n || !r)
              return ae.create(t, []);
            let s = 0;
            this.options.mode === "deepest" && t.descendants((a, c) => {
              if (a.isText)
                return;
              if (!(o >= c && o <= c + a.nodeSize - 1))
                return !1;
              s += 1;
            });
            let l = 0;
            return t.descendants((a, c) => {
              if (a.isText || !(o >= c && o <= c + a.nodeSize - 1))
                return !1;
              if (l += 1, this.options.mode === "deepest" && s - l > 0 || this.options.mode === "shallowest" && l > 1)
                return this.options.mode === "deepest";
              i.push(
                Ee.node(c, c + a.nodeSize, {
                  class: this.options.className
                })
              );
            }), ae.create(t, i);
          }
        }
      })
    ];
  }
});
var l5 = Q.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [j4()];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = ee(U(t, "allowGapCursor", n))) != null ? e : null
    };
  }
});
Q.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    return [
      new ue({
        key: new pe("placeholder"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, o = [];
            if (!n)
              return null;
            const i = this.editor.isEmpty;
            return t.descendants((s, l) => {
              const a = r >= l && r <= l + s.nodeSize, c = !s.isLeaf && Os(s);
              if ((a || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                i && u.push(this.options.emptyEditorClass);
                const d = Ee.node(l, l + s.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: s,
                    pos: l,
                    hasAnchor: a
                  }) : this.options.placeholder
                });
                o.push(d);
              }
              return this.options.includeChildren;
            }), ae.create(t, o);
          }
        }
      })
    ];
  }
});
var a5 = Q.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: t, options: e } = this;
    return [
      new ue({
        key: new pe("selection"),
        props: {
          decorations(n) {
            return n.selection.empty || t.isFocused || !t.isEditable || wm(n.selection) || t.view.dragging ? null : ae.create(n.doc, [
              Ee.inline(n.selection.from, n.selection.to, {
                class: e.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function Af({ types: t, node: e }) {
  return e && Array.isArray(t) && t.includes(e.type) || e?.type === t;
}
var c5 = Q.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    const t = new pe(this.name), e = Object.entries(this.editor.schema.nodes).map(([, n]) => n).filter((n) => (this.options.notAfter || []).concat(this.options.node).includes(n.name));
    return [
      new ue({
        key: t,
        appendTransaction: (n, r, o) => {
          const { doc: i, tr: s, schema: l } = o, a = t.getState(o), c = i.content.size, u = l.nodes[this.options.node];
          if (a)
            return s.insert(c, u.create());
        },
        state: {
          init: (n, r) => {
            const o = r.tr.doc.lastChild;
            return !Af({ node: o, types: e });
          },
          apply: (n, r) => {
            if (!n.docChanged)
              return r;
            const o = n.doc.lastChild;
            return !Af({ node: o, types: e });
          }
        }
      })
    ];
  }
}), u5 = Q.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => y1(t, e),
      redo: () => ({ state: t, dispatch: e }) => b1(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [i5(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), d5 = Q.create({
  name: "starterKit",
  addExtensions() {
    var t, e, n, r;
    const o = [];
    return this.options.bold !== !1 && o.push(U7.configure(this.options.bold)), this.options.blockquote !== !1 && o.push(F7.configure(this.options.blockquote)), this.options.bulletList !== !1 && o.push(n1.configure(this.options.bulletList)), this.options.code !== !1 && o.push(j7.configure(this.options.code)), this.options.codeBlock !== !1 && o.push(Z7.configure(this.options.codeBlock)), this.options.document !== !1 && o.push(J7.configure(this.options.document)), this.options.dropcursor !== !1 && o.push(s5.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && o.push(l5.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && o.push(Y7.configure(this.options.hardBreak)), this.options.heading !== !1 && o.push(X7.configure(this.options.heading)), this.options.undoRedo !== !1 && o.push(u5.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && o.push(jm.configure(this.options.horizontalRule)), this.options.italic !== !1 && o.push(o4.configure(this.options.italic)), this.options.listItem !== !1 && o.push(r1.configure(this.options.listItem)), this.options.listKeymap !== !1 && o.push(c1.configure((t = this.options) == null ? void 0 : t.listKeymap)), this.options.link !== !1 && o.push(A4.configure((e = this.options) == null ? void 0 : e.link)), this.options.orderedList !== !1 && o.push(u1.configure(this.options.orderedList)), this.options.paragraph !== !1 && o.push(H4.configure(this.options.paragraph)), this.options.strike !== !1 && o.push(z4.configure(this.options.strike)), this.options.text !== !1 && o.push(V4.configure(this.options.text)), this.options.underline !== !1 && o.push(h1.configure((n = this.options) == null ? void 0 : n.underline)), this.options.trailingNode !== !1 && o.push(c5.configure((r = this.options) == null ? void 0 : r.trailingNode)), o;
  }
}), f5 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, h5 = Ce.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", X(this.options.HTMLAttributes, t)];
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      zm({
        find: f5,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t;
          return { src: n, alt: e, title: r };
        }
      })
    ];
  }
}), p5 = Q.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).every((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).every((e) => e),
      toggleTextAlign: (t) => ({ editor: e, commands: n }) => this.options.alignments.includes(t) ? e.isActive({ textAlign: t }) ? n.unsetTextAlign() : n.setTextAlign(t) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), m5 = (t) => be({
  find: /--$/,
  replace: t ?? "—"
}), g5 = (t) => be({
  find: /\.\.\.$/,
  replace: t ?? "…"
}), y5 = (t) => be({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
  replace: t ?? "“"
}), b5 = (t) => be({
  find: /"$/,
  replace: t ?? "”"
}), C5 = (t) => be({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
  replace: t ?? "‘"
}), v5 = (t) => be({
  find: /'$/,
  replace: t ?? "’"
}), w5 = (t) => be({
  find: /<-$/,
  replace: t ?? "←"
}), S5 = (t) => be({
  find: /->$/,
  replace: t ?? "→"
}), x5 = (t) => be({
  find: /\(c\)$/,
  replace: t ?? "©"
}), k5 = (t) => be({
  find: /\(tm\)$/,
  replace: t ?? "™"
}), E5 = (t) => be({
  find: /\(sm\)$/,
  replace: t ?? "℠"
}), M5 = (t) => be({
  find: /\(r\)$/,
  replace: t ?? "®"
}), T5 = (t) => be({
  find: /(?:^|\s)(1\/2)\s$/,
  replace: t ?? "½"
}), R5 = (t) => be({
  find: /\+\/-$/,
  replace: t ?? "±"
}), A5 = (t) => be({
  find: /!=$/,
  replace: t ?? "≠"
}), O5 = (t) => be({
  find: /<<$/,
  replace: t ?? "«"
}), N5 = (t) => be({
  find: />>$/,
  replace: t ?? "»"
}), I5 = (t) => be({
  find: /\d+\s?([*x])\s?\d+$/,
  replace: t ?? "×"
}), L5 = (t) => be({
  find: /\^2$/,
  replace: t ?? "²"
}), D5 = (t) => be({
  find: /\^3$/,
  replace: t ?? "³"
}), P5 = (t) => be({
  find: /(?:^|\s)(1\/4)\s$/,
  replace: t ?? "¼"
}), B5 = (t) => be({
  find: /(?:^|\s)(3\/4)\s$/,
  replace: t ?? "¾"
}), H5 = Q.create({
  name: "typography",
  addOptions() {
    return {
      closeDoubleQuote: "”",
      closeSingleQuote: "’",
      copyright: "©",
      ellipsis: "…",
      emDash: "—",
      laquo: "«",
      leftArrow: "←",
      multiplication: "×",
      notEqual: "≠",
      oneHalf: "½",
      oneQuarter: "¼",
      openDoubleQuote: "“",
      openSingleQuote: "‘",
      plusMinus: "±",
      raquo: "»",
      registeredTrademark: "®",
      rightArrow: "→",
      servicemark: "℠",
      superscriptThree: "³",
      superscriptTwo: "²",
      threeQuarters: "¾",
      trademark: "™"
    };
  },
  addInputRules() {
    const t = [];
    return this.options.emDash !== !1 && t.push(m5(this.options.emDash)), this.options.ellipsis !== !1 && t.push(g5(this.options.ellipsis)), this.options.openDoubleQuote !== !1 && t.push(y5(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== !1 && t.push(b5(this.options.closeDoubleQuote)), this.options.openSingleQuote !== !1 && t.push(C5(this.options.openSingleQuote)), this.options.closeSingleQuote !== !1 && t.push(v5(this.options.closeSingleQuote)), this.options.leftArrow !== !1 && t.push(w5(this.options.leftArrow)), this.options.rightArrow !== !1 && t.push(S5(this.options.rightArrow)), this.options.copyright !== !1 && t.push(x5(this.options.copyright)), this.options.trademark !== !1 && t.push(k5(this.options.trademark)), this.options.servicemark !== !1 && t.push(E5(this.options.servicemark)), this.options.registeredTrademark !== !1 && t.push(M5(this.options.registeredTrademark)), this.options.oneHalf !== !1 && t.push(T5(this.options.oneHalf)), this.options.plusMinus !== !1 && t.push(R5(this.options.plusMinus)), this.options.notEqual !== !1 && t.push(A5(this.options.notEqual)), this.options.laquo !== !1 && t.push(O5(this.options.laquo)), this.options.raquo !== !1 && t.push(N5(this.options.raquo)), this.options.multiplication !== !1 && t.push(I5(this.options.multiplication)), this.options.superscriptTwo !== !1 && t.push(L5(this.options.superscriptTwo)), this.options.superscriptThree !== !1 && t.push(D5(this.options.superscriptThree)), this.options.oneQuarter !== !1 && t.push(P5(this.options.oneQuarter)), this.options.threeQuarters !== !1 && t.push(B5(this.options.threeQuarters)), t;
  }
}), F5 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, _5 = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, z5 = Ct.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Zn({
        find: F5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Rn({
        find: _5,
        type: this.type
      })
    ];
  }
}), V5 = Ct.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), $5 = Ct.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), Ia, La;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  Ia = (e) => t.get(e), La = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  Ia = (r) => {
    for (let o = 0; o < t.length; o += 2)
      if (t[o] == r) return t[o + 1];
  }, La = (r, o) => (n == 10 && (n = 0), t[n++] = r, t[n++] = o);
}
var ye = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t) continue;
      const r = e % this.width, o = e / this.width | 0;
      let i = r + 1, s = o + 1;
      for (let l = 1; i < this.width && this.map[e + l] == n; l++)
        i++;
      for (let l = 1; s < this.height && this.map[e + this.width * l] == n; l++)
        s++;
      return { left: r, top: o, right: i, bottom: s };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(t) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == t)
        return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(t, e, n) {
    const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[i * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i - 1 : s)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(t, e) {
    const {
      left: n,
      right: r,
      top: o,
      bottom: i
    } = this.findCell(t), {
      left: s,
      right: l,
      top: a,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(o, a),
      right: Math.max(r, l),
      bottom: Math.max(i, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++)
      for (let o = t.left; o < t.right; o++) {
        const i = r * this.width + o, s = this.map[i];
        n[s] || (n[s] = !0, !(o == t.left && o && this.map[i - 1] == s || r == t.top && r && this.map[i - this.width] == s) && e.push(s));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(t, e, n) {
    for (let r = 0, o = 0; ; r++) {
      const i = o + n.child(r).nodeSize;
      if (r == t) {
        let s = e + t * this.width;
        const l = (t + 1) * this.width;
        for (; s < l && this.map[s] < o; ) s++;
        return s == l ? i - 1 : this.map[s];
      }
      o = i;
    }
  }
  // Find the table map for the given table node.
  static get(t) {
    return Ia(t) || La(t, U5(t));
  }
};
function U5(t) {
  if (t.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + t.type.name);
  const e = W5(t), n = t.childCount, r = [];
  let o = 0, i = null;
  const s = [];
  for (let c = 0, u = e * n; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; o < r.length && r[o] != 0; ) o++;
      if (p == d.childCount) break;
      const m = d.child(p), { colspan: b, rowspan: C, colwidth: v } = m.attrs;
      for (let S = 0; S < C; S++) {
        if (S + c >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: C - S
          });
          break;
        }
        const w = o + S * e;
        for (let x = 0; x < b; x++) {
          r[w + x] == 0 ? r[w + x] = u : (i || (i = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: b - x
          });
          const k = v && v[x];
          if (k) {
            const E = (w + x) % e * 2, M = s[E];
            M == null || M != k && s[E + 1] == 1 ? (s[E] = k, s[E + 1] = 1) : M == k && s[E + 1]++;
          }
        }
      }
      o += b, u += m.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; o < f; ) r[o++] == 0 && h++;
    h && (i || (i = [])).push({ type: "missing", row: c, n: h }), u++;
  }
  (e === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
  const l = new ye(e, n, r, i);
  let a = !1;
  for (let c = 0; !a && c < s.length; c += 2)
    s[c] != null && s[c + 1] < n && (a = !0);
  return a && K5(l, s, t), l;
}
function W5(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const o = t.child(r);
    let i = 0;
    if (n)
      for (let s = 0; s < r; s++) {
        const l = t.child(s);
        for (let a = 0; a < l.childCount; a++) {
          const c = l.child(a);
          s + c.attrs.rowspan > r && (i += c.attrs.colspan);
        }
      }
    for (let s = 0; s < o.childCount; s++) {
      const l = o.child(s);
      i += l.attrs.colspan, l.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = i : e != i && (e = Math.max(e, i));
  }
  return e;
}
function K5(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let o = 0; o < t.map.length; o++) {
    const i = t.map[o];
    if (r[i]) continue;
    r[i] = !0;
    const s = n.nodeAt(i);
    if (!s)
      throw new RangeError(`No cell with offset ${i} found`);
    let l = null;
    const a = s.attrs;
    for (let c = 0; c < a.colspan; c++) {
      const u = (o + c) % t.width, d = e[u * 2];
      d != null && (!a.colwidth || a.colwidth[c] != d) && ((l || (l = j5(a)))[c] = d);
    }
    l && t.problems.unshift({
      type: "colwidth mismatch",
      pos: i,
      colwidth: l
    });
  }
}
function j5(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++) e.push(0);
  return e;
}
function Be(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], o = r.spec.tableRole;
      o && (e[o] = r);
    }
  }
  return e;
}
var pn = new pe("selectingCells");
function Or(t) {
  for (let e = t.depth - 1; e > 0; e--)
    if (t.node(e).type.spec.tableRole == "row")
      return t.node(0).resolve(t.before(e + 1));
  return null;
}
function q5(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return t.node(e);
  }
  return null;
}
function vt(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--)
    if (e.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function Bs(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const n = Or(e.$head) || G5(e.$head);
  if (n)
    return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function G5(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return t.doc.resolve(n - e.nodeSize);
  }
}
function Da(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function Z5(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Jc(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function C1(t, e, n) {
  const r = t.node(-1), o = ye.get(r), i = t.start(-1), s = o.nextCell(t.pos - i, e, n);
  return s == null ? null : t.node(0).resolve(i + s);
}
function Jn(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan - n };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
}
function v1(t, e, n = 1) {
  const r = { ...t, colspan: t.colspan + n };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function J5(t, e, n) {
  const r = Be(e.type.schema).header_cell;
  for (let o = 0; o < t.height; o++)
    if (e.nodeAt(t.map[n + o * t.width]).type != r)
      return !1;
  return !0;
}
var se = class Ut extends K {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, n = e) {
    const r = e.node(-1), o = ye.get(r), i = e.start(-1), s = o.rectBetween(
      e.pos - i,
      n.pos - i
    ), l = e.node(0), a = o.cellsInRect(s).filter((u) => u != n.pos - i);
    a.unshift(n.pos - i);
    const c = a.map((u) => {
      const d = r.nodeAt(u);
      if (!d)
        throw RangeError(`No cell with offset ${u} found`);
      const f = i + u + 1;
      return new hp(
        l.resolve(f),
        l.resolve(f + d.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), o = e.resolve(n.map(this.$headCell.pos));
    if (Da(r) && Da(o) && Jc(r, o)) {
      const i = this.$anchorCell.node(-1) != r.node(-1);
      return i && this.isRowSelection() ? Ut.rowSelection(r, o) : i && this.isColSelection() ? Ut.colSelection(r, o) : new Ut(r, o);
    }
    return V.between(r, o);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), n = ye.get(e), r = this.$anchorCell.start(-1), o = n.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), i = {}, s = [];
    for (let a = o.top; a < o.bottom; a++) {
      const c = [];
      for (let u = a * n.width + o.left, d = o.left; d < o.right; d++, u++) {
        const f = n.map[u];
        if (i[f]) continue;
        i[f] = !0;
        const h = n.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const m = o.left - h.left, b = h.right - o.right;
        if (m > 0 || b > 0) {
          let C = p.attrs;
          if (m > 0 && (C = Jn(C, 0, m)), b > 0 && (C = Jn(
            C,
            C.colspan - b,
            b
          )), h.left < o.left) {
            if (p = p.type.createAndFill(C), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(C)}`
              );
          } else
            p = p.type.create(C, p.content);
        }
        if (h.top < o.top || h.bottom > o.bottom) {
          const C = {
            ...p.attrs,
            rowspan: Math.min(h.bottom, o.bottom) - Math.max(h.top, o.top)
          };
          h.top < o.top ? p = p.type.createAndFill(C) : p = p.type.create(C, p.content);
        }
        c.push(p);
      }
      s.push(e.child(a).copy(A.from(c)));
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : s;
    return new B(A.from(l), 1, 1);
  }
  replace(e, n = B.empty) {
    const r = e.steps.length, o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      const { $from: l, $to: a } = o[s], c = e.mapping.slice(r);
      e.replace(
        c.map(l.pos),
        c.map(a.pos),
        s ? B.empty : n
      );
    }
    const i = K.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    i && e.setSelection(i);
  }
  replaceWith(e, n) {
    this.replace(e, new B(A.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = ye.get(n), o = this.$anchorCell.start(-1), i = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - o,
        this.$headCell.pos - o
      )
    );
    for (let s = 0; s < i.length; s++)
      e(n.nodeAt(i[s]), o + i[s]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, o) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, n = e) {
    const r = e.node(-1), o = ye.get(r), i = e.start(-1), s = o.findCell(e.pos - i), l = o.findCell(n.pos - i), a = e.node(0);
    return s.top <= l.top ? (s.top > 0 && (e = a.resolve(i + o.map[s.left])), l.bottom < o.height && (n = a.resolve(
      i + o.map[o.width * (o.height - 1) + l.right - 1]
    ))) : (l.top > 0 && (n = a.resolve(i + o.map[l.left])), s.bottom < o.height && (e = a.resolve(
      i + o.map[o.width * (o.height - 1) + s.right - 1]
    ))), new Ut(e, n);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = ye.get(e), r = this.$anchorCell.start(-1), o = n.colCount(this.$anchorCell.pos - r), i = n.colCount(this.$headCell.pos - r);
    if (Math.min(o, i) > 0) return !1;
    const s = o + this.$anchorCell.nodeAfter.attrs.colspan, l = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, l) == n.width;
  }
  eq(e) {
    return e instanceof Ut && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, n = e) {
    const r = e.node(-1), o = ye.get(r), i = e.start(-1), s = o.findCell(e.pos - i), l = o.findCell(n.pos - i), a = e.node(0);
    return s.left <= l.left ? (s.left > 0 && (e = a.resolve(
      i + o.map[s.top * o.width]
    )), l.right < o.width && (n = a.resolve(
      i + o.map[o.width * (l.top + 1) - 1]
    ))) : (l.left > 0 && (n = a.resolve(i + o.map[l.top * o.width])), s.right < o.width && (e = a.resolve(
      i + o.map[o.width * (s.top + 1) - 1]
    ))), new Ut(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new Ut(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new Ut(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new Y5(this.$anchorCell.pos, this.$headCell.pos);
  }
};
se.prototype.visible = !1;
K.jsonID("cell", se);
var Y5 = class w1 {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new w1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && Jc(n, r) ? new se(n, r) : K.near(r, 1);
  }
};
function X5(t) {
  if (!(t.selection instanceof se)) return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(
      Ee.node(r, r + n.nodeSize, { class: "selectedCell" })
    );
  }), ae.create(t.doc, e);
}
function Q5({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let n = t.pos, r = e.pos, o = t.depth;
  for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++)
    ;
  for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--)
    ;
  return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
}
function e3({ $from: t, $to: e }) {
  let n, r;
  for (let o = t.depth; o > 0; o--) {
    const i = t.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      n = i;
      break;
    }
  }
  for (let o = e.depth; o > 0; o--) {
    const i = e.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      r = i;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function t3(t, e, n) {
  const r = (e || t).selection, o = (e || t).doc;
  let i, s;
  if (r instanceof z && (s = r.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell")
      i = se.create(o, r.from);
    else if (s == "row") {
      const l = o.resolve(r.from + 1);
      i = se.rowSelection(l, l);
    } else if (!n) {
      const l = ye.get(r.node), a = r.from + 1, c = a + l.map[l.width * l.height - 1];
      i = se.create(o, a + 1, c);
    }
  } else r instanceof V && Q5(r) ? i = V.create(o, r.from) : r instanceof V && e3(r) && (i = V.create(o, r.$from.start(), r.$from.end()));
  return i && (e || (e = t.tr)).setSelection(i), e;
}
var n3 = new pe("fix-tables");
function S1(t, e, n, r) {
  const o = t.childCount, i = e.childCount;
  e: for (let s = 0, l = 0; s < i; s++) {
    const a = e.child(s);
    for (let c = l, u = Math.min(o, s + 3); c < u; c++)
      if (t.child(c) == a) {
        l = c + 1, n += a.nodeSize;
        continue e;
      }
    r(a, n), l < o && t.child(l).sameMarkup(a) ? S1(t.child(l), a, n + 1, r) : a.nodesBetween(0, a.content.size, r, n + 1), n += a.nodeSize;
  }
}
function x1(t, e) {
  let n;
  const r = (o, i) => {
    o.type.spec.tableRole == "table" && (n = r3(t, o, i, n));
  };
  return e ? e.doc != t.doc && S1(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function r3(t, e, n, r) {
  const o = ye.get(e);
  if (!o.problems) return r;
  r || (r = t.tr);
  const i = [];
  for (let a = 0; a < o.height; a++) i.push(0);
  for (let a = 0; a < o.problems.length; a++) {
    const c = o.problems[a];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++) i[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(n + 1 + c.pos),
        null,
        Jn(d, d.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      i[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(n);
      r.delete(u, u + e.nodeSize);
    }
  }
  let s, l;
  for (let a = 0; a < i.length; a++)
    i[a] && (s == null && (s = a), l = a);
  for (let a = 0, c = n + 1; a < o.height; a++) {
    const u = e.child(a), d = c + u.nodeSize, f = i[a];
    if (f > 0) {
      let h = "cell";
      u.firstChild && (h = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let b = 0; b < f; b++) {
        const C = Be(t.schema)[h].createAndFill();
        C && p.push(C);
      }
      const m = (a == 0 || s == a - 1) && l == a ? c + 1 : d - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = d;
  }
  return r.setMeta(n3, { fixTables: !0 });
}
function Pt(t) {
  const e = t.selection, n = Bs(t), r = n.node(-1), o = n.start(-1), i = ye.get(r);
  return { ...e instanceof se ? i.rectBetween(
    e.$anchorCell.pos - o,
    e.$headCell.pos - o
  ) : i.findCell(n.pos - o), tableStart: o, map: i, table: r };
}
function k1(t, { map: e, tableStart: n, table: r }, o) {
  let i = o > 0 ? -1 : 0;
  J5(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const l = s * e.width + o;
    if (o > 0 && o < e.width && e.map[l - 1] == e.map[l]) {
      const a = e.map[l], c = r.nodeAt(a);
      t.setNodeMarkup(
        t.mapping.map(n + a),
        null,
        v1(c.attrs, o - e.colCount(a))
      ), s += c.attrs.rowspan - 1;
    } else {
      const a = i == null ? Be(r.type.schema).cell : r.nodeAt(e.map[l + i]).type, c = e.positionAt(s, o, r);
      t.insert(t.mapping.map(n + c), a.createAndFill());
    }
  }
  return t;
}
function o3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t);
    e(k1(t.tr, n, n.left));
  }
  return !0;
}
function i3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t);
    e(k1(t.tr, n, n.right));
  }
  return !0;
}
function s3(t, { map: e, table: n, tableStart: r }, o) {
  const i = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const l = s * e.width + o, a = e.map[l], c = n.nodeAt(a), u = c.attrs;
    if (o > 0 && e.map[l - 1] == a || o < e.width - 1 && e.map[l + 1] == a)
      t.setNodeMarkup(
        t.mapping.slice(i).map(r + a),
        null,
        Jn(u, o - e.colCount(a))
      );
    else {
      const d = t.mapping.slice(i).map(r + a);
      t.delete(d, d + c.nodeSize);
    }
    s += u.rowspan;
  }
}
function l3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let o = n.right - 1; s3(r, n, o), o != n.left; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = ye.get(i);
    }
    e(r);
  }
  return !0;
}
function a3(t, e, n) {
  var r;
  const o = Be(e.type.schema).header_cell;
  for (let i = 0; i < t.width; i++)
    if (((r = e.nodeAt(t.map[i + n * t.width])) == null ? void 0 : r.type) != o)
      return !1;
  return !0;
}
function E1(t, { map: e, tableStart: n, table: r }, o) {
  var i;
  let s = n;
  for (let c = 0; c < o; c++) s += r.child(c).nodeSize;
  const l = [];
  let a = o > 0 ? -1 : 0;
  a3(e, r, o + a) && (a = o == 0 || o == e.height ? null : 0);
  for (let c = 0, u = e.width * o; c < e.width; c++, u++)
    if (o > 0 && o < e.height && e.map[u] == e.map[u - e.width]) {
      const d = e.map[u], f = r.nodeAt(d).attrs;
      t.setNodeMarkup(n + d, null, {
        ...f,
        rowspan: f.rowspan + 1
      }), c += f.colspan - 1;
    } else {
      const d = a == null ? Be(r.type.schema).cell : (i = r.nodeAt(e.map[u + a * e.width])) == null ? void 0 : i.type, f = d?.createAndFill();
      f && l.push(f);
    }
  return t.insert(s, Be(r.type.schema).row.create(null, l)), t;
}
function c3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t);
    e(E1(t.tr, n, n.top));
  }
  return !0;
}
function u3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t);
    e(E1(t.tr, n, n.bottom));
  }
  return !0;
}
function d3(t, { map: e, table: n, tableStart: r }, o) {
  let i = 0;
  for (let c = 0; c < o; c++) i += n.child(c).nodeSize;
  const s = i + n.child(o).nodeSize, l = t.mapping.maps.length;
  t.delete(i + r, s + r);
  const a = /* @__PURE__ */ new Set();
  for (let c = 0, u = o * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!a.has(d)) {
      if (a.add(d), o > 0 && d == e.map[u - e.width]) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(l).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (o < e.height && d == e.map[u + e.width]) {
        const f = n.nodeAt(d), h = f.attrs, p = f.type.create(
          { ...h, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(o + 1, c, n);
        t.insert(t.mapping.slice(l).map(r + m), p), c += h.colspan - 1;
      }
    }
  }
}
function f3(t, e) {
  if (!vt(t)) return !1;
  if (e) {
    const n = Pt(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let o = n.bottom - 1; d3(r, n, o), o != n.top; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i)
        throw RangeError("No table found");
      n.table = i, n.map = ye.get(n.table);
    }
    e(r);
  }
  return !0;
}
function Of(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function h3({ width: t, height: e, map: n }, r) {
  let o = r.top * t + r.left, i = o, s = (r.bottom - 1) * t + r.left, l = o + (r.right - r.left - 1);
  for (let a = r.top; a < r.bottom; a++) {
    if (r.left > 0 && n[i] == n[i - 1] || r.right < t && n[l] == n[l + 1])
      return !0;
    i += t, l += t;
  }
  for (let a = r.left; a < r.right; a++) {
    if (r.top > 0 && n[o] == n[o - t] || r.bottom < e && n[s] == n[s + t])
      return !0;
    o++, s++;
  }
  return !1;
}
function Nf(t, e) {
  const n = t.selection;
  if (!(n instanceof se) || n.$anchorCell.pos == n.$headCell.pos)
    return !1;
  const r = Pt(t), { map: o } = r;
  if (h3(o, r)) return !1;
  if (e) {
    const i = t.tr, s = {};
    let l = A.empty, a, c;
    for (let u = r.top; u < r.bottom; u++)
      for (let d = r.left; d < r.right; d++) {
        const f = o.map[u * o.width + d], h = r.table.nodeAt(f);
        if (!(s[f] || !h))
          if (s[f] = !0, a == null)
            a = f, c = h;
          else {
            Of(h) || (l = l.append(h.content));
            const p = i.mapping.map(f + r.tableStart);
            i.delete(p, p + h.nodeSize);
          }
      }
    if (a == null || c == null)
      return !0;
    if (i.setNodeMarkup(a + r.tableStart, null, {
      ...v1(
        c.attrs,
        c.attrs.colspan,
        r.right - r.left - c.attrs.colspan
      ),
      rowspan: r.bottom - r.top
    }), l.size) {
      const u = a + 1 + c.content.size, d = Of(c) ? a + 1 : u;
      i.replaceWith(d + r.tableStart, u + r.tableStart, l);
    }
    i.setSelection(
      new se(i.doc.resolve(a + r.tableStart))
    ), e(i);
  }
  return !0;
}
function If(t, e) {
  const n = Be(t.schema);
  return p3(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function p3(t) {
  return (e, n) => {
    var r;
    const o = e.selection;
    let i, s;
    if (o instanceof se) {
      if (o.$anchorCell.pos != o.$headCell.pos) return !1;
      i = o.$anchorCell.nodeAfter, s = o.$anchorCell.pos;
    } else {
      if (i = q5(o.$from), !i) return !1;
      s = (r = Or(o.$from)) == null ? void 0 : r.pos;
    }
    if (i == null || s == null || i.attrs.colspan == 1 && i.attrs.rowspan == 1)
      return !1;
    if (n) {
      let l = i.attrs;
      const a = [], c = l.colwidth;
      l.rowspan > 1 && (l = { ...l, rowspan: 1 }), l.colspan > 1 && (l = { ...l, colspan: 1 });
      const u = Pt(e), d = e.tr;
      for (let h = 0; h < u.right - u.left; h++)
        a.push(
          c ? {
            ...l,
            colwidth: c && c[h] ? [c[h]] : null
          } : l
        );
      let f;
      for (let h = u.top; h < u.bottom; h++) {
        let p = u.map.positionAt(h, u.left, u.table);
        h == u.top && (p += i.nodeSize);
        for (let m = u.left, b = 0; m < u.right; m++, b++)
          m == u.left && h == u.top || d.insert(
            f = d.mapping.map(p + u.tableStart, 1),
            t({ node: i, row: h, col: m }).createAndFill(a[b])
          );
      }
      d.setNodeMarkup(
        s,
        t({ node: i, row: u.top, col: u.left }),
        a[0]
      ), o instanceof se && d.setSelection(
        new se(
          d.doc.resolve(o.$anchorCell.pos),
          f ? d.doc.resolve(f) : void 0
        )
      ), n(d);
    }
    return !0;
  };
}
function m3(t, e) {
  return function(n, r) {
    if (!vt(n)) return !1;
    const o = Bs(n);
    if (o.nodeAfter.attrs[t] === e) return !1;
    if (r) {
      const i = n.tr;
      n.selection instanceof se ? n.selection.forEachCell((s, l) => {
        s.attrs[t] !== e && i.setNodeMarkup(l, null, {
          ...s.attrs,
          [t]: e
        });
      }) : i.setNodeMarkup(o.pos, null, {
        ...o.nodeAfter.attrs,
        [t]: e
      }), r(i);
    }
    return !0;
  };
}
function g3(t) {
  return function(e, n) {
    if (!vt(e)) return !1;
    if (n) {
      const r = Be(e.schema), o = Pt(e), i = e.tr, s = o.map.cellsInRect(
        t == "column" ? {
          left: o.left,
          top: 0,
          right: o.right,
          bottom: o.map.height
        } : t == "row" ? {
          left: 0,
          top: o.top,
          right: o.map.width,
          bottom: o.bottom
        } : o
      ), l = s.map((a) => o.table.nodeAt(a));
      for (let a = 0; a < s.length; a++)
        l[a].type == r.header_cell && i.setNodeMarkup(
          o.tableStart + s[a],
          r.cell,
          l[a].attrs
        );
      if (i.steps.length == 0)
        for (let a = 0; a < s.length; a++)
          i.setNodeMarkup(
            o.tableStart + s[a],
            r.header_cell,
            l[a].attrs
          );
      n(i);
    }
    return !0;
  };
}
function Lf(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let o = 0; o < r.length; o++) {
    const i = e.table.nodeAt(r[o]);
    if (i && i.type !== n.header_cell)
      return !1;
  }
  return !0;
}
function fo(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? g3(t) : function(n, r) {
    if (!vt(n)) return !1;
    if (r) {
      const o = Be(n.schema), i = Pt(n), s = n.tr, l = Lf("row", i, o), a = Lf(
        "column",
        i,
        o
      ), u = (t === "column" ? l : t === "row" ? a : !1) ? 1 : 0, d = t == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: i.map.height
      } : t == "row" ? {
        left: u,
        top: 0,
        right: i.map.width,
        bottom: 1
      } : i, f = t == "column" ? a ? o.cell : o.header_cell : t == "row" ? l ? o.cell : o.header_cell : o.cell;
      i.map.cellsInRect(d).forEach((h) => {
        const p = h + i.tableStart, m = s.doc.nodeAt(p);
        m && s.setNodeMarkup(p, f, m.attrs);
      }), r(s);
    }
    return !0;
  };
}
fo("row", {
  useDeprecatedLogic: !0
});
fo("column", {
  useDeprecatedLogic: !0
});
var y3 = fo("cell", {
  useDeprecatedLogic: !0
});
function b3(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n) return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
      const i = t.node(-1).child(r), s = i.lastChild;
      if (s)
        return o - 1 - s.nodeSize;
      o -= i.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1)
      return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
      const i = n.child(r);
      if (i.childCount) return o + 1;
      o += i.nodeSize;
    }
  }
  return null;
}
function Df(t) {
  return function(e, n) {
    if (!vt(e)) return !1;
    const r = b3(Bs(e), t);
    if (r == null) return !1;
    if (n) {
      const o = e.doc.resolve(r);
      n(
        e.tr.setSelection(V.between(o, Z5(o))).scrollIntoView()
      );
    }
    return !0;
  };
}
function C3(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--)
    if (n.node(r).type.spec.tableRole == "table")
      return e && e(
        t.tr.delete(n.before(r), n.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function qo(t, e) {
  const n = t.selection;
  if (!(n instanceof se)) return !1;
  if (e) {
    const r = t.tr, o = Be(t.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(o) || r.replace(
        r.mapping.map(s + 1),
        r.mapping.map(s + i.nodeSize - 1),
        new B(o, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function v3(t) {
  if (!t.size) return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const o = e.child(0), i = o.type.spec.tableRole, s = o.type.schema, l = [];
  if (i == "row")
    for (let a = 0; a < e.childCount; a++) {
      let c = e.child(a).content;
      const u = a ? 0 : Math.max(0, n - 1), d = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || d) && (c = Pa(
        Be(s).row,
        new B(c, u, d)
      ).content), l.push(c);
    }
  else if (i == "cell" || i == "header_cell")
    l.push(
      n || r ? Pa(
        Be(s).row,
        new B(e, n, r)
      ).content : e
    );
  else
    return null;
  return w3(s, l);
}
function w3(t, e) {
  const n = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: l, colspan: a } = i.child(s).attrs;
      for (let c = o; c < o + l; c++)
        n[c] = (n[c] || 0) + a;
    }
  }
  let r = 0;
  for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
  for (let o = 0; o < n.length; o++)
    if (o >= e.length && e.push(A.empty), n[o] < r) {
      const i = Be(t).cell.createAndFill(), s = [];
      for (let l = n[o]; l < r; l++)
        s.push(i);
      e[o] = e[o].append(A.from(s));
    }
  return { height: e.length, width: r, rows: e };
}
function Pa(t, e) {
  const n = t.createAndFill();
  return new dc(n).replace(0, n.content.size, e).doc;
}
function S3({ width: t, height: e, rows: n }, r, o) {
  if (t != r) {
    const i = [], s = [];
    for (let l = 0; l < n.length; l++) {
      const a = n[l], c = [];
      for (let u = i[l] || 0, d = 0; u < r; d++) {
        let f = a.child(d % a.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          Jn(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++)
          i[l + h] = (i[l + h] || 0) + f.attrs.colspan;
      }
      s.push(A.from(c));
    }
    n = s, t = r;
  }
  if (e != o) {
    const i = [];
    for (let s = 0, l = 0; s < o; s++, l++) {
      const a = [], c = n[l % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        s + d.attrs.rowspan > o && (d = d.type.create(
          {
            ...d.attrs,
            rowspan: Math.max(1, o - d.attrs.rowspan)
          },
          d.content
        )), a.push(d);
      }
      i.push(A.from(a));
    }
    n = i, e = o;
  }
  return { width: t, height: e, rows: n };
}
function x3(t, e, n, r, o, i, s) {
  const l = t.doc.type.schema, a = Be(l);
  let c, u;
  if (o > e.width)
    for (let d = 0, f = 0; d < e.height; d++) {
      const h = n.child(d);
      f += h.nodeSize;
      const p = [];
      let m;
      h.lastChild == null || h.lastChild.type == a.cell ? m = c || (c = a.cell.createAndFill()) : m = u || (u = a.header_cell.createAndFill());
      for (let b = e.width; b < o; b++) p.push(m);
      t.insert(t.mapping.slice(s).map(f - 1 + r), p);
    }
  if (i > e.height) {
    const d = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, o); p++) {
      const b = p >= e.width ? !1 : n.nodeAt(e.map[m + p]).type == a.header_cell;
      d.push(
        b ? u || (u = a.header_cell.createAndFill()) : c || (c = a.cell.createAndFill())
      );
    }
    const f = a.row.create(null, A.from(d)), h = [];
    for (let p = e.height; p < i; p++) h.push(f);
    t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), h);
  }
  return !!(c || u);
}
function Pf(t, e, n, r, o, i, s, l) {
  if (s == 0 || s == e.height) return !1;
  let a = !1;
  for (let c = o; c < i; c++) {
    const u = s * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      a = !0;
      const f = n.nodeAt(d), { top: h, left: p } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(l).map(d + r), null, {
        ...f.attrs,
        rowspan: s - h
      }), t.insert(
        t.mapping.slice(l).map(e.positionAt(s, p, n)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: h + f.attrs.rowspan - s
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return a;
}
function Bf(t, e, n, r, o, i, s, l) {
  if (s == 0 || s == e.width) return !1;
  let a = !1;
  for (let c = o; c < i; c++) {
    const u = c * e.width + s, d = e.map[u];
    if (e.map[u - 1] == d) {
      a = !0;
      const f = n.nodeAt(d), h = e.colCount(d), p = t.mapping.slice(l).map(d + r);
      t.setNodeMarkup(
        p,
        null,
        Jn(
          f.attrs,
          s - h,
          f.attrs.colspan - (s - h)
        )
      ), t.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          Jn(f.attrs, 0, s - h)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return a;
}
function Hf(t, e, n, r, o) {
  let i = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!i)
    throw new Error("No table found");
  let s = ye.get(i);
  const { top: l, left: a } = r, c = a + o.width, u = l + o.height, d = t.tr;
  let f = 0;
  function h() {
    if (i = n ? d.doc.nodeAt(n - 1) : d.doc, !i)
      throw new Error("No table found");
    s = ye.get(i), f = d.mapping.maps.length;
  }
  x3(d, s, i, n, c, u, f) && h(), Pf(d, s, i, n, a, c, l, f) && h(), Pf(d, s, i, n, a, c, u, f) && h(), Bf(d, s, i, n, l, u, a, f) && h(), Bf(d, s, i, n, l, u, c, f) && h();
  for (let p = l; p < u; p++) {
    const m = s.positionAt(p, a, i), b = s.positionAt(p, c, i);
    d.replace(
      d.mapping.slice(f).map(m + n),
      d.mapping.slice(f).map(b + n),
      new B(o.rows[p - l], 0, 0)
    );
  }
  h(), d.setSelection(
    new se(
      d.doc.resolve(n + s.positionAt(l, a, i)),
      d.doc.resolve(n + s.positionAt(u - 1, c - 1, i))
    )
  ), e(d);
}
var k3 = Sc({
  ArrowLeft: Go("horiz", -1),
  ArrowRight: Go("horiz", 1),
  ArrowUp: Go("vert", -1),
  ArrowDown: Go("vert", 1),
  "Shift-ArrowLeft": Zo("horiz", -1),
  "Shift-ArrowRight": Zo("horiz", 1),
  "Shift-ArrowUp": Zo("vert", -1),
  "Shift-ArrowDown": Zo("vert", 1),
  Backspace: qo,
  "Mod-Backspace": qo,
  Delete: qo,
  "Mod-Delete": qo
});
function ui(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Go(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    if (i instanceof se)
      return ui(
        n,
        r,
        K.near(i.$headCell, e)
      );
    if (t != "horiz" && !i.empty) return !1;
    const s = M1(o, t, e);
    if (s == null) return !1;
    if (t == "horiz")
      return ui(
        n,
        r,
        K.near(n.doc.resolve(i.head + e), e)
      );
    {
      const l = n.doc.resolve(s), a = C1(l, t, e);
      let c;
      return a ? c = K.near(a, 1) : e < 0 ? c = K.near(n.doc.resolve(l.before(-1)), -1) : c = K.near(n.doc.resolve(l.after(-1)), 1), ui(n, r, c);
    }
  };
}
function Zo(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    let s;
    if (i instanceof se)
      s = i;
    else {
      const a = M1(o, t, e);
      if (a == null) return !1;
      s = new se(n.doc.resolve(a));
    }
    const l = C1(s.$headCell, t, e);
    return l ? ui(
      n,
      r,
      new se(s.$anchorCell, l)
    ) : !1;
  };
}
function E3(t, e) {
  const n = t.state.doc, r = Or(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new se(r))), !0) : !1;
}
function M3(t, e, n) {
  if (!vt(t.state)) return !1;
  let r = v3(n);
  const o = t.state.selection;
  if (o instanceof se) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        A.from(
          Pa(Be(t.state.schema).cell, n)
        )
      ]
    });
    const i = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), l = ye.get(i).rectBetween(
      o.$anchorCell.pos - s,
      o.$headCell.pos - s
    );
    return r = S3(r, l.right - l.left, l.bottom - l.top), Hf(t.state, t.dispatch, s, l, r), !0;
  } else if (r) {
    const i = Bs(t.state), s = i.start(-1);
    return Hf(
      t.state,
      t.dispatch,
      s,
      ye.get(i.node(-1)).findCell(i.pos - s),
      r
    ), !0;
  } else
    return !1;
}
function T3(t, e) {
  var n;
  if (e.ctrlKey || e.metaKey) return;
  const r = Ff(t, e.target);
  let o;
  if (e.shiftKey && t.state.selection instanceof se)
    i(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (o = Or(t.state.selection.$anchor)) != null && ((n = Bl(t, e)) == null ? void 0 : n.pos) != o.pos)
    i(o, e), e.preventDefault();
  else if (!r)
    return;
  function i(a, c) {
    let u = Bl(t, c);
    const d = pn.getState(t.state) == null;
    if (!u || !Jc(a, u))
      if (d) u = a;
      else return;
    const f = new se(a, u);
    if (d || !t.state.selection.eq(f)) {
      const h = t.state.tr.setSelection(f);
      d && h.setMeta(pn, a.pos), t.dispatch(h);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", l), pn.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(pn, -1));
  }
  function l(a) {
    const c = a, u = pn.getState(t.state);
    let d;
    if (u != null)
      d = t.state.doc.resolve(u);
    else if (Ff(t, c.target) != r && (d = Bl(t, e), !d))
      return s();
    d && i(d, c);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", l);
}
function M1(t, e, n) {
  if (!(t.state.selection instanceof V)) return null;
  const { $head: r } = t.state.selection;
  for (let o = r.depth - 1; o >= 0; o--) {
    const i = r.node(o);
    if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)) return null;
    if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
      const l = r.before(o), a = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(a) ? l : null;
    }
  }
  return null;
}
function Ff(t, e) {
  for (; e && e != t.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function Bl(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return n && n ? Or(t.state.doc.resolve(n.pos)) : null;
}
var R3 = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${n}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), Ba(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, Ba(
      e,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function Ba(t, e, n, r, o, i) {
  var s;
  let l = 0, a = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u) {
    for (let d = 0, f = 0; d < u.childCount; d++) {
      const { colspan: h, colwidth: p } = u.child(d).attrs;
      for (let m = 0; m < h; m++, f++) {
        const b = o == f ? i : p && p[m], C = b ? b + "px" : "";
        if (l += b || r, b || (a = !1), c)
          c.style.width != C && (c.style.width = C), c = c.nextSibling;
        else {
          const v = document.createElement("col");
          v.style.width = C, e.appendChild(v);
        }
      }
    }
    for (; c; ) {
      const d = c.nextSibling;
      (s = c.parentNode) == null || s.removeChild(c), c = d;
    }
    a ? (n.style.width = l + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = l + "px");
  }
}
var qe = new pe(
  "tableColumnResizing"
);
function A3({
  handleWidth: t = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: n = 100,
  View: r = R3,
  lastColumnResizable: o = !0
} = {}) {
  const i = new ue({
    key: qe,
    state: {
      init(s, l) {
        var a, c;
        const u = (c = (a = i.spec) == null ? void 0 : a.props) == null ? void 0 : c.nodeViews, d = Be(l.schema).table.name;
        return r && u && (u[d] = (f, h) => new r(f, n, h)), new O3(-1, !1);
      },
      apply(s, l) {
        return l.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const l = qe.getState(s);
        return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, l) => {
          N3(s, l, t, o);
        },
        mouseleave: (s) => {
          I3(s);
        },
        mousedown: (s, l) => {
          L3(s, l, e, n);
        }
      },
      decorations: (s) => {
        const l = qe.getState(s);
        if (l && l.activeHandle > -1)
          return F3(s, l.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var O3 = class di {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(qe);
    if (r && r.setHandle != null)
      return new di(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new di(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let o = e.mapping.map(n.activeHandle, -1);
      return Da(e.doc.resolve(o)) || (o = -1), new di(o, n.dragging);
    }
    return n;
  }
};
function N3(t, e, n, r) {
  if (!t.editable) return;
  const o = qe.getState(t.state);
  if (o && !o.dragging) {
    const i = P3(e.target);
    let s = -1;
    if (i) {
      const { left: l, right: a } = i.getBoundingClientRect();
      e.clientX - l <= n ? s = _f(t, e, "left", n) : a - e.clientX <= n && (s = _f(t, e, "right", n));
    }
    if (s != o.activeHandle) {
      if (!r && s !== -1) {
        const l = t.state.doc.resolve(s), a = l.node(-1), c = ye.get(a), u = l.start(-1);
        if (c.colCount(l.pos - u) + l.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      T1(t, s);
    }
  }
}
function I3(t) {
  if (!t.editable) return;
  const e = qe.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && T1(t, -1);
}
function L3(t, e, n, r) {
  var o;
  if (!t.editable) return !1;
  const i = (o = t.dom.ownerDocument.defaultView) != null ? o : window, s = qe.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging)
    return !1;
  const l = t.state.doc.nodeAt(s.activeHandle), a = D3(t, s.activeHandle, l.attrs);
  t.dispatch(
    t.state.tr.setMeta(qe, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function c(d) {
    i.removeEventListener("mouseup", c), i.removeEventListener("mousemove", u);
    const f = qe.getState(t.state);
    f?.dragging && (B3(
      t,
      f.activeHandle,
      zf(f.dragging, d, n)
    ), t.dispatch(
      t.state.tr.setMeta(qe, { setDragging: null })
    ));
  }
  function u(d) {
    if (!d.which) return c(d);
    const f = qe.getState(t.state);
    if (f && f.dragging) {
      const h = zf(f.dragging, d, n);
      Vf(
        t,
        f.activeHandle,
        h,
        r
      );
    }
  }
  return Vf(
    t,
    s.activeHandle,
    a,
    r
  ), i.addEventListener("mouseup", c), i.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function D3(t, e, { colspan: n, colwidth: r }) {
  const o = r && r[r.length - 1];
  if (o) return o;
  const i = t.domAtPos(e);
  let l = i.node.childNodes[i.offset].offsetWidth, a = n;
  if (r)
    for (let c = 0; c < n; c++)
      r[c] && (l -= r[c], a--);
  return l / a;
}
function P3(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
    t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function _f(t, e, n, r) {
  const o = n == "right" ? -r : r, i = t.posAtCoords({
    left: e.clientX + o,
    top: e.clientY
  });
  if (!i) return -1;
  const { pos: s } = i, l = Or(t.state.doc.resolve(s));
  if (!l) return -1;
  if (n == "right") return l.pos;
  const a = ye.get(l.node(-1)), c = l.start(-1), u = a.map.indexOf(l.pos - c);
  return u % a.width == 0 ? -1 : c + a.map[u - 1];
}
function zf(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function T1(t, e) {
  t.dispatch(
    t.state.tr.setMeta(qe, { setHandle: e })
  );
}
function B3(t, e, n) {
  const r = t.state.doc.resolve(e), o = r.node(-1), i = ye.get(o), s = r.start(-1), l = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, a = t.state.tr;
  for (let c = 0; c < i.height; c++) {
    const u = c * i.width + l;
    if (c && i.map[u] == i.map[u - i.width]) continue;
    const d = i.map[u], f = o.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : l - i.colCount(d);
    if (f.colwidth && f.colwidth[h] == n) continue;
    const p = f.colwidth ? f.colwidth.slice() : H3(f.colspan);
    p[h] = n, a.setNodeMarkup(s + d, null, { ...f, colwidth: p });
  }
  a.docChanged && t.dispatch(a);
}
function Vf(t, e, n, r) {
  const o = t.state.doc.resolve(e), i = o.node(-1), s = o.start(-1), l = ye.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
  let a = t.domAtPos(o.start(-1)).node;
  for (; a && a.nodeName != "TABLE"; )
    a = a.parentNode;
  a && Ba(
    i,
    a.firstChild,
    a,
    r,
    l,
    n
  );
}
function H3(t) {
  return Array(t).fill(0);
}
function F3(t, e) {
  var n;
  const r = [], o = t.doc.resolve(e), i = o.node(-1);
  if (!i)
    return ae.empty;
  const s = ye.get(i), l = o.start(-1), a = s.colCount(o.pos - l) + o.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < s.height; c++) {
    const u = a + c * s.width;
    if ((a == s.width - 1 || s.map[u] != s.map[u + 1]) && (c == 0 || s.map[u] != s.map[u - s.width])) {
      const d = s.map[u], f = l + d + i.nodeAt(d).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", (n = qe.getState(t)) != null && n.dragging && r.push(
        Ee.node(
          l + d,
          l + d + i.nodeAt(d).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(Ee.widget(f, h));
    }
  }
  return ae.create(t.doc, r);
}
function _3({
  allowTableNodeSelection: t = !1
} = {}) {
  return new ue({
    key: pn,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(pn);
        if (r != null) return r == -1 ? null : r;
        if (n == null || !e.docChanged) return n;
        const { deleted: o, pos: i } = e.mapping.mapResult(n);
        return o ? null : i;
      }
    },
    props: {
      decorations: X5,
      handleDOMEvents: {
        mousedown: T3
      },
      createSelectionBetween(e) {
        return pn.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: E3,
      handleKeyDown: k3,
      handlePaste: M3
    },
    appendTransaction(e, n, r) {
      return t3(
        r,
        x1(r, n),
        t
      );
    }
  });
}
var R1 = Ce.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", X(this.options.HTMLAttributes, t), 0];
  }
}), A1 = Ce.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", X(this.options.HTMLAttributes, t), 0];
  }
}), O1 = Ce.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", X(this.options.HTMLAttributes, t), 0];
  }
});
function Ha(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function $f(t, e, n, r, o, i) {
  var s;
  let l = 0, a = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u !== null)
    for (let d = 0, f = 0; d < u.childCount; d += 1) {
      const { colspan: h, colwidth: p } = u.child(d).attrs;
      for (let m = 0; m < h; m += 1, f += 1) {
        const b = o === f ? i : p && p[m], C = b ? `${b}px` : "";
        if (l += b || r, b || (a = !1), c) {
          if (c.style.width !== C) {
            const [v, S] = Ha(r, b);
            c.style.setProperty(v, S);
          }
          c = c.nextSibling;
        } else {
          const v = document.createElement("col"), [S, w] = Ha(r, b);
          v.style.setProperty(S, w), e.appendChild(v);
        }
      }
    }
  for (; c; ) {
    const d = c.nextSibling;
    (s = c.parentNode) == null || s.removeChild(c), c = d;
  }
  a ? (n.style.width = `${l}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${l}px`);
}
var z3 = class {
  constructor(t, e) {
    this.node = t, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), $f(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(t) {
    return t.type !== this.node.type ? !1 : (this.node = t, $f(t, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(t) {
    return t.type === "attributes" && (t.target === this.table || this.colgroup.contains(t.target));
  }
};
function V3(t, e, n, r) {
  let o = 0, i = !0;
  const s = [], l = t.firstChild;
  if (!l)
    return {};
  for (let d = 0, f = 0; d < l.childCount; d += 1) {
    const { colspan: h, colwidth: p } = l.child(d).attrs;
    for (let m = 0; m < h; m += 1, f += 1) {
      const b = n === f ? r : p && p[m];
      o += b || e, b || (i = !1);
      const [C, v] = Ha(e, b);
      s.push(["col", { style: `${C}: ${v}` }]);
    }
  }
  const a = i ? `${o}px` : "", c = i ? "" : `${o}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: a, tableMinWidth: c };
}
function Uf(t, e) {
  return t.createAndFill();
}
function $3(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const r = t.nodes[n];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), t.cached.tableNodeTypes = e, e;
}
function U3(t, e, n, r, o) {
  const i = $3(t), s = [], l = [];
  for (let c = 0; c < n; c += 1) {
    const u = Uf(i.cell);
    if (u && l.push(u), r) {
      const d = Uf(i.header_cell);
      d && s.push(d);
    }
  }
  const a = [];
  for (let c = 0; c < e; c += 1)
    a.push(i.row.createChecked(null, r && c === 0 ? s : l));
  return i.table.createChecked(null, a);
}
function W3(t) {
  return t instanceof se;
}
var Jo = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!W3(e))
    return !1;
  let n = 0;
  const r = dm(e.ranges[0].$from, (i) => i.type.name === "table");
  return r?.node.descendants((i) => {
    if (i.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, N1 = Ce.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: z3,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: r, tableMinWidth: o } = V3(t, this.options.cellMinWidth);
    return [
      "table",
      X(this.options.HTMLAttributes, e, {
        style: r ? `width: ${r}` : `min-width: ${o}`
      }),
      n,
      ["tbody", 0]
    ];
  },
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: o, editor: i }) => {
        const s = U3(i.schema, t, e, n);
        if (o) {
          const l = r.selection.from + 1;
          r.replaceSelectionWith(s).scrollIntoView().setSelection(V.near(r.doc.resolve(l)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => o3(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => i3(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => l3(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => c3(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => u3(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => f3(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => C3(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => Nf(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => If(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => fo("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => fo("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => y3(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => Nf(t, e) ? !0 : If(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => m3(t, e)(n, r),
      goToNextCell: () => ({ state: t, dispatch: e }) => Df(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => Df(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && x1(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const r = se.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: Jo,
      "Mod-Backspace": Jo,
      Delete: Jo,
      "Mod-Delete": Jo
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        A3({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      _3({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: ee(U(t, "tableRole", e))
    };
  }
});
Q.create({
  name: "tableKit",
  addExtensions() {
    const t = [];
    return this.options.table !== !1 && t.push(N1.configure(this.options.table)), this.options.tableCell !== !1 && t.push(R1.configure(this.options.tableCell)), this.options.tableHeader !== !1 && t.push(A1.configure(this.options.tableHeader)), this.options.tableRow !== !1 && t.push(O1.configure(this.options.tableRow)), t;
  }
});
var K3 = (t) => {
  if (!t.children.length)
    return;
  const e = t.querySelectorAll("span");
  e && e.forEach((n) => {
    var r, o;
    const i = n.getAttribute("style"), s = (o = (r = n.parentElement) == null ? void 0 : r.closest("span")) == null ? void 0 : o.getAttribute("style");
    n.setAttribute("style", `${s};${i}`);
  });
}, I1 = Ct.create({
  name: "textStyle",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      mergeNestedSpanStyles: !0
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        consuming: !1,
        getAttrs: (t) => t.hasAttribute("style") ? (this.options.mergeNestedSpanStyles && K3(t), {}) : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["span", X(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      toggleTextStyle: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      removeEmptyTextStyle: () => ({ tr: t }) => {
        const { selection: e } = t;
        return t.doc.nodesBetween(e.from, e.to, (n, r) => {
          if (n.isTextblock)
            return !0;
          n.marks.filter((o) => o.type === this.type).some((o) => Object.values(o.attrs).some((i) => !!i)) || t.removeMark(r, r + n.nodeSize, this.type);
        }), !0;
      }
    };
  }
}), j3 = Q.create({
  name: "backgroundColor",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          backgroundColor: {
            default: null,
            parseHTML: (t) => {
              var e;
              const n = t.getAttribute("style");
              if (n) {
                const r = n.split(";").map((o) => o.trim()).filter(Boolean);
                for (let o = r.length - 1; o >= 0; o -= 1) {
                  const i = r[o].split(":");
                  if (i.length >= 2) {
                    const s = i[0].trim().toLowerCase(), l = i.slice(1).join(":").trim();
                    if (s === "background-color")
                      return l.replace(/['"]+/g, "");
                  }
                }
              }
              return (e = t.style.backgroundColor) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.backgroundColor ? {
              style: `background-color: ${t.backgroundColor}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setBackgroundColor: (t) => ({ chain: e }) => e().setMark("textStyle", { backgroundColor: t }).run(),
      unsetBackgroundColor: () => ({ chain: t }) => t().setMark("textStyle", { backgroundColor: null }).removeEmptyTextStyle().run()
    };
  }
}), L1 = Q.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (t) => {
              var e;
              const n = t.getAttribute("style");
              if (n) {
                const r = n.split(";").map((o) => o.trim()).filter(Boolean);
                for (let o = r.length - 1; o >= 0; o -= 1) {
                  const i = r[o].split(":");
                  if (i.length >= 2) {
                    const s = i[0].trim().toLowerCase(), l = i.slice(1).join(":").trim();
                    if (s === "color")
                      return l.replace(/['"]+/g, "");
                  }
                }
              }
              return (e = t.style.color) == null ? void 0 : e.replace(/['"]+/g, "");
            },
            renderHTML: (t) => t.color ? {
              style: `color: ${t.color}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (t) => ({ chain: e }) => e().setMark("textStyle", { color: t }).run(),
      unsetColor: () => ({ chain: t }) => t().setMark("textStyle", { color: null }).removeEmptyTextStyle().run()
    };
  }
}), q3 = Q.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseHTML: (t) => t.style.fontFamily,
            renderHTML: (t) => t.fontFamily ? {
              style: `font-family: ${t.fontFamily}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontFamily: (t) => ({ chain: e }) => e().setMark("textStyle", { fontFamily: t }).run(),
      unsetFontFamily: () => ({ chain: t }) => t().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run()
    };
  }
}), G3 = Q.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize,
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
}), Z3 = Q.create({
  name: "lineHeight",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          lineHeight: {
            default: null,
            parseHTML: (t) => t.style.lineHeight,
            renderHTML: (t) => t.lineHeight ? {
              style: `line-height: ${t.lineHeight}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setLineHeight: (t) => ({ chain: e }) => e().setMark("textStyle", { lineHeight: t }).run(),
      unsetLineHeight: () => ({ chain: t }) => t().setMark("textStyle", { lineHeight: null }).removeEmptyTextStyle().run()
    };
  }
});
Q.create({
  name: "textStyleKit",
  addExtensions() {
    const t = [];
    return this.options.backgroundColor !== !1 && t.push(j3.configure(this.options.backgroundColor)), this.options.color !== !1 && t.push(L1.configure(this.options.color)), this.options.fontFamily !== !1 && t.push(q3.configure(this.options.fontFamily)), this.options.fontSize !== !1 && t.push(G3.configure(this.options.fontSize)), this.options.lineHeight !== !1 && t.push(Z3.configure(this.options.lineHeight)), this.options.textStyle !== !1 && t.push(I1.configure(this.options.textStyle)), t;
  }
});
const J3 = Q.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: (t) => t.style.fontSize?.replace("px", "") || null,
            renderHTML: (t) => t.fontSize ? {
              style: `font-size: ${t.fontSize}`
            } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setFontSize: (t) => ({ chain: e }) => e().setMark("textStyle", { fontSize: t }).run(),
      unsetFontSize: () => ({ chain: t }) => t().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run()
    };
  }
});
function Hs() {
  return typeof window < "u";
}
function Nr(t) {
  return Yc(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function Ke(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Bt(t) {
  var e;
  return (e = (Yc(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function Yc(t) {
  return Hs() ? t instanceof Node || t instanceof Ke(t).Node : !1;
}
function ce(t) {
  return Hs() ? t instanceof Element || t instanceof Ke(t).Element : !1;
}
function Ze(t) {
  return Hs() ? t instanceof HTMLElement || t instanceof Ke(t).HTMLElement : !1;
}
function Fa(t) {
  return !Hs() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Ke(t).ShadowRoot;
}
const Y3 = /* @__PURE__ */ new Set(["inline", "contents"]);
function xo(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: o
  } = st(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !Y3.has(o);
}
const X3 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Q3(t) {
  return X3.has(Nr(t));
}
const eS = [":popover-open", ":modal"];
function Fs(t) {
  return eS.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const tS = ["transform", "translate", "scale", "rotate", "perspective"], nS = ["transform", "translate", "scale", "rotate", "perspective", "filter"], rS = ["paint", "layout", "strict", "content"];
function Xc(t) {
  const e = _s(), n = ce(t) ? st(t) : t;
  return tS.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || nS.some((r) => (n.willChange || "").includes(r)) || rS.some((r) => (n.contain || "").includes(r));
}
function oS(t) {
  let e = Qt(t);
  for (; Ze(e) && !Xt(e); ) {
    if (Xc(e))
      return e;
    if (Fs(e))
      return null;
    e = Qt(e);
  }
  return null;
}
function _s() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const iS = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Xt(t) {
  return iS.has(Nr(t));
}
function st(t) {
  return Ke(t).getComputedStyle(t);
}
function zs(t) {
  return ce(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Qt(t) {
  if (Nr(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Fa(t) && t.host || // Fallback.
    Bt(t)
  );
  return Fa(e) ? e.host : e;
}
function D1(t) {
  const e = Qt(t);
  return Xt(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Ze(e) && xo(e) ? e : D1(e);
}
function xn(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const o = D1(t), i = o === ((r = t.ownerDocument) == null ? void 0 : r.body), s = Ke(o);
  if (i) {
    const l = _a(s);
    return e.concat(s, s.visualViewport || [], xo(o) ? o : [], l && n ? xn(l) : []);
  }
  return e.concat(o, xn(o, [], n));
}
function _a(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
const P1 = ["top", "right", "bottom", "left"], Wf = ["start", "end"], Kf = /* @__PURE__ */ P1.reduce((t, e) => t.concat(e, e + "-" + Wf[0], e + "-" + Wf[1]), []), yt = Math.min, De = Math.max, is = Math.round, Yo = Math.floor, It = (t) => ({
  x: t,
  y: t
}), sS = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, lS = {
  start: "end",
  end: "start"
};
function za(t, e, n) {
  return De(t, yt(e, n));
}
function bt(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Je(t) {
  return t.split("-")[0];
}
function pt(t) {
  return t.split("-")[1];
}
function Qc(t) {
  return t === "x" ? "y" : "x";
}
function eu(t) {
  return t === "y" ? "height" : "width";
}
const aS = /* @__PURE__ */ new Set(["top", "bottom"]);
function ht(t) {
  return aS.has(Je(t)) ? "y" : "x";
}
function tu(t) {
  return Qc(ht(t));
}
function B1(t, e, n) {
  n === void 0 && (n = !1);
  const r = pt(t), o = tu(t), i = eu(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = ls(s)), [s, ls(s)];
}
function cS(t) {
  const e = ls(t);
  return [ss(t), e, ss(e)];
}
function ss(t) {
  return t.replace(/start|end/g, (e) => lS[e]);
}
const jf = ["left", "right"], qf = ["right", "left"], uS = ["top", "bottom"], dS = ["bottom", "top"];
function fS(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? qf : jf : e ? jf : qf;
    case "left":
    case "right":
      return e ? uS : dS;
    default:
      return [];
  }
}
function hS(t, e, n, r) {
  const o = pt(t);
  let i = fS(Je(t), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), e && (i = i.concat(i.map(ss)))), i;
}
function ls(t) {
  return t.replace(/left|right|bottom|top/g, (e) => sS[e]);
}
function pS(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function nu(t) {
  return typeof t != "number" ? pS(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Er(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: o
  } = t;
  return {
    width: r,
    height: o,
    top: n,
    left: e,
    right: e + r,
    bottom: n + o,
    x: e,
    y: n
  };
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var mS = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Va = /* @__PURE__ */ mS.join(","), H1 = typeof Element > "u", ho = H1 ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, as = !H1 && Element.prototype.getRootNode ? function(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t);
} : function(t) {
  return t?.ownerDocument;
}, cs = function t(e, n) {
  var r;
  n === void 0 && (n = !0);
  var o = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "inert"), i = o === "" || o === "true", s = i || n && e && t(e.parentNode);
  return s;
}, gS = function(e) {
  var n, r = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "contenteditable");
  return r === "" || r === "true";
}, yS = function(e, n, r) {
  if (cs(e))
    return [];
  var o = Array.prototype.slice.apply(e.querySelectorAll(Va));
  return n && ho.call(e, Va) && o.unshift(e), o = o.filter(r), o;
}, bS = function t(e, n, r) {
  for (var o = [], i = Array.from(e); i.length; ) {
    var s = i.shift();
    if (!cs(s, !1))
      if (s.tagName === "SLOT") {
        var l = s.assignedElements(), a = l.length ? l : s.children, c = t(a, !0, r);
        r.flatten ? o.push.apply(o, c) : o.push({
          scopeParent: s,
          candidates: c
        });
      } else {
        var u = ho.call(s, Va);
        u && r.filter(s) && (n || !e.includes(s)) && o.push(s);
        var d = s.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(s), f = !cs(d, !1) && (!r.shadowRootFilter || r.shadowRootFilter(s));
        if (d && f) {
          var h = t(d === !0 ? s.children : d.children, !0, r);
          r.flatten ? o.push.apply(o, h) : o.push({
            scopeParent: s,
            candidates: h
          });
        } else
          i.unshift.apply(i, s.children);
      }
  }
  return o;
}, F1 = function(e) {
  return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
}, _1 = function(e) {
  if (!e)
    throw new Error("No node provided");
  return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || gS(e)) && !F1(e) ? 0 : e.tabIndex;
}, CS = function(e, n) {
  var r = _1(e);
  return r < 0 && n && !F1(e) ? 0 : r;
}, vS = function(e, n) {
  return e.tabIndex === n.tabIndex ? e.documentOrder - n.documentOrder : e.tabIndex - n.tabIndex;
}, z1 = function(e) {
  return e.tagName === "INPUT";
}, wS = function(e) {
  return z1(e) && e.type === "hidden";
}, SS = function(e) {
  var n = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, xS = function(e, n) {
  for (var r = 0; r < e.length; r++)
    if (e[r].checked && e[r].form === n)
      return e[r];
}, kS = function(e) {
  if (!e.name)
    return !0;
  var n = e.form || as(e), r = function(l) {
    return n.querySelectorAll('input[type="radio"][name="' + l + '"]');
  }, o;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    o = r(window.CSS.escape(e.name));
  else
    try {
      o = r(e.name);
    } catch (s) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), !1;
    }
  var i = xS(o, e.form);
  return !i || i === e;
}, ES = function(e) {
  return z1(e) && e.type === "radio";
}, MS = function(e) {
  return ES(e) && !kS(e);
}, TS = function(e) {
  var n, r = e && as(e), o = (n = r) === null || n === void 0 ? void 0 : n.host, i = !1;
  if (r && r !== e) {
    var s, l, a;
    for (i = !!((s = o) !== null && s !== void 0 && (l = s.ownerDocument) !== null && l !== void 0 && l.contains(o) || e != null && (a = e.ownerDocument) !== null && a !== void 0 && a.contains(e)); !i && o; ) {
      var c, u, d;
      r = as(o), o = (c = r) === null || c === void 0 ? void 0 : c.host, i = !!((u = o) !== null && u !== void 0 && (d = u.ownerDocument) !== null && d !== void 0 && d.contains(o));
    }
  }
  return i;
}, Gf = function(e) {
  var n = e.getBoundingClientRect(), r = n.width, o = n.height;
  return r === 0 && o === 0;
}, RS = function(e, n) {
  var r = n.displayCheck, o = n.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var i = ho.call(e, "details>summary:first-of-type"), s = i ? e.parentElement : e;
  if (ho.call(s, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof o == "function") {
      for (var l = e; e; ) {
        var a = e.parentElement, c = as(e);
        if (a && !a.shadowRoot && o(a) === !0)
          return Gf(e);
        e.assignedSlot ? e = e.assignedSlot : !a && c !== e.ownerDocument ? e = c.host : e = a;
      }
      e = l;
    }
    if (TS(e))
      return !e.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return Gf(e);
  return !1;
}, AS = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var n = e.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var o = n.children.item(r);
          if (o.tagName === "LEGEND")
            return ho.call(n, "fieldset[disabled] *") ? !0 : !o.contains(e);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, OS = function(e, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  cs(n) || wS(n) || RS(n, e) || // For a details element with a summary, the summary element gets the focus
  SS(n) || AS(n));
}, Zf = function(e, n) {
  return !(MS(n) || _1(n) < 0 || !OS(e, n));
}, NS = function(e) {
  var n = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, IS = function t(e) {
  var n = [], r = [];
  return e.forEach(function(o, i) {
    var s = !!o.scopeParent, l = s ? o.scopeParent : o, a = CS(l, s), c = s ? t(o.candidates) : l;
    a === 0 ? s ? n.push.apply(n, c) : n.push(l) : r.push({
      documentOrder: i,
      tabIndex: a,
      item: o,
      isScope: s,
      content: c
    });
  }), r.sort(vS).reduce(function(o, i) {
    return i.isScope ? o.push.apply(o, i.content) : o.push(i.content), o;
  }, []).concat(n);
}, V1 = function(e, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = bS([e], n.includeContainer, {
    filter: Zf.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: NS
  }) : r = yS(e, n.includeContainer, Zf.bind(null, n)), IS(r);
};
function LS() {
  const t = navigator.userAgentData;
  return t != null && t.platform ? t.platform : navigator.platform;
}
function DS() {
  const t = navigator.userAgentData;
  return t && Array.isArray(t.brands) ? t.brands.map((e) => {
    let {
      brand: n,
      version: r
    } = e;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function $1() {
  return /apple/i.test(navigator.vendor);
}
function PS() {
  return LS().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function BS() {
  return DS().includes("jsdom/");
}
const Jf = "data-floating-ui-focusable", HS = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function $a(t) {
  let e = t.activeElement;
  for (; ((n = e) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var n;
    e = e.shadowRoot.activeElement;
  }
  return e;
}
function Mr(t, e) {
  if (!t || !e)
    return !1;
  const n = e.getRootNode == null ? void 0 : e.getRootNode();
  if (t.contains(e))
    return !0;
  if (n && Fa(n)) {
    let r = e;
    for (; r; ) {
      if (t === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function pr(t) {
  return "composedPath" in t ? t.composedPath()[0] : t.target;
}
function Hl(t, e) {
  if (e == null)
    return !1;
  if ("composedPath" in t)
    return t.composedPath().includes(e);
  const n = t;
  return n.target != null && e.contains(n.target);
}
function FS(t) {
  return t.matches("html,body");
}
function Ot(t) {
  return t?.ownerDocument || document;
}
function _S(t) {
  return Ze(t) && t.matches(HS);
}
function zS(t) {
  if (!t || BS()) return !0;
  try {
    return t.matches(":focus-visible");
  } catch {
    return !0;
  }
}
function VS(t) {
  return t ? t.hasAttribute(Jf) ? t : t.querySelector("[" + Jf + "]") || t : null;
}
function fi(t, e, n) {
  return n === void 0 && (n = !0), t.filter((o) => {
    var i;
    return o.parentId === e && (!n || ((i = o.context) == null ? void 0 : i.open));
  }).flatMap((o) => [o, ...fi(t, o.id, n)]);
}
function $S(t) {
  return "nativeEvent" in t;
}
function Ua(t, e) {
  const n = ["mouse", "pen"];
  return n.push("", void 0), n.includes(t);
}
var US = typeof document < "u", WS = function() {
}, mt = US ? bs : WS;
const KS = {
  ...y
};
function Xo(t) {
  const e = y.useRef(t);
  return mt(() => {
    e.current = t;
  }), e;
}
const jS = KS.useInsertionEffect, qS = jS || ((t) => t());
function Rt(t) {
  const e = y.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return qS(() => {
    e.current = t;
  }), y.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
      r[o] = arguments[o];
    return e.current == null ? void 0 : e.current(...r);
  }, []);
}
const U1 = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function W1(t, e) {
  const n = V1(t, U1()), r = n.length;
  if (r === 0) return;
  const o = $a(Ot(t)), i = n.indexOf(o), s = i === -1 ? e === 1 ? 0 : r - 1 : i + e;
  return n[s];
}
function GS(t) {
  return W1(Ot(t).body, 1) || t;
}
function ZS(t) {
  return W1(Ot(t).body, -1) || t;
}
function Fl(t, e) {
  const n = e || t.currentTarget, r = t.relatedTarget;
  return !r || !Mr(n, r);
}
function JS(t) {
  V1(t, U1()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function Yf(t) {
  t.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
function Xf(t, e, n) {
  let {
    reference: r,
    floating: o
  } = t;
  const i = ht(e), s = tu(e), l = eu(s), a = Je(e), c = i === "y", u = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, f = r[l] / 2 - o[l] / 2;
  let h;
  switch (a) {
    case "top":
      h = {
        x: u,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (pt(e)) {
    case "start":
      h[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const YS = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, l = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: u,
    y: d
  } = Xf(c, r, a), f = r, h = {}, p = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: b,
      fn: C
    } = l[m], {
      x: v,
      y: S,
      data: w,
      reset: x
    } = await C({
      x: u,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: o,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = v ?? u, d = S ?? d, h = {
      ...h,
      [b]: {
        ...h[b],
        ...w
      }
    }, x && p <= 50 && (p++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (c = x.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : x.rects), {
      x: u,
      y: d
    } = Xf(c, f, a)), m = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: o,
    middlewareData: h
  };
};
async function Tr(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: l,
    strategy: a
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = bt(e, t), p = nu(h), b = l[f ? d === "floating" ? "reference" : "floating" : d], C = Er(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), v = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, S = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(l.floating)), w = await (i.isElement == null ? void 0 : i.isElement(S)) ? await (i.getScale == null ? void 0 : i.getScale(S)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = Er(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: v,
    offsetParent: S,
    strategy: a
  }) : v);
  return {
    top: (C.top - x.top + p.top) / w.y,
    bottom: (x.bottom - C.bottom + p.bottom) / w.y,
    left: (C.left - x.left + p.left) / w.x,
    right: (x.right - C.right + p.right) / w.x
  };
}
const XS = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: l,
      middlewareData: a
    } = e, {
      element: c,
      padding: u = 0
    } = bt(t, e) || {};
    if (c == null)
      return {};
    const d = nu(u), f = {
      x: n,
      y: r
    }, h = tu(o), p = eu(h), m = await s.getDimensions(c), b = h === "y", C = b ? "top" : "left", v = b ? "bottom" : "right", S = b ? "clientHeight" : "clientWidth", w = i.reference[p] + i.reference[h] - f[h] - i.floating[p], x = f[h] - i.reference[h], k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let E = k ? k[S] : 0;
    (!E || !await (s.isElement == null ? void 0 : s.isElement(k))) && (E = l.floating[S] || i.floating[p]);
    const M = w / 2 - x / 2, N = E / 2 - m[p] / 2 - 1, T = yt(d[C], N), P = yt(d[v], N), _ = T, F = E - m[p] - P, D = E / 2 - m[p] / 2 + M, W = za(_, D, F), $ = !a.arrow && pt(o) != null && D !== W && i.reference[p] / 2 - (D < _ ? T : P) - m[p] / 2 < 0, H = $ ? D < _ ? D - _ : D - F : 0;
    return {
      [h]: f[h] + H,
      data: {
        [h]: W,
        centerOffset: D - W - H,
        ...$ && {
          alignmentOffset: H
        }
      },
      reset: $
    };
  }
});
function QS(t, e, n) {
  return (t ? [...n.filter((o) => pt(o) === t), ...n.filter((o) => pt(o) !== t)] : n.filter((o) => Je(o) === o)).filter((o) => t ? pt(o) === t || (e ? ss(o) !== o : !1) : !0);
}
const ex = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, r, o;
      const {
        rects: i,
        middlewareData: s,
        placement: l,
        platform: a,
        elements: c
      } = e, {
        crossAxis: u = !1,
        alignment: d,
        allowedPlacements: f = Kf,
        autoAlignment: h = !0,
        ...p
      } = bt(t, e), m = d !== void 0 || f === Kf ? QS(d || null, h, f) : f, b = await Tr(e, p), C = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0, v = m[C];
      if (v == null)
        return {};
      const S = B1(v, i, await (a.isRTL == null ? void 0 : a.isRTL(c.floating)));
      if (l !== v)
        return {
          reset: {
            placement: m[0]
          }
        };
      const w = [b[Je(v)], b[S[0]], b[S[1]]], x = [...((r = s.autoPlacement) == null ? void 0 : r.overflows) || [], {
        placement: v,
        overflows: w
      }], k = m[C + 1];
      if (k)
        return {
          data: {
            index: C + 1,
            overflows: x
          },
          reset: {
            placement: k
          }
        };
      const E = x.map((T) => {
        const P = pt(T.placement);
        return [T.placement, P && u ? (
          // Check along the mainAxis and main crossAxis side.
          T.overflows.slice(0, 2).reduce((_, F) => _ + F, 0)
        ) : (
          // Check only the mainAxis.
          T.overflows[0]
        ), T.overflows];
      }).sort((T, P) => T[1] - P[1]), N = ((o = E.filter((T) => T[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        pt(T[0]) ? 2 : 3
      ).every((P) => P <= 0))[0]) == null ? void 0 : o[0]) || E[0][0];
      return N !== l ? {
        data: {
          index: C + 1,
          overflows: x
        },
        reset: {
          placement: N
        }
      } : {};
    }
  };
}, tx = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: l,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...b
      } = bt(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const C = Je(o), v = ht(l), S = Je(l) === l, w = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), x = f || (S || !m ? [ls(l)] : cS(l)), k = p !== "none";
      !f && k && x.push(...hS(l, m, p, w));
      const E = [l, ...x], M = await Tr(e, b), N = [];
      let T = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && N.push(M[C]), d) {
        const D = B1(o, s, w);
        N.push(M[D[0]], M[D[1]]);
      }
      if (T = [...T, {
        placement: o,
        overflows: N
      }], !N.every((D) => D <= 0)) {
        var P, _;
        const D = (((P = i.flip) == null ? void 0 : P.index) || 0) + 1, W = E[D];
        if (W && (!(d === "alignment" ? v !== ht(W) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        T.every((O) => ht(O.placement) === v ? O.overflows[0] > 0 : !0)))
          return {
            data: {
              index: D,
              overflows: T
            },
            reset: {
              placement: W
            }
          };
        let $ = (_ = T.filter((H) => H.overflows[0] <= 0).sort((H, O) => H.overflows[1] - O.overflows[1])[0]) == null ? void 0 : _.placement;
        if (!$)
          switch (h) {
            case "bestFit": {
              var F;
              const H = (F = T.filter((O) => {
                if (k) {
                  const I = ht(O.placement);
                  return I === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  I === "y";
                }
                return !0;
              }).map((O) => [O.placement, O.overflows.filter((I) => I > 0).reduce((I, j) => I + j, 0)]).sort((O, I) => O[1] - I[1])[0]) == null ? void 0 : F[0];
              H && ($ = H);
              break;
            }
            case "initialPlacement":
              $ = l;
              break;
          }
        if (o !== $)
          return {
            reset: {
              placement: $
            }
          };
      }
      return {};
    }
  };
};
function Qf(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function eh(t) {
  return P1.some((e) => t[e] >= 0);
}
const nx = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...o
      } = bt(t, e);
      switch (r) {
        case "referenceHidden": {
          const i = await Tr(e, {
            ...o,
            elementContext: "reference"
          }), s = Qf(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: eh(s)
            }
          };
        }
        case "escaped": {
          const i = await Tr(e, {
            ...o,
            altBoundary: !0
          }), s = Qf(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: eh(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function K1(t) {
  const e = yt(...t.map((i) => i.left)), n = yt(...t.map((i) => i.top)), r = De(...t.map((i) => i.right)), o = De(...t.map((i) => i.bottom));
  return {
    x: e,
    y: n,
    width: r - e,
    height: o - n
  };
}
function rx(t) {
  const e = t.slice().sort((o, i) => o.y - i.y), n = [];
  let r = null;
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    !r || i.y - r.y > r.height / 2 ? n.push([i]) : n[n.length - 1].push(i), r = i;
  }
  return n.map((o) => Er(K1(o)));
}
const ox = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      const {
        placement: n,
        elements: r,
        rects: o,
        platform: i,
        strategy: s
      } = e, {
        padding: l = 2,
        x: a,
        y: c
      } = bt(t, e), u = Array.from(await (i.getClientRects == null ? void 0 : i.getClientRects(r.reference)) || []), d = rx(u), f = Er(K1(u)), h = nu(l);
      function p() {
        if (d.length === 2 && d[0].left > d[1].right && a != null && c != null)
          return d.find((b) => a > b.left - h.left && a < b.right + h.right && c > b.top - h.top && c < b.bottom + h.bottom) || f;
        if (d.length >= 2) {
          if (ht(n) === "y") {
            const T = d[0], P = d[d.length - 1], _ = Je(n) === "top", F = T.top, D = P.bottom, W = _ ? T.left : P.left, $ = _ ? T.right : P.right, H = $ - W, O = D - F;
            return {
              top: F,
              bottom: D,
              left: W,
              right: $,
              width: H,
              height: O,
              x: W,
              y: F
            };
          }
          const b = Je(n) === "left", C = De(...d.map((T) => T.right)), v = yt(...d.map((T) => T.left)), S = d.filter((T) => b ? T.left === v : T.right === C), w = S[0].top, x = S[S.length - 1].bottom, k = v, E = C, M = E - k, N = x - w;
          return {
            top: w,
            bottom: x,
            left: k,
            right: E,
            width: M,
            height: N,
            x: k,
            y: w
          };
        }
        return f;
      }
      const m = await i.getElementRects({
        reference: {
          getBoundingClientRect: p
        },
        floating: r.floating,
        strategy: s
      });
      return o.reference.x !== m.reference.x || o.reference.y !== m.reference.y || o.reference.width !== m.reference.width || o.reference.height !== m.reference.height ? {
        reset: {
          rects: m
        }
      } : {};
    }
  };
}, j1 = /* @__PURE__ */ new Set(["left", "top"]);
async function ix(t, e) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = t, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = Je(n), l = pt(n), a = ht(n) === "y", c = j1.has(s) ? -1 : 1, u = i && a ? -1 : 1, d = bt(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return l && typeof p == "number" && (h = l === "end" ? p * -1 : p), a ? {
    x: h * u,
    y: f * c
  } : {
    x: f * c,
    y: h * u
  };
}
const sx = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: l
      } = e, a = await ix(e, t);
      return s === ((n = l.offset) == null ? void 0 : n.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, lx = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: l = {
          fn: (b) => {
            let {
              x: C,
              y: v
            } = b;
            return {
              x: C,
              y: v
            };
          }
        },
        ...a
      } = bt(t, e), c = {
        x: n,
        y: r
      }, u = await Tr(e, a), d = ht(Je(o)), f = Qc(d);
      let h = c[f], p = c[d];
      if (i) {
        const b = f === "y" ? "top" : "left", C = f === "y" ? "bottom" : "right", v = h + u[b], S = h - u[C];
        h = za(v, h, S);
      }
      if (s) {
        const b = d === "y" ? "top" : "left", C = d === "y" ? "bottom" : "right", v = p + u[b], S = p - u[C];
        p = za(v, p, S);
      }
      const m = l.fn({
        ...e,
        [f]: h,
        [d]: p
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r,
          enabled: {
            [f]: i,
            [d]: s
          }
        }
      };
    }
  };
}, ax = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        middlewareData: s
      } = e, {
        offset: l = 0,
        mainAxis: a = !0,
        crossAxis: c = !0
      } = bt(t, e), u = {
        x: n,
        y: r
      }, d = ht(o), f = Qc(d);
      let h = u[f], p = u[d];
      const m = bt(l, e), b = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (a) {
        const S = f === "y" ? "height" : "width", w = i.reference[f] - i.floating[S] + b.mainAxis, x = i.reference[f] + i.reference[S] - b.mainAxis;
        h < w ? h = w : h > x && (h = x);
      }
      if (c) {
        var C, v;
        const S = f === "y" ? "width" : "height", w = j1.has(Je(o)), x = i.reference[d] - i.floating[S] + (w && ((C = s.offset) == null ? void 0 : C[d]) || 0) + (w ? 0 : b.crossAxis), k = i.reference[d] + i.reference[S] + (w ? 0 : ((v = s.offset) == null ? void 0 : v[d]) || 0) - (w ? b.crossAxis : 0);
        p < x ? p = x : p > k && (p = k);
      }
      return {
        [f]: h,
        [d]: p
      };
    }
  };
}, cx = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        rects: i,
        platform: s,
        elements: l
      } = e, {
        apply: a = () => {
        },
        ...c
      } = bt(t, e), u = await Tr(e, c), d = Je(o), f = pt(o), h = ht(o) === "y", {
        width: p,
        height: m
      } = i.floating;
      let b, C;
      d === "top" || d === "bottom" ? (b = d, C = f === (await (s.isRTL == null ? void 0 : s.isRTL(l.floating)) ? "start" : "end") ? "left" : "right") : (C = d, b = f === "end" ? "top" : "bottom");
      const v = m - u.top - u.bottom, S = p - u.left - u.right, w = yt(m - u[b], v), x = yt(p - u[C], S), k = !e.middlewareData.shift;
      let E = w, M = x;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (M = S), (r = e.middlewareData.shift) != null && r.enabled.y && (E = v), k && !f) {
        const T = De(u.left, 0), P = De(u.right, 0), _ = De(u.top, 0), F = De(u.bottom, 0);
        h ? M = p - 2 * (T !== 0 || P !== 0 ? T + P : De(u.left, u.right)) : E = m - 2 * (_ !== 0 || F !== 0 ? _ + F : De(u.top, u.bottom));
      }
      await a({
        ...e,
        availableWidth: M,
        availableHeight: E
      });
      const N = await s.getDimensions(l.floating);
      return p !== N.width || m !== N.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function q1(t) {
  const e = st(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const o = Ze(t), i = o ? t.offsetWidth : n, s = o ? t.offsetHeight : r, l = is(n) !== i || is(r) !== s;
  return l && (n = i, r = s), {
    width: n,
    height: r,
    $: l
  };
}
function ru(t) {
  return ce(t) ? t : t.contextElement;
}
function br(t) {
  const e = ru(t);
  if (!Ze(e))
    return It(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = q1(e);
  let s = (i ? is(n.width) : n.width) / r, l = (i ? is(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: s,
    y: l
  };
}
const ux = /* @__PURE__ */ It(0);
function G1(t) {
  const e = Ke(t);
  return !_s() || !e.visualViewport ? ux : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function dx(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== Ke(t) ? !1 : e;
}
function Yn(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), i = ru(t);
  let s = It(1);
  e && (r ? ce(r) && (s = br(r)) : s = br(t));
  const l = dx(i, n, r) ? G1(i) : It(0);
  let a = (o.left + l.x) / s.x, c = (o.top + l.y) / s.y, u = o.width / s.x, d = o.height / s.y;
  if (i) {
    const f = Ke(i), h = r && ce(r) ? Ke(r) : r;
    let p = f, m = _a(p);
    for (; m && r && h !== p; ) {
      const b = br(m), C = m.getBoundingClientRect(), v = st(m), S = C.left + (m.clientLeft + parseFloat(v.paddingLeft)) * b.x, w = C.top + (m.clientTop + parseFloat(v.paddingTop)) * b.y;
      a *= b.x, c *= b.y, u *= b.x, d *= b.y, a += S, c += w, p = Ke(m), m = _a(p);
    }
  }
  return Er({
    width: u,
    height: d,
    x: a,
    y: c
  });
}
function ou(t, e) {
  const n = zs(t).scrollLeft;
  return e ? e.left + n : Yn(Bt(t)).left + n;
}
function Z1(t, e, n) {
  n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), o = r.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    ou(t, r)
  )), i = r.top + e.scrollTop;
  return {
    x: o,
    y: i
  };
}
function fx(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: o
  } = t;
  const i = o === "fixed", s = Bt(r), l = e ? Fs(e.floating) : !1;
  if (r === s || l && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = It(1);
  const u = It(0), d = Ze(r);
  if ((d || !d && !i) && ((Nr(r) !== "body" || xo(s)) && (a = zs(r)), Ze(r))) {
    const h = Yn(r);
    c = br(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const f = s && !d && !i ? Z1(s, a, !0) : It(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - a.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - a.scrollTop * c.y + u.y + f.y
  };
}
function hx(t) {
  return Array.from(t.getClientRects());
}
function px(t) {
  const e = Bt(t), n = zs(t), r = t.ownerDocument.body, o = De(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), i = De(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + ou(t);
  const l = -n.scrollTop;
  return st(r).direction === "rtl" && (s += De(e.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: l
  };
}
function mx(t, e) {
  const n = Ke(t), r = Bt(t), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, l = 0, a = 0;
  if (o) {
    i = o.width, s = o.height;
    const c = _s();
    (!c || c && e === "fixed") && (l = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: l,
    y: a
  };
}
const gx = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function yx(t, e) {
  const n = Yn(t, !0, e === "fixed"), r = n.top + t.clientTop, o = n.left + t.clientLeft, i = Ze(t) ? br(t) : It(1), s = t.clientWidth * i.x, l = t.clientHeight * i.y, a = o * i.x, c = r * i.y;
  return {
    width: s,
    height: l,
    x: a,
    y: c
  };
}
function th(t, e, n) {
  let r;
  if (e === "viewport")
    r = mx(t, n);
  else if (e === "document")
    r = px(Bt(t));
  else if (ce(e))
    r = yx(e, n);
  else {
    const o = G1(t);
    r = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return Er(r);
}
function J1(t, e) {
  const n = Qt(t);
  return n === e || !ce(n) || Xt(n) ? !1 : st(n).position === "fixed" || J1(n, e);
}
function bx(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = xn(t, [], !1).filter((l) => ce(l) && Nr(l) !== "body"), o = null;
  const i = st(t).position === "fixed";
  let s = i ? Qt(t) : t;
  for (; ce(s) && !Xt(s); ) {
    const l = st(s), a = Xc(s);
    !a && l.position === "fixed" && (o = null), (i ? !a && !o : !a && l.position === "static" && !!o && gx.has(o.position) || xo(s) && !a && J1(t, s)) ? r = r.filter((u) => u !== s) : o = l, s = Qt(s);
  }
  return e.set(t, r), r;
}
function Cx(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = t;
  const s = [...n === "clippingAncestors" ? Fs(e) ? [] : bx(e, this._c) : [].concat(n), r], l = s[0], a = s.reduce((c, u) => {
    const d = th(e, u, o);
    return c.top = De(d.top, c.top), c.right = yt(d.right, c.right), c.bottom = yt(d.bottom, c.bottom), c.left = De(d.left, c.left), c;
  }, th(e, l, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function vx(t) {
  const {
    width: e,
    height: n
  } = q1(t);
  return {
    width: e,
    height: n
  };
}
function wx(t, e, n) {
  const r = Ze(e), o = Bt(e), i = n === "fixed", s = Yn(t, !0, i, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = It(0);
  function c() {
    a.x = ou(o);
  }
  if (r || !r && !i)
    if ((Nr(e) !== "body" || xo(o)) && (l = zs(e)), r) {
      const h = Yn(e, !0, i, e);
      a.x = h.x + e.clientLeft, a.y = h.y + e.clientTop;
    } else o && c();
  i && !r && o && c();
  const u = o && !r && !i ? Z1(o, l) : It(0), d = s.left + l.scrollLeft - a.x - u.x, f = s.top + l.scrollTop - a.y - u.y;
  return {
    x: d,
    y: f,
    width: s.width,
    height: s.height
  };
}
function _l(t) {
  return st(t).position === "static";
}
function nh(t, e) {
  if (!Ze(t) || st(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Bt(t) === n && (n = n.ownerDocument.body), n;
}
function Y1(t, e) {
  const n = Ke(t);
  if (Fs(t))
    return n;
  if (!Ze(t)) {
    let o = Qt(t);
    for (; o && !Xt(o); ) {
      if (ce(o) && !_l(o))
        return o;
      o = Qt(o);
    }
    return n;
  }
  let r = nh(t, e);
  for (; r && Q3(r) && _l(r); )
    r = nh(r, e);
  return r && Xt(r) && _l(r) && !Xc(r) ? n : r || oS(t) || n;
}
const Sx = async function(t) {
  const e = this.getOffsetParent || Y1, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: wx(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function xx(t) {
  return st(t).direction === "rtl";
}
const kx = {
  convertOffsetParentRelativeRectToViewportRelativeRect: fx,
  getDocumentElement: Bt,
  getClippingRect: Cx,
  getOffsetParent: Y1,
  getElementRects: Sx,
  getClientRects: hx,
  getDimensions: vx,
  getScale: br,
  isElement: ce,
  isRTL: xx
};
function X1(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function Ex(t, e) {
  let n = null, r;
  const o = Bt(t);
  function i() {
    var l;
    clearTimeout(r), (l = n) == null || l.disconnect(), n = null;
  }
  function s(l, a) {
    l === void 0 && (l = !1), a === void 0 && (a = 1), i();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: h
    } = c;
    if (l || e(), !f || !h)
      return;
    const p = Yo(d), m = Yo(o.clientWidth - (u + f)), b = Yo(o.clientHeight - (d + h)), C = Yo(u), S = {
      rootMargin: -p + "px " + -m + "px " + -b + "px " + -C + "px",
      threshold: De(0, yt(1, a)) || 1
    };
    let w = !0;
    function x(k) {
      const E = k[0].intersectionRatio;
      if (E !== a) {
        if (!w)
          return s();
        E ? s(!1, E) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      E === 1 && !X1(c, t.getBoundingClientRect()) && s(), w = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...S,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, S);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function Q1(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, c = ru(t), u = o || i ? [...c ? xn(c) : [], ...xn(e)] : [];
  u.forEach((C) => {
    o && C.addEventListener("scroll", n, {
      passive: !0
    }), i && C.addEventListener("resize", n);
  });
  const d = c && l ? Ex(c, n) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((C) => {
    let [v] = C;
    v && v.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var S;
      (S = h) == null || S.observe(e);
    })), n();
  }), c && !a && h.observe(c), h.observe(e));
  let p, m = a ? Yn(t) : null;
  a && b();
  function b() {
    const C = Yn(t);
    m && !X1(m, C) && n(), m = C, p = requestAnimationFrame(b);
  }
  return n(), () => {
    var C;
    u.forEach((v) => {
      o && v.removeEventListener("scroll", n), i && v.removeEventListener("resize", n);
    }), d?.(), (C = h) == null || C.disconnect(), h = null, a && cancelAnimationFrame(p);
  };
}
const iu = sx, eg = ex, su = lx, lu = tx, au = cx, cu = nx, us = XS, tg = ox, Mx = ax, uu = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: kx,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return YS(t, e, {
    ...o,
    platform: i
  });
};
var Tx = typeof document < "u", Rx = function() {
}, hi = Tx ? bs : Rx;
function ds(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, o;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!ds(t[r], e[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(t), n = o.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && t.$$typeof) && !ds(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function ng(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function rh(t, e) {
  const n = ng(t);
  return Math.round(e * n) / n;
}
function zl(t) {
  const e = y.useRef(t);
  return hi(() => {
    e.current = t;
  }), e;
}
function rg(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: l = !0,
    whileElementsMounted: a,
    open: c
  } = t, [u, d] = y.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = y.useState(r);
  ds(f, r) || h(r);
  const [p, m] = y.useState(null), [b, C] = y.useState(null), v = y.useCallback((O) => {
    O !== k.current && (k.current = O, m(O));
  }, []), S = y.useCallback((O) => {
    O !== E.current && (E.current = O, C(O));
  }, []), w = i || p, x = s || b, k = y.useRef(null), E = y.useRef(null), M = y.useRef(u), N = a != null, T = zl(a), P = zl(o), _ = zl(c), F = y.useCallback(() => {
    if (!k.current || !E.current)
      return;
    const O = {
      placement: e,
      strategy: n,
      middleware: f
    };
    P.current && (O.platform = P.current), uu(k.current, E.current, O).then((I) => {
      const j = {
        ...I,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: _.current !== !1
      };
      D.current && !ds(M.current, j) && (M.current = j, sc.flushSync(() => {
        d(j);
      }));
    });
  }, [f, e, n, P, _]);
  hi(() => {
    c === !1 && M.current.isPositioned && (M.current.isPositioned = !1, d((O) => ({
      ...O,
      isPositioned: !1
    })));
  }, [c]);
  const D = y.useRef(!1);
  hi(() => (D.current = !0, () => {
    D.current = !1;
  }), []), hi(() => {
    if (w && (k.current = w), x && (E.current = x), w && x) {
      if (T.current)
        return T.current(w, x, F);
      F();
    }
  }, [w, x, F, T, N]);
  const W = y.useMemo(() => ({
    reference: k,
    floating: E,
    setReference: v,
    setFloating: S
  }), [v, S]), $ = y.useMemo(() => ({
    reference: w,
    floating: x
  }), [w, x]), H = y.useMemo(() => {
    const O = {
      position: n,
      left: 0,
      top: 0
    };
    if (!$.floating)
      return O;
    const I = rh($.floating, u.x), j = rh($.floating, u.y);
    return l ? {
      ...O,
      transform: "translate(" + I + "px, " + j + "px)",
      ...ng($.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: I,
      top: j
    };
  }, [n, l, $.floating, u.x, u.y]);
  return y.useMemo(() => ({
    ...u,
    update: F,
    refs: W,
    elements: $,
    floatingStyles: H
  }), [u, F, W, $, H]);
}
const Ax = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? us({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? us({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, og = (t, e) => ({
  ...iu(t),
  options: [t, e]
}), ig = (t, e) => ({
  ...su(t),
  options: [t, e]
}), Ox = (t, e) => ({
  ...Mx(t),
  options: [t, e]
}), sg = (t, e) => ({
  ...lu(t),
  options: [t, e]
}), Nx = (t, e) => ({
  ...au(t),
  options: [t, e]
}), Ix = (t, e) => ({
  ...cu(t),
  options: [t, e]
}), Lx = (t, e) => ({
  ...Ax(t),
  options: [t, e]
});
function lg(t) {
  const e = y.useRef(void 0), n = y.useCallback((r) => {
    const o = t.map((i) => {
      if (i != null) {
        if (typeof i == "function") {
          const s = i, l = s(r);
          return typeof l == "function" ? l : () => {
            s(null);
          };
        }
        return i.current = r, () => {
          i.current = null;
        };
      }
    });
    return () => {
      o.forEach((i) => i?.());
    };
  }, t);
  return y.useMemo(() => t.every((r) => r == null) ? null : (r) => {
    e.current && (e.current(), e.current = void 0), r != null && (e.current = n(r));
  }, t);
}
const Dx = "data-floating-ui-focusable", oh = "active", ih = "selected", Px = {
  ...y
};
let sh = !1, Bx = 0;
const lh = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + Bx++
);
function Hx() {
  const [t, e] = y.useState(() => sh ? lh() : void 0);
  return mt(() => {
    t == null && e(lh());
  }, []), y.useEffect(() => {
    sh = !0;
  }, []), t;
}
const Fx = Px.useId, du = Fx || Hx;
let Wa;
process.env.NODE_ENV !== "production" && (Wa = /* @__PURE__ */ new Set());
function _x() {
  for (var t, e = arguments.length, n = new Array(e), r = 0; r < e; r++)
    n[r] = arguments[r];
  const o = "Floating UI: " + n.join(" ");
  if (!((t = Wa) != null && t.has(o))) {
    var i;
    (i = Wa) == null || i.add(o), console.error(o);
  }
}
function zx() {
  const t = /* @__PURE__ */ new Map();
  return {
    emit(e, n) {
      var r;
      (r = t.get(e)) == null || r.forEach((o) => o(n));
    },
    on(e, n) {
      t.has(e) || t.set(e, /* @__PURE__ */ new Set()), t.get(e).add(n);
    },
    off(e, n) {
      var r;
      (r = t.get(e)) == null || r.delete(n);
    }
  };
}
const Vx = /* @__PURE__ */ y.createContext(null), $x = /* @__PURE__ */ y.createContext(null), fu = () => {
  var t;
  return ((t = y.useContext(Vx)) == null ? void 0 : t.id) || null;
}, hu = () => y.useContext($x);
function ko(t) {
  return "data-floating-ui-" + t;
}
function et(t) {
  t.current !== -1 && (clearTimeout(t.current), t.current = -1);
}
const ah = /* @__PURE__ */ ko("safe-polygon");
function Vl(t, e, n) {
  if (n && !Ua(n))
    return 0;
  if (typeof t == "number")
    return t;
  if (typeof t == "function") {
    const r = t();
    return typeof r == "number" ? r : r?.[e];
  }
  return t?.[e];
}
function $l(t) {
  return typeof t == "function" ? t() : t;
}
function Ux(t, e) {
  e === void 0 && (e = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: o,
    events: i,
    elements: s
  } = t, {
    enabled: l = !0,
    delay: a = 0,
    handleClose: c = null,
    mouseOnly: u = !1,
    restMs: d = 0,
    move: f = !0
  } = e, h = hu(), p = fu(), m = Xo(c), b = Xo(a), C = Xo(n), v = Xo(d), S = y.useRef(), w = y.useRef(-1), x = y.useRef(), k = y.useRef(-1), E = y.useRef(!0), M = y.useRef(!1), N = y.useRef(() => {
  }), T = y.useRef(!1), P = Rt(() => {
    var H;
    const O = (H = o.current.openEvent) == null ? void 0 : H.type;
    return O?.includes("mouse") && O !== "mousedown";
  });
  y.useEffect(() => {
    if (!l) return;
    function H(O) {
      let {
        open: I
      } = O;
      I || (et(w), et(k), E.current = !0, T.current = !1);
    }
    return i.on("openchange", H), () => {
      i.off("openchange", H);
    };
  }, [l, i]), y.useEffect(() => {
    if (!l || !m.current || !n) return;
    function H(I) {
      P() && r(!1, I, "hover");
    }
    const O = Ot(s.floating).documentElement;
    return O.addEventListener("mouseleave", H), () => {
      O.removeEventListener("mouseleave", H);
    };
  }, [s.floating, n, r, l, m, P]);
  const _ = y.useCallback(function(H, O, I) {
    O === void 0 && (O = !0), I === void 0 && (I = "hover");
    const j = Vl(b.current, "close", S.current);
    j && !x.current ? (et(w), w.current = window.setTimeout(() => r(!1, H, I), j)) : O && (et(w), r(!1, H, I));
  }, [b, r]), F = Rt(() => {
    N.current(), x.current = void 0;
  }), D = Rt(() => {
    if (M.current) {
      const H = Ot(s.floating).body;
      H.style.pointerEvents = "", H.removeAttribute(ah), M.current = !1;
    }
  }), W = Rt(() => o.current.openEvent ? ["click", "mousedown"].includes(o.current.openEvent.type) : !1);
  y.useEffect(() => {
    if (!l) return;
    function H(q) {
      if (et(w), E.current = !1, u && !Ua(S.current) || $l(v.current) > 0 && !Vl(b.current, "open"))
        return;
      const te = Vl(b.current, "open", S.current);
      te ? w.current = window.setTimeout(() => {
        C.current || r(!0, q, "hover");
      }, te) : n || r(!0, q, "hover");
    }
    function O(q) {
      if (W()) {
        D();
        return;
      }
      N.current();
      const te = Ot(s.floating);
      if (et(k), T.current = !1, m.current && o.current.floatingContext) {
        n || et(w), x.current = m.current({
          ...o.current.floatingContext,
          tree: h,
          x: q.clientX,
          y: q.clientY,
          onClose() {
            D(), F(), W() || _(q, !0, "safe-polygon");
          }
        });
        const fe = x.current;
        te.addEventListener("mousemove", fe), N.current = () => {
          te.removeEventListener("mousemove", fe);
        };
        return;
      }
      (S.current === "touch" ? !Mr(s.floating, q.relatedTarget) : !0) && _(q);
    }
    function I(q) {
      W() || o.current.floatingContext && (m.current == null || m.current({
        ...o.current.floatingContext,
        tree: h,
        x: q.clientX,
        y: q.clientY,
        onClose() {
          D(), F(), W() || _(q);
        }
      })(q));
    }
    function j() {
      et(w);
    }
    function re(q) {
      W() || _(q, !1);
    }
    if (ce(s.domReference)) {
      const q = s.domReference, te = s.floating;
      return n && q.addEventListener("mouseleave", I), f && q.addEventListener("mousemove", H, {
        once: !0
      }), q.addEventListener("mouseenter", H), q.addEventListener("mouseleave", O), te && (te.addEventListener("mouseleave", I), te.addEventListener("mouseenter", j), te.addEventListener("mouseleave", re)), () => {
        n && q.removeEventListener("mouseleave", I), f && q.removeEventListener("mousemove", H), q.removeEventListener("mouseenter", H), q.removeEventListener("mouseleave", O), te && (te.removeEventListener("mouseleave", I), te.removeEventListener("mouseenter", j), te.removeEventListener("mouseleave", re));
      };
    }
  }, [s, l, t, u, f, _, F, D, r, n, C, h, b, m, o, W, v]), mt(() => {
    var H;
    if (l && n && (H = m.current) != null && (H = H.__options) != null && H.blockPointerEvents && P()) {
      M.current = !0;
      const I = s.floating;
      if (ce(s.domReference) && I) {
        var O;
        const j = Ot(s.floating).body;
        j.setAttribute(ah, "");
        const re = s.domReference, q = h == null || (O = h.nodesRef.current.find((te) => te.id === p)) == null || (O = O.context) == null ? void 0 : O.elements.floating;
        return q && (q.style.pointerEvents = ""), j.style.pointerEvents = "none", re.style.pointerEvents = "auto", I.style.pointerEvents = "auto", () => {
          j.style.pointerEvents = "", re.style.pointerEvents = "", I.style.pointerEvents = "";
        };
      }
    }
  }, [l, n, p, s, h, m, P]), mt(() => {
    n || (S.current = void 0, T.current = !1, F(), D());
  }, [n, F, D]), y.useEffect(() => () => {
    F(), et(w), et(k), D();
  }, [l, s.domReference, F, D]);
  const $ = y.useMemo(() => {
    function H(O) {
      S.current = O.pointerType;
    }
    return {
      onPointerDown: H,
      onPointerEnter: H,
      onMouseMove(O) {
        const {
          nativeEvent: I
        } = O;
        function j() {
          !E.current && !C.current && r(!0, I, "hover");
        }
        u && !Ua(S.current) || n || $l(v.current) === 0 || T.current && O.movementX ** 2 + O.movementY ** 2 < 2 || (et(k), S.current === "touch" ? j() : (T.current = !0, k.current = window.setTimeout(j, $l(v.current))));
      }
    };
  }, [u, r, n, C, v]);
  return y.useMemo(() => l ? {
    reference: $
  } : {}, [l, $]);
}
const ch = () => {
}, Wx = /* @__PURE__ */ y.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: ch,
  setState: ch,
  isInstantPhase: !1
});
function Kx(t) {
  const {
    children: e,
    delay: n,
    timeoutMs: r = 0
  } = t, [o, i] = y.useReducer((a, c) => ({
    ...a,
    ...c
  }), {
    delay: n,
    timeoutMs: r,
    initialDelay: n,
    currentId: null,
    isInstantPhase: !1
  }), s = y.useRef(null), l = y.useCallback((a) => {
    i({
      currentId: a
    });
  }, []);
  return mt(() => {
    o.currentId ? s.current === null ? s.current = o.currentId : o.isInstantPhase || i({
      isInstantPhase: !0
    }) : (o.isInstantPhase && i({
      isInstantPhase: !1
    }), s.current = null);
  }, [o.currentId, o.isInstantPhase]), /* @__PURE__ */ g(Wx.Provider, {
    value: y.useMemo(() => ({
      ...o,
      setState: i,
      setCurrentId: l
    }), [o, l]),
    children: e
  });
}
const ag = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
}, uh = /* @__PURE__ */ y.forwardRef(function(e, n) {
  const [r, o] = y.useState();
  mt(() => {
    $1() && o("button");
  }, []);
  const i = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [ko("focus-guard")]: "",
    style: ag
  };
  return /* @__PURE__ */ g("span", {
    ...e,
    ...i
  });
}), cg = /* @__PURE__ */ y.createContext(null), dh = /* @__PURE__ */ ko("portal");
function jx(t) {
  t === void 0 && (t = {});
  const {
    id: e,
    root: n
  } = t, r = du(), o = Gx(), [i, s] = y.useState(null), l = y.useRef(null);
  return mt(() => () => {
    i?.remove(), queueMicrotask(() => {
      l.current = null;
    });
  }, [i]), mt(() => {
    if (!r || l.current) return;
    const a = e ? document.getElementById(e) : null;
    if (!a) return;
    const c = document.createElement("div");
    c.id = r, c.setAttribute(dh, ""), a.appendChild(c), l.current = c, s(c);
  }, [e, r]), mt(() => {
    if (n === null || !r || l.current) return;
    let a = n || o?.portalNode;
    a && !Yc(a) && (a = a.current), a = a || document.body;
    let c = null;
    e && (c = document.createElement("div"), c.id = e, a.appendChild(c));
    const u = document.createElement("div");
    u.id = r, u.setAttribute(dh, ""), a = c || a, a.appendChild(u), l.current = u, s(u);
  }, [e, n, r, o]), i;
}
function qx(t) {
  const {
    children: e,
    id: n,
    root: r,
    preserveTabOrder: o = !0
  } = t, i = jx({
    id: n,
    root: r
  }), [s, l] = y.useState(null), a = y.useRef(null), c = y.useRef(null), u = y.useRef(null), d = y.useRef(null), f = s?.modal, h = s?.open, p = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!s && // Guards are only for non-modal focus management.
    !s.modal && // Don't render if unmount is transitioning.
    s.open && o && !!(r || i)
  );
  return y.useEffect(() => {
    if (!i || !o || f)
      return;
    function m(b) {
      i && Fl(b) && (b.type === "focusin" ? Yf : JS)(i);
    }
    return i.addEventListener("focusin", m, !0), i.addEventListener("focusout", m, !0), () => {
      i.removeEventListener("focusin", m, !0), i.removeEventListener("focusout", m, !0);
    };
  }, [i, o, f]), y.useEffect(() => {
    i && (h || Yf(i));
  }, [h, i]), /* @__PURE__ */ R(cg.Provider, {
    value: y.useMemo(() => ({
      preserveTabOrder: o,
      beforeOutsideRef: a,
      afterOutsideRef: c,
      beforeInsideRef: u,
      afterInsideRef: d,
      portalNode: i,
      setFocusManagerState: l
    }), [o, i]),
    children: [p && i && /* @__PURE__ */ g(uh, {
      "data-type": "outside",
      ref: a,
      onFocus: (m) => {
        if (Fl(m, i)) {
          var b;
          (b = u.current) == null || b.focus();
        } else {
          const C = s ? s.domReference : null, v = ZS(C);
          v?.focus();
        }
      }
    }), p && i && /* @__PURE__ */ g("span", {
      "aria-owns": i.id,
      style: ag
    }), i && /* @__PURE__ */ sc.createPortal(e, i), p && i && /* @__PURE__ */ g(uh, {
      "data-type": "outside",
      ref: c,
      onFocus: (m) => {
        if (Fl(m, i)) {
          var b;
          (b = d.current) == null || b.focus();
        } else {
          const C = s ? s.domReference : null, v = GS(C);
          v?.focus(), s?.closeOnFocusOut && s?.onOpenChange(!1, m.nativeEvent, "focus-out");
        }
      }
    })]
  });
}
const Gx = () => y.useContext(cg), Zx = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, Jx = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, fh = (t) => {
  var e, n;
  return {
    escapeKey: typeof t == "boolean" ? t : (e = t?.escapeKey) != null ? e : !1,
    outsidePress: typeof t == "boolean" ? t : (n = t?.outsidePress) != null ? n : !0
  };
};
function Yx(t, e) {
  e === void 0 && (e = {});
  const {
    open: n,
    onOpenChange: r,
    elements: o,
    dataRef: i
  } = t, {
    enabled: s = !0,
    escapeKey: l = !0,
    outsidePress: a = !0,
    outsidePressEvent: c = "pointerdown",
    referencePress: u = !1,
    referencePressEvent: d = "pointerdown",
    ancestorScroll: f = !1,
    bubbles: h,
    capture: p
  } = e, m = hu(), b = Rt(typeof a == "function" ? a : () => !1), C = typeof a == "function" ? b : a, v = y.useRef(!1), {
    escapeKey: S,
    outsidePress: w
  } = fh(h), {
    escapeKey: x,
    outsidePress: k
  } = fh(p), E = y.useRef(!1), M = Rt((D) => {
    var W;
    if (!n || !s || !l || D.key !== "Escape" || E.current)
      return;
    const $ = (W = i.current.floatingContext) == null ? void 0 : W.nodeId, H = m ? fi(m.nodesRef.current, $) : [];
    if (!S && (D.stopPropagation(), H.length > 0)) {
      let O = !0;
      if (H.forEach((I) => {
        var j;
        if ((j = I.context) != null && j.open && !I.context.dataRef.current.__escapeKeyBubbles) {
          O = !1;
          return;
        }
      }), !O)
        return;
    }
    r(!1, $S(D) ? D.nativeEvent : D, "escape-key");
  }), N = Rt((D) => {
    var W;
    const $ = () => {
      var H;
      M(D), (H = pr(D)) == null || H.removeEventListener("keydown", $);
    };
    (W = pr(D)) == null || W.addEventListener("keydown", $);
  }), T = Rt((D) => {
    var W;
    const $ = i.current.insideReactTree;
    i.current.insideReactTree = !1;
    const H = v.current;
    if (v.current = !1, c === "click" && H || $ || typeof C == "function" && !C(D))
      return;
    const O = pr(D), I = "[" + ko("inert") + "]", j = Ot(o.floating).querySelectorAll(I);
    let re = ce(O) ? O : null;
    for (; re && !Xt(re); ) {
      const fe = Qt(re);
      if (Xt(fe) || !ce(fe))
        break;
      re = fe;
    }
    if (j.length && ce(O) && !FS(O) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Mr(O, o.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(j).every((fe) => !Mr(re, fe)))
      return;
    if (Ze(O) && F) {
      const fe = Xt(O), xe = st(O), ne = /auto|scroll/, oe = fe || ne.test(xe.overflowX), Xe = fe || ne.test(xe.overflowY), Ft = oe && O.clientWidth > 0 && O.scrollWidth > O.clientWidth, rr = Xe && O.clientHeight > 0 && O.scrollHeight > O.clientHeight, ol = xe.direction === "rtl", or = rr && (ol ? D.offsetX <= O.offsetWidth - O.clientWidth : D.offsetX > O.clientWidth), gy = Ft && D.offsetY > O.clientHeight;
      if (or || gy)
        return;
    }
    const q = (W = i.current.floatingContext) == null ? void 0 : W.nodeId, te = m && fi(m.nodesRef.current, q).some((fe) => {
      var xe;
      return Hl(D, (xe = fe.context) == null ? void 0 : xe.elements.floating);
    });
    if (Hl(D, o.floating) || Hl(D, o.domReference) || te)
      return;
    const Ye = m ? fi(m.nodesRef.current, q) : [];
    if (Ye.length > 0) {
      let fe = !0;
      if (Ye.forEach((xe) => {
        var ne;
        if ((ne = xe.context) != null && ne.open && !xe.context.dataRef.current.__outsidePressBubbles) {
          fe = !1;
          return;
        }
      }), !fe)
        return;
    }
    r(!1, D, "outside-press");
  }), P = Rt((D) => {
    var W;
    const $ = () => {
      var H;
      T(D), (H = pr(D)) == null || H.removeEventListener(c, $);
    };
    (W = pr(D)) == null || W.addEventListener(c, $);
  });
  y.useEffect(() => {
    if (!n || !s)
      return;
    i.current.__escapeKeyBubbles = S, i.current.__outsidePressBubbles = w;
    let D = -1;
    function W(j) {
      r(!1, j, "ancestor-scroll");
    }
    function $() {
      window.clearTimeout(D), E.current = !0;
    }
    function H() {
      D = window.setTimeout(
        () => {
          E.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        _s() ? 5 : 0
      );
    }
    const O = Ot(o.floating);
    l && (O.addEventListener("keydown", x ? N : M, x), O.addEventListener("compositionstart", $), O.addEventListener("compositionend", H)), C && O.addEventListener(c, k ? P : T, k);
    let I = [];
    return f && (ce(o.domReference) && (I = xn(o.domReference)), ce(o.floating) && (I = I.concat(xn(o.floating))), !ce(o.reference) && o.reference && o.reference.contextElement && (I = I.concat(xn(o.reference.contextElement)))), I = I.filter((j) => {
      var re;
      return j !== ((re = O.defaultView) == null ? void 0 : re.visualViewport);
    }), I.forEach((j) => {
      j.addEventListener("scroll", W, {
        passive: !0
      });
    }), () => {
      l && (O.removeEventListener("keydown", x ? N : M, x), O.removeEventListener("compositionstart", $), O.removeEventListener("compositionend", H)), C && O.removeEventListener(c, k ? P : T, k), I.forEach((j) => {
        j.removeEventListener("scroll", W);
      }), window.clearTimeout(D);
    };
  }, [i, o, l, C, c, n, r, f, s, S, w, M, x, N, T, k, P]), y.useEffect(() => {
    i.current.insideReactTree = !1;
  }, [i, C, c]);
  const _ = y.useMemo(() => ({
    onKeyDown: M,
    ...u && {
      [Zx[d]]: (D) => {
        r(!1, D.nativeEvent, "reference-press");
      },
      ...d !== "click" && {
        onClick(D) {
          r(!1, D.nativeEvent, "reference-press");
        }
      }
    }
  }), [M, r, u, d]), F = y.useMemo(() => ({
    onKeyDown: M,
    onMouseDown() {
      v.current = !0;
    },
    onMouseUp() {
      v.current = !0;
    },
    [Jx[c]]: () => {
      i.current.insideReactTree = !0;
    }
  }), [M, c, i]);
  return y.useMemo(() => s ? {
    reference: _,
    floating: F
  } : {}, [s, _, F]);
}
function Xx(t) {
  const {
    open: e = !1,
    onOpenChange: n,
    elements: r
  } = t, o = du(), i = y.useRef({}), [s] = y.useState(() => zx()), l = fu() != null;
  if (process.env.NODE_ENV !== "production") {
    const h = r.reference;
    h && !ce(h) && _x("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [a, c] = y.useState(r.reference), u = Rt((h, p, m) => {
    i.current.openEvent = h ? p : void 0, s.emit("openchange", {
      open: h,
      event: p,
      reason: m,
      nested: l
    }), n?.(h, p, m);
  }), d = y.useMemo(() => ({
    setPositionReference: c
  }), []), f = y.useMemo(() => ({
    reference: a || r.reference || null,
    floating: r.floating || null,
    domReference: r.reference
  }), [a, r.reference, r.floating]);
  return y.useMemo(() => ({
    dataRef: i,
    open: e,
    onOpenChange: u,
    elements: f,
    events: s,
    floatingId: o,
    refs: d
  }), [e, u, f, s, o, d]);
}
function Qx(t) {
  t === void 0 && (t = {});
  const {
    nodeId: e
  } = t, n = Xx({
    ...t,
    elements: {
      reference: null,
      floating: null,
      ...t.elements
    }
  }), r = t.rootContext || n, o = r.elements, [i, s] = y.useState(null), [l, a] = y.useState(null), u = o?.domReference || i, d = y.useRef(null), f = hu();
  mt(() => {
    u && (d.current = u);
  }, [u]);
  const h = rg({
    ...t,
    elements: {
      ...o,
      ...l && {
        reference: l
      }
    }
  }), p = y.useCallback((S) => {
    const w = ce(S) ? {
      getBoundingClientRect: () => S.getBoundingClientRect(),
      getClientRects: () => S.getClientRects(),
      contextElement: S
    } : S;
    a(w), h.refs.setReference(w);
  }, [h.refs]), m = y.useCallback((S) => {
    (ce(S) || S === null) && (d.current = S, s(S)), (ce(h.refs.reference.current) || h.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    S !== null && !ce(S)) && h.refs.setReference(S);
  }, [h.refs]), b = y.useMemo(() => ({
    ...h.refs,
    setReference: m,
    setPositionReference: p,
    domReference: d
  }), [h.refs, m, p]), C = y.useMemo(() => ({
    ...h.elements,
    domReference: u
  }), [h.elements, u]), v = y.useMemo(() => ({
    ...h,
    ...r,
    refs: b,
    elements: C,
    nodeId: e
  }), [h, b, C, e, r]);
  return mt(() => {
    r.dataRef.current.floatingContext = v;
    const S = f?.nodesRef.current.find((w) => w.id === e);
    S && (S.context = v);
  }), y.useMemo(() => ({
    ...h,
    context: v,
    refs: b,
    elements: C
  }), [h, b, C, v]);
}
function Ul() {
  return PS() && $1();
}
function e9(t, e) {
  e === void 0 && (e = {});
  const {
    open: n,
    onOpenChange: r,
    events: o,
    dataRef: i,
    elements: s
  } = t, {
    enabled: l = !0,
    visibleOnly: a = !0
  } = e, c = y.useRef(!1), u = y.useRef(-1), d = y.useRef(!0);
  y.useEffect(() => {
    if (!l) return;
    const h = Ke(s.domReference);
    function p() {
      !n && Ze(s.domReference) && s.domReference === $a(Ot(s.domReference)) && (c.current = !0);
    }
    function m() {
      d.current = !0;
    }
    function b() {
      d.current = !1;
    }
    return h.addEventListener("blur", p), Ul() && (h.addEventListener("keydown", m, !0), h.addEventListener("pointerdown", b, !0)), () => {
      h.removeEventListener("blur", p), Ul() && (h.removeEventListener("keydown", m, !0), h.removeEventListener("pointerdown", b, !0));
    };
  }, [s.domReference, n, l]), y.useEffect(() => {
    if (!l) return;
    function h(p) {
      let {
        reason: m
      } = p;
      (m === "reference-press" || m === "escape-key") && (c.current = !0);
    }
    return o.on("openchange", h), () => {
      o.off("openchange", h);
    };
  }, [o, l]), y.useEffect(() => () => {
    et(u);
  }, []);
  const f = y.useMemo(() => ({
    onMouseLeave() {
      c.current = !1;
    },
    onFocus(h) {
      if (c.current) return;
      const p = pr(h.nativeEvent);
      if (a && ce(p)) {
        if (Ul() && !h.relatedTarget) {
          if (!d.current && !_S(p))
            return;
        } else if (!zS(p))
          return;
      }
      r(!0, h.nativeEvent, "focus");
    },
    onBlur(h) {
      c.current = !1;
      const p = h.relatedTarget, m = h.nativeEvent, b = ce(p) && p.hasAttribute(ko("focus-guard")) && p.getAttribute("data-type") === "outside";
      u.current = window.setTimeout(() => {
        var C;
        const v = $a(s.domReference ? s.domReference.ownerDocument : document);
        !p && v === s.domReference || Mr((C = i.current.floatingContext) == null ? void 0 : C.refs.floating.current, v) || Mr(s.domReference, v) || b || r(!1, m, "focus");
      });
    }
  }), [i, s.domReference, r, a]);
  return y.useMemo(() => l ? {
    reference: f
  } : {}, [l, f]);
}
function Wl(t, e, n) {
  const r = /* @__PURE__ */ new Map(), o = n === "item";
  let i = t;
  if (o && t) {
    const {
      [oh]: s,
      [ih]: l,
      ...a
    } = t;
    i = a;
  }
  return {
    ...n === "floating" && {
      tabIndex: -1,
      [Dx]: ""
    },
    ...i,
    ...e.map((s) => {
      const l = s ? s[n] : null;
      return typeof l == "function" ? t ? l(t) : null : l;
    }).concat(t).reduce((s, l) => (l && Object.entries(l).forEach((a) => {
      let [c, u] = a;
      if (!(o && [oh, ih].includes(c)))
        if (c.indexOf("on") === 0) {
          if (r.has(c) || r.set(c, []), typeof u == "function") {
            var d;
            (d = r.get(c)) == null || d.push(u), s[c] = function() {
              for (var f, h = arguments.length, p = new Array(h), m = 0; m < h; m++)
                p[m] = arguments[m];
              return (f = r.get(c)) == null ? void 0 : f.map((b) => b(...p)).find((b) => b !== void 0);
            };
          }
        } else
          s[c] = u;
    }), s), {})
  };
}
function t9(t) {
  t === void 0 && (t = []);
  const e = t.map((l) => l?.reference), n = t.map((l) => l?.floating), r = t.map((l) => l?.item), o = y.useCallback(
    (l) => Wl(l, t, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e
  ), i = y.useCallback(
    (l) => Wl(l, t, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  ), s = y.useCallback(
    (l) => Wl(l, t, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    r
  );
  return y.useMemo(() => ({
    getReferenceProps: o,
    getFloatingProps: i,
    getItemProps: s
  }), [o, i, s]);
}
const n9 = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function r9(t, e) {
  var n, r;
  e === void 0 && (e = {});
  const {
    open: o,
    elements: i,
    floatingId: s
  } = t, {
    enabled: l = !0,
    role: a = "dialog"
  } = e, c = du(), u = ((n = i.domReference) == null ? void 0 : n.id) || c, d = y.useMemo(() => {
    var v;
    return ((v = VS(i.floating)) == null ? void 0 : v.id) || s;
  }, [i.floating, s]), f = (r = n9.get(a)) != null ? r : a, p = fu() != null, m = y.useMemo(() => f === "tooltip" || a === "label" ? {
    ["aria-" + (a === "label" ? "labelledby" : "describedby")]: o ? d : void 0
  } : {
    "aria-expanded": o ? "true" : "false",
    "aria-haspopup": f === "alertdialog" ? "dialog" : f,
    "aria-controls": o ? d : void 0,
    ...f === "listbox" && {
      role: "combobox"
    },
    ...f === "menu" && {
      id: u
    },
    ...f === "menu" && p && {
      role: "menuitem"
    },
    ...a === "select" && {
      "aria-autocomplete": "none"
    },
    ...a === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [f, d, p, o, u, a]), b = y.useMemo(() => {
    const v = {
      id: d,
      ...f && {
        role: f
      }
    };
    return f === "tooltip" || a === "label" ? v : {
      ...v,
      ...f === "menu" && {
        "aria-labelledby": u
      }
    };
  }, [f, d, u, a]), C = y.useCallback((v) => {
    let {
      active: S,
      selected: w
    } = v;
    const x = {
      role: "option",
      ...S && {
        id: d + "-fui-option"
      }
    };
    switch (a) {
      case "select":
      case "combobox":
        return {
          ...x,
          "aria-selected": w
        };
    }
    return {};
  }, [d, a]);
  return y.useMemo(() => l ? {
    reference: m,
    floating: b,
    item: C
  } : {}, [l, m, b, C]);
}
function o9({
  initialOpen: t = !1,
  placement: e = "top",
  open: n,
  onOpenChange: r,
  delay: o = 600,
  closeDelay: i = 0
} = {}) {
  const [s, l] = y.useState(t), a = n ?? s, c = r ?? l, u = Qx({
    placement: e,
    open: a,
    onOpenChange: c,
    whileElementsMounted: Q1,
    middleware: [
      og(4),
      sg({
        crossAxis: e.includes("-"),
        fallbackAxisSideDirection: "start",
        padding: 4
      }),
      ig({ padding: 4 })
    ]
  }), d = u.context, f = Ux(d, {
    mouseOnly: !0,
    move: !1,
    restMs: o,
    enabled: n == null,
    delay: {
      close: i
    }
  }), h = e9(d, {
    enabled: n == null
  }), p = Yx(d), m = r9(d, { role: "tooltip" }), b = t9([f, h, p, m]);
  return y.useMemo(
    () => ({
      open: a,
      setOpen: c,
      ...b,
      ...u
    }),
    [a, c, b, u]
  );
}
const Ka = y.createContext(null);
function ug() {
  const t = y.useContext(Ka);
  if (t == null)
    throw new Error(
      "Tooltip components must be wrapped in <TooltipProvider />"
    );
  return t;
}
function dg({ children: t, ...e }) {
  const n = o9(e);
  return e.useDelayGroup ? /* @__PURE__ */ g(
    Kx,
    {
      delay: { open: e.delay ?? 0, close: e.closeDelay ?? 0 },
      timeoutMs: e.timeout,
      children: /* @__PURE__ */ g(Ka.Provider, { value: n, children: t })
    }
  ) : /* @__PURE__ */ g(Ka.Provider, { value: n, children: t });
}
const fg = y.forwardRef(function({ children: e, asChild: n = !1, ...r }, o) {
  const i = ug(), s = y.isValidElement(e) ? parseInt(y.version, 10) >= 19 ? (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.props.ref
  ) : (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    e.ref
  ) : void 0, l = lg([i.refs.setReference, o, s]);
  if (n && y.isValidElement(e)) {
    const a = {
      "data-tooltip-state": i.open ? "open" : "closed"
    };
    return y.cloneElement(
      e,
      i.getReferenceProps({
        ref: l,
        ...r,
        ...typeof e.props == "object" ? e.props : {},
        ...a
      })
    );
  }
  return /* @__PURE__ */ g(
    "button",
    {
      ref: l,
      "data-tooltip-state": i.open ? "open" : "closed",
      ...i.getReferenceProps(r),
      children: e
    }
  );
}), hg = y.forwardRef(function({ style: e, children: n, portal: r = !0, portalProps: o = {}, ...i }, s) {
  const l = ug(), a = lg([l.refs.setFloating, s]);
  if (!l.open) return null;
  const c = /* @__PURE__ */ g(
    "div",
    {
      ref: a,
      style: {
        ...l.floatingStyles,
        ...e
      },
      ...l.getFloatingProps(i),
      className: "tiptap-tooltip",
      children: n
    }
  );
  return r ? /* @__PURE__ */ g(qx, { ...o, children: c }) : c;
});
dg.displayName = "Tooltip";
fg.displayName = "TooltipTrigger";
hg.displayName = "TooltipContent";
const ja = 5 * 1024 * 1024, i9 = {
  mod: "⌘",
  ctrl: "⌘",
  alt: "⌥",
  shift: "⇧",
  backspace: "Del"
};
function Re(...t) {
  return t.filter(Boolean).join(" ");
}
function s9() {
  return typeof navigator < "u" && navigator.platform.toLowerCase().includes("mac");
}
const l9 = (t, e, n = !0) => {
  if (e) {
    const r = t.toLowerCase();
    return i9[r] || (n ? t.toUpperCase() : t);
  }
  return n ? t.charAt(0).toUpperCase() + t.slice(1) : t;
}, at = (t) => {
  const { shortcutKeys: e, delimiter: n = "+", capitalize: r = !0 } = t;
  return e ? e.split(n).map((o) => o.trim()).map((o) => l9(o, s9(), r)) : [];
}, nn = (t, e) => e?.schema ? e.schema.spec.marks.get(t) !== void 0 : !1, rn = (t, e) => e?.schema ? e.schema.spec.nodes.get(t) !== void 0 : !1;
function Ht(t) {
  return typeof t == "number" && t >= 0;
}
function Eo(t, e) {
  if (!t) return !1;
  const n = Array.isArray(e) ? e : [e], r = n.some(
    (o) => t.extensionManager.extensions.some((i) => i.name === o)
  );
  return r || console.warn(
    `None of the extensions [${n.join(
      ", "
    )}] were found in the editor schema. Ensure they are included in the editor configuration.`
  ), r;
}
function a9(t, e) {
  try {
    const n = t.state.doc.nodeAt(e);
    return n || (console.warn(`No node found at position ${e}`), null);
  } catch (n) {
    return console.error(`Error getting node at position ${e}:`, n), null;
  }
}
function In(t) {
  const { editor: e, node: n, nodePos: r } = t;
  if (!e || !e.state?.doc) return null;
  const o = n != null, i = Ht(r);
  if (!o && !i)
    return null;
  if (o) {
    let s = -1, l = null;
    if (e.state.doc.descendants((a, c) => a === n ? (s = c, l = a, !1) : !0), s !== -1 && l !== null)
      return { pos: s, node: l };
  }
  if (i) {
    const s = a9(e, r);
    if (s)
      return { pos: r, node: s };
  }
  return null;
}
function wt(t, e = []) {
  if (!t || !t.state.selection) return !1;
  const { state: n } = t, { doc: r, selection: o } = n;
  if (o.empty) return !1;
  if (o instanceof z) {
    const i = r.nodeAt(o.from);
    return i ? e.includes(i.type.name) : !1;
  }
  return !1;
}
const c9 = async (t, e, n) => {
  if (!t)
    throw new Error("No file provided");
  if (t.size > ja)
    throw new Error(
      `File size exceeds maximum allowed (${ja / (1024 * 1024)}MB)`
    );
  for (let r = 0; r <= 100; r += 10) {
    if (n?.aborted)
      throw new Error("Upload cancelled");
    await new Promise((o) => setTimeout(o, 500)), e?.({ progress: r });
  }
  return URL.createObjectURL(t);
}, u9 = (
  // eslint-disable-next-line no-control-regex
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
);
function d9(t, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return !t || t.replace(u9, "").match(
    new RegExp(
      `^(?:(?:${n.join(
        "|"
      )}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
function f9(t, e, n) {
  try {
    const r = new URL(t, e);
    if (d9(r.href, n))
      return r.href;
  } catch {
  }
  return "#";
}
const h9 = ({
  shortcuts: t
}) => t.length === 0 ? null : /* @__PURE__ */ g("div", { children: t.map((e, n) => /* @__PURE__ */ R(y.Fragment, { children: [
  n > 0 && /* @__PURE__ */ g("kbd", { children: "+" }),
  /* @__PURE__ */ g("kbd", { children: e })
] }, n)) }), J = y.forwardRef(
  ({
    className: t,
    children: e,
    tooltip: n,
    showTooltip: r = !0,
    shortcutKeys: o,
    "aria-label": i,
    ...s
  }, l) => {
    const a = y.useMemo(
      () => at({ shortcutKeys: o }),
      [o]
    );
    return !n || !r ? /* @__PURE__ */ g(
      "button",
      {
        className: Re("tiptap-button", t),
        ref: l,
        "aria-label": i,
        ...s,
        children: e
      }
    ) : /* @__PURE__ */ R(dg, { delay: 200, children: [
      /* @__PURE__ */ g(
        fg,
        {
          className: Re("tiptap-button", t),
          ref: l,
          "aria-label": i,
          ...s,
          children: e
        }
      ),
      /* @__PURE__ */ R(hg, { children: [
        n,
        /* @__PURE__ */ g(h9, { shortcuts: a })
      ] })
    ] });
  }
);
J.displayName = "Button";
const lt = y.forwardRef(({ className: t, children: e, orientation: n = "vertical", ...r }, o) => /* @__PURE__ */ g(
  "div",
  {
    ref: o,
    className: Re("tiptap-button-group", t),
    "data-orientation": n,
    role: "group",
    ...r,
    children: e
  }
));
lt.displayName = "ButtonGroup";
const St = y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ g("div", { ref: n, className: Re("tiptap-card", t), ...e })
);
St.displayName = "Card";
const p9 = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g("div", { ref: n, className: Re("tiptap-card-header", t), ...e }));
p9.displayName = "CardHeader";
const xt = y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ g("div", { ref: n, className: Re("tiptap-card-body", t), ...e })
);
xt.displayName = "CardBody";
const Xn = y.forwardRef(({ className: t, orientation: e = "vertical", ...n }, r) => /* @__PURE__ */ g(
  "div",
  {
    ref: r,
    "data-orientation": e,
    className: Re("tiptap-card-item-group", t),
    ...n
  }
));
Xn.displayName = "CardItemGroup";
const m9 = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g(
  "div",
  {
    ref: n,
    className: Re("tiptap-card-group-label", t),
    ...e
  }
));
m9.displayName = "CardGroupLabel";
const g9 = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ g("div", { ref: n, className: Re("tiptap-card-footer", t), ...e }));
g9.displayName = "CardFooter";
const he = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g("path", { d: "M3 3h18v18H3z" }),
        /* @__PURE__ */ g("path", { d: "M21 9H3" }),
        /* @__PURE__ */ g("path", { d: "M21 15H3" }),
        /* @__PURE__ */ g("path", { d: "M12 3v18" })
      ]
    }
  )
);
he.displayName = "TableIcon";
const kn = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M7 5V4C7 3.17477 7.40255 2.43324 7.91789 1.91789C8.43324 1.40255 9.17477 1 10 1H14C14.8252 1 15.5668 1.40255 16.0821 1.91789C16.5975 2.43324 17 3.17477 17 4V5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H20V20C20 20.8252 19.5975 21.5668 19.0821 22.0821C18.5668 22.5975 17.8252 23 17 23H7C6.17477 23 5.43324 22.5975 4.91789 22.0821C4.40255 21.5668 4 20.8252 4 20V7H3C2.44772 7 2 6.55228 2 6C2 5.44772 2.44772 5 3 5H7ZM9 4C9 3.82523 9.09745 3.56676 9.33211 3.33211C9.56676 3.09745 9.82523 3 10 3H14C14.1748 3 14.4332 3.09745 14.6679 3.33211C14.9025 3.56676 15 3.82523 15 4V5H9V4ZM6 7V20C6 20.1748 6.09745 20.4332 6.33211 20.6679C6.56676 20.9025 6.82523 21 7 21H17C17.1748 21 17.4332 20.9025 17.6679 20.6679C17.9025 20.4332 18 20.1748 18 20V7H6Z",
          fill: "currentColor"
        }
      )
    }
  )
);
kn.displayName = "TrashIcon";
const qa = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g("circle", { cx: "12", cy: "12", r: "1" }),
        /* @__PURE__ */ g("circle", { cx: "19", cy: "12", r: "1" }),
        /* @__PURE__ */ g("circle", { cx: "5", cy: "12", r: "1" })
      ]
    }
  )
);
qa.displayName = "MoreHorizontalIcon";
const y9 = ({
  editor: t,
  node: e,
  getPos: n
}) => {
  const r = Nt(null), o = Nt(null), [i, s] = Xr({
    showControls: !0,
    activeMenu: null,
    activePosition: null,
    menuPosition: { x: 0, y: 0 }
  }), [l, a] = Xr(!1);
  Zt(() => {
    const w = () => {
      const x = n();
      if (x === void 0) return;
      const { selection: k } = t.state, E = x, M = x + e.nodeSize, N = k.from >= E && k.to <= M && (k.from !== k.to || k.from > E && k.to < M);
      a(N);
    };
    return w(), t.on("selectionUpdate", w), () => {
      t.off("selectionUpdate", w);
    };
  }, [t, e, n]);
  const c = Pn(
    (w, x) => {
      if (!r.current) return !1;
      const k = r.current.querySelector("table");
      if (!k) return !1;
      try {
        const E = Array.from(k.querySelectorAll("tr"));
        if (w >= E.length) return !1;
        const M = Array.from(E[w].querySelectorAll("td, th"));
        if (x >= M.length) return !1;
        const N = M[x];
        if (!N) return !1;
        const T = t.view.posAtDOM(N, 0);
        if (T >= 0)
          return t.commands.setTextSelection(T), !0;
      } catch (E) {
        console.warn("Failed to set cursor to cell:", E);
      }
      return !1;
    },
    [t]
  ), u = Pn(() => {
    s((w) => ({
      ...w,
      activeMenu: null,
      activePosition: null
    }));
  }, []), d = Pn(
    (w, x) => {
      if (!r.current) return { x: 0, y: 0 };
      const k = w.getBoundingClientRect();
      if (k.bottom < 0 || k.top > window.innerHeight || k.right < 0 || k.left > window.innerWidth)
        return u(), { x: 0, y: 0 };
      const E = window.innerWidth, M = window.innerHeight, N = 200, T = 142, P = 4;
      let _, F;
      return x === "column" ? (_ = k.left + k.width / 2 - N / 2, F = k.top - T - 5, _ + N > E - P && (_ = k.right - N), _ < P && (_ = P), F < P && (F = k.bottom + 5)) : (_ = k.left - N - 5, F = k.top + k.height / 2 - T / 2, _ < P && (_ = k.right + 5), F < P && (F = P), F + T > M - P && (F = M - T - P)), {
        x: Math.max(P, Math.min(_, E - N - P)),
        y: Math.max(P, Math.min(F, M - T - P))
      };
    },
    []
  ), f = Pn(
    (w, x) => {
      switch (x && c(x.rowIndex, x.colIndex), w) {
        case "addColumnBefore":
          t.chain().focus().addColumnBefore().run();
          break;
        case "addColumnAfter":
          t.chain().focus().addColumnAfter().run();
          break;
        case "deleteColumn":
          t.chain().focus().deleteColumn().run();
          break;
        case "addRowBefore":
          t.chain().focus().addRowBefore().run();
          break;
        case "addRowAfter":
          t.chain().focus().addRowAfter().run();
          break;
        case "deleteRow":
          t.chain().focus().deleteRow().run();
          break;
        case "toggleHeaderRow":
          t.chain().focus().toggleHeaderRow().run();
          break;
        case "toggleHeaderColumn":
          t.chain().focus().toggleHeaderColumn().run();
          break;
        case "deleteTable":
          t.chain().focus().deleteTable().run();
          break;
      }
      u();
    },
    [t, c, u]
  ), h = Pn(
    (w, x) => {
      if (x.preventDefault(), i.activeMenu === "column" && i.activePosition?.colIndex === w) {
        u();
        return;
      }
      const k = d(
        x.target,
        "column"
      );
      s((E) => ({
        ...E,
        activeMenu: "column",
        activePosition: { rowIndex: 0, colIndex: w },
        menuPosition: k
      }));
    },
    [
      i.activeMenu,
      i.activePosition?.colIndex,
      u,
      d
    ]
  ), p = Pn(
    (w, x) => {
      if (x.preventDefault(), x.stopPropagation(), i.activeMenu === "row" && i.activePosition?.rowIndex === w) {
        u();
        return;
      }
      const k = d(
        x.target,
        "row"
      );
      s((E) => ({
        ...E,
        activeMenu: "row",
        activePosition: { rowIndex: w, colIndex: 0 },
        menuPosition: k
      }));
    },
    [
      i.activeMenu,
      i.activePosition?.rowIndex,
      u,
      d
    ]
  );
  Zt(() => {
    const w = (k) => {
      const E = k.target, M = E instanceof Element;
      i.activeMenu && o.current && !o.current.contains(E) && !(M && E.closest(".table-node-control")) && u();
    }, x = (k) => {
      k.key === "Escape" && i.activeMenu && u();
    };
    if (i.activeMenu)
      return document.addEventListener("mousedown", w), document.addEventListener("keydown", x), window.addEventListener("resize", u), () => {
        document.removeEventListener("mousedown", w), document.removeEventListener("keydown", x), window.removeEventListener("resize", u);
      };
  }, [i.activeMenu, u]), Zt(() => {
    if (i.activeMenu) {
      const w = document.body.style.overflow;
      return document.body.style.overflow = "hidden", () => {
        document.body.style.overflow = w;
      };
    }
  }, [i.activeMenu]);
  const m = () => {
    if (!r.current || !i.showControls) return null;
    const w = r.current.querySelector("table");
    if (!w) return null;
    const x = w.querySelector("tr");
    if (!x) return null;
    const k = Array.from(x.querySelectorAll("th, td")), E = w.getBoundingClientRect();
    return k.map((M, N) => {
      const T = M.getBoundingClientRect(), P = T.left - E.left + T.width / 2 - 10;
      return /* @__PURE__ */ g(
        J,
        {
          className: `table-node-control table-node-control--column ${l ? "table-node-control--selected" : ""}`,
          style: {
            left: P,
            top: -8
          },
          onClick: (_) => h(N, _),
          title: "Column actions",
          children: /* @__PURE__ */ g(qa, { className: "tiptap-button-icon" })
        },
        `col-${N}`
      );
    });
  }, b = () => {
    if (!r.current || !i.showControls) return null;
    const w = r.current.querySelector("table");
    if (!w) return null;
    const x = Array.from(w.querySelectorAll("tr")), k = w.getBoundingClientRect();
    return x.map((E, M) => {
      const N = E.getBoundingClientRect(), T = N.top - k.top + N.height / 2 - 8;
      return /* @__PURE__ */ g(
        J,
        {
          className: `table-node-control table-node-control--row ${l ? "table-node-control--selected" : ""}`,
          style: {
            left: -10,
            top: T
          },
          onClick: (P) => p(M, P),
          title: "Row actions",
          children: /* @__PURE__ */ g(qa, { className: "tiptap-button-icon" })
        },
        `row-${M}`
      );
    });
  }, C = () => {
    if (!i.activeMenu || !i.activePosition) return null;
    const w = i.activeMenu === "column" ? [
      {
        action: "addColumnBefore",
        label: "Add column before",
        icon: he
      },
      {
        action: "addColumnAfter",
        label: "Add column after",
        icon: he
      },
      {
        action: "toggleHeaderColumn",
        label: "Toggle header column",
        icon: he
      },
      { action: "deleteColumn", label: "Delete column", icon: kn }
    ] : [
      {
        action: "addRowBefore",
        label: "Add row before",
        icon: he
      },
      { action: "addRowAfter", label: "Add row after", icon: he },
      {
        action: "toggleHeaderRow",
        label: "Toggle header row",
        icon: he
      },
      { action: "deleteRow", label: "Delete row", icon: kn }
    ];
    return /* @__PURE__ */ g(
      "div",
      {
        ref: o,
        className: "table-node-menu",
        style: {
          position: "fixed",
          left: i.menuPosition.x,
          top: i.menuPosition.y,
          zIndex: 1e3,
          width: "12.5rem"
          // 200px
        },
        children: /* @__PURE__ */ g(St, { "data-style": "popover", children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { orientation: "vertical", children: w.map((x) => /* @__PURE__ */ R(
          J,
          {
            "data-style": "ghost",
            onClick: () => f(x.action, i.activePosition),
            className: "table-node-action",
            title: x.label,
            children: [
              /* @__PURE__ */ g(x.icon, { className: "tiptap-button-icon" }),
              /* @__PURE__ */ g("span", { children: x.label })
            ]
          },
          x.action
        )) }) }) })
      }
    );
  }, v = () => {
    if (!r.current) return 0;
    const w = r.current.querySelector("table");
    if (!w) return 0;
    const x = w.querySelector("tr");
    return x ? x.querySelectorAll("th, td").length : 0;
  }, S = () => {
    const w = v();
    return w === 0 ? null : /* @__PURE__ */ g("colgroup", { children: Array.from({ length: w }, (x, k) => /* @__PURE__ */ g("col", { className: "table-col" }, `col-${k}`)) });
  };
  return /* @__PURE__ */ R(Ls, { className: "table-node-wrapper", ref: r, children: [
    /* @__PURE__ */ R("div", { className: "table-node-container", children: [
      m(),
      b(),
      /* @__PURE__ */ R("table", { children: [
        S(),
        /* @__PURE__ */ g(N7, { as: "tbody" })
      ] })
    ] }),
    C()
  ] });
};
function hh({
  orientation: t = "horizontal",
  size: e,
  style: n = {},
  ...r
}) {
  const o = {
    ...n,
    ...t === "horizontal" && !e && { flex: 1 },
    ...e && {
      width: t === "vertical" ? "1px" : e,
      height: t === "horizontal" ? "1px" : e
    }
  };
  return /* @__PURE__ */ g("div", { ...r, style: o });
}
const Ir = y.forwardRef(
  ({ decorative: t, orientation: e = "vertical", className: n, ...r }, o) => {
    const s = t ? { role: "none" } : { "aria-orientation": e === "vertical" ? e : void 0, role: "separator" };
    return /* @__PURE__ */ g(
      "div",
      {
        className: Re("tiptap-separator", n),
        "data-orientation": e,
        ...s,
        ...r,
        ref: o
      }
    );
  }
);
Ir.displayName = "Separator";
function pg({
  editor: t,
  containerRef: e,
  query: n,
  items: r,
  onSelect: o,
  onClose: i,
  orientation: s = "vertical",
  autoSelectFirstItem: l = !0
}) {
  const [a, c] = y.useState(
    l ? 0 : -1
  );
  return y.useEffect(() => {
    const u = (f) => {
      if (!r.length) return !1;
      const h = () => c((m) => m === -1 ? 0 : (m + 1) % r.length), p = () => c((m) => m === -1 ? r.length - 1 : (m - 1 + r.length) % r.length);
      switch (f.key) {
        case "ArrowUp":
          return s === "horizontal" ? !1 : (f.preventDefault(), p(), !0);
        case "ArrowDown":
          return s === "horizontal" ? !1 : (f.preventDefault(), h(), !0);
        case "ArrowLeft":
          return s === "vertical" ? !1 : (f.preventDefault(), p(), !0);
        case "ArrowRight":
          return s === "vertical" ? !1 : (f.preventDefault(), h(), !0);
        case "Tab":
          return f.preventDefault(), f.shiftKey ? p() : h(), !0;
        case "Home":
          return f.preventDefault(), c(0), !0;
        case "End":
          return f.preventDefault(), c(r.length - 1), !0;
        case "Enter":
          return f.isComposing ? !1 : (f.preventDefault(), a !== -1 && r[a] && o?.(r[a]), !0);
        case "Escape":
          return f.preventDefault(), i?.(), !0;
        default:
          return !1;
      }
    };
    let d = null;
    if (t ? d = t.view.dom : e?.current && (d = e.current), d)
      return d.addEventListener("keydown", u, !0), () => {
        d?.removeEventListener(
          "keydown",
          u,
          !0
        );
      };
  }, [
    t,
    e,
    r,
    a,
    o,
    i,
    s
  ]), y.useEffect(() => {
    n && c(l ? 0 : -1);
  }, [n, l]), {
    selectedIndex: r.length ? a : void 0,
    setSelectedIndex: c
  };
}
const ph = (t, e) => {
  typeof t == "function" ? t(e) : t && typeof t == "object" && "current" in t && (t.current = e);
}, b9 = (t, e) => {
  const n = y.useRef(null);
  return y.useCallback(
    (r) => {
      t && "current" in t && (t.current = r), n.current && ph(n.current, null), n.current = e, e && ph(e, r);
    },
    [t, e]
  );
}, C9 = (t) => {
  const [e, n] = y.useState([]), r = y.useCallback(() => t.current ? Array.from(
    t.current.querySelectorAll(
      'button:not([disabled]), [role="button"]:not([disabled]), [tabindex="0"]:not([disabled])'
    )
  ) : [], [t]);
  y.useEffect(() => {
    const i = t.current;
    if (!i) return;
    const s = () => n(r());
    s();
    const l = new MutationObserver(s);
    return l.observe(i, { childList: !0, subtree: !0 }), () => l.disconnect();
  }, [r, t]);
  const { selectedIndex: o } = pg({
    containerRef: t,
    items: e,
    orientation: "horizontal",
    onSelect: (i) => i.click(),
    autoSelectFirstItem: !1
  });
  y.useEffect(() => {
    const i = t.current;
    if (!i) return;
    const s = (a) => {
      const c = a.target;
      i.contains(c) && c.setAttribute("data-focus-visible", "true");
    }, l = (a) => {
      const c = a.target;
      i.contains(c) && c.removeAttribute("data-focus-visible");
    };
    return i.addEventListener("focus", s, !0), i.addEventListener("blur", l, !0), () => {
      i.removeEventListener("focus", s, !0), i.removeEventListener("blur", l, !0);
    };
  }, [t]), y.useEffect(() => {
    o !== void 0 && e[o] && e[o].focus();
  }, [o, e]);
}, mg = y.forwardRef(
  ({ children: t, className: e, variant: n = "fixed", ...r }, o) => {
    const i = y.useRef(null), s = b9(i, o);
    return C9(i), /* @__PURE__ */ g(
      "div",
      {
        ref: s,
        role: "toolbar",
        "aria-label": "toolbar",
        "data-variant": n,
        className: Re("tiptap-toolbar", e),
        ...r,
        children: t
      }
    );
  }
);
mg.displayName = "Toolbar";
const Mt = y.forwardRef(
  ({ children: t, className: e, ...n }, r) => /* @__PURE__ */ g(
    "div",
    {
      ref: r,
      role: "group",
      className: Re("tiptap-toolbar-group", e),
      ...n,
      children: t
    }
  )
);
Mt.displayName = "ToolbarGroup";
const Tt = y.forwardRef(
  ({ ...t }, e) => /* @__PURE__ */ g(Ir, { ref: e, orientation: "vertical", decorative: !0, ...t })
);
Tt.displayName = "ToolbarSeparator";
const gg = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z",
          fill: "currentColor"
        }
      )
    }
  )
);
gg.displayName = "CloseIcon";
function v9(t) {
  const [e, n] = y.useState([]), r = async (l) => {
    if (l.size > t.maxSize) {
      const d = new Error(
        `File size exceeds maximum allowed (${t.maxSize / 1024 / 1024}MB)`
      );
      return t.onError?.(d), null;
    }
    const a = new AbortController(), c = crypto.randomUUID(), u = {
      id: c,
      file: l,
      progress: 0,
      status: "uploading",
      abortController: a
    };
    n((d) => [...d, u]);
    try {
      if (!t.upload)
        throw new Error("Upload function is not defined");
      const d = await t.upload(
        l,
        (f) => {
          n(
            (h) => h.map(
              (p) => p.id === c ? { ...p, progress: f.progress } : p
            )
          );
        },
        a.signal
      );
      if (!d) throw new Error("Upload failed: No URL returned");
      return a.signal.aborted ? null : (n(
        (f) => f.map(
          (h) => h.id === c ? { ...h, status: "success", url: d, progress: 100 } : h
        )
      ), t.onSuccess?.(d), d);
    } catch (d) {
      return a.signal.aborted || (n(
        (f) => f.map(
          (h) => h.id === c ? { ...h, status: "error", progress: 0 } : h
        )
      ), t.onError?.(
        d instanceof Error ? d : new Error("Upload failed")
      )), null;
    }
  };
  return {
    fileItems: e,
    uploadFiles: async (l) => {
      if (!l || l.length === 0)
        return t.onError?.(new Error("No files to upload")), [];
      if (t.limit && l.length > t.limit)
        return t.onError?.(
          new Error(
            `Maximum ${t.limit} file${t.limit === 1 ? "" : "s"} allowed`
          )
        ), [];
      const a = l.map((u) => r(u));
      return (await Promise.all(a)).filter((u) => u !== null);
    },
    removeFileItem: (l) => {
      n((a) => {
        const c = a.find((u) => u.id === l);
        return c?.abortController && c.abortController.abort(), c?.url && URL.revokeObjectURL(c.url), a.filter((u) => u.id !== l);
      });
    },
    clearAllFiles: () => {
      e.forEach((l) => {
        l.abortController && l.abortController.abort(), l.url && URL.revokeObjectURL(l.url);
      }), n([]);
    }
  };
}
const yg = () => /* @__PURE__ */ R(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    className: "tiptap-image-upload-icon",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      /* @__PURE__ */ g(
        "path",
        {
          d: "M11.1953 4.41771C10.3478 4.08499 9.43578 3.94949 8.5282 4.02147C7.62062 4.09345 6.74133 4.37102 5.95691 4.83316C5.1725 5.2953 4.50354 5.92989 4.00071 6.68886C3.49788 7.44783 3.17436 8.31128 3.05465 9.2138C2.93495 10.1163 3.0222 11.0343 3.3098 11.8981C3.5974 12.7619 4.07781 13.5489 4.71463 14.1995C5.10094 14.5942 5.09414 15.2274 4.69945 15.6137C4.30476 16 3.67163 15.9932 3.28532 15.5985C2.43622 14.731 1.79568 13.6816 1.41221 12.5299C1.02875 11.3781 0.91241 10.1542 1.07201 8.95084C1.23162 7.74748 1.66298 6.59621 2.33343 5.58425C3.00387 4.57229 3.89581 3.72617 4.9417 3.10998C5.98758 2.4938 7.15998 2.1237 8.37008 2.02773C9.58018 1.93176 10.7963 2.11243 11.9262 2.55605C13.0561 2.99968 14.0703 3.69462 14.8919 4.58825C15.5423 5.29573 16.0585 6.11304 16.4177 7.00002H17.4999C18.6799 6.99991 19.8288 7.37933 20.7766 8.08222C21.7245 8.78515 22.4212 9.7743 22.7637 10.9036C23.1062 12.0328 23.0765 13.2423 22.6788 14.3534C22.2812 15.4644 21.5367 16.4181 20.5554 17.0736C20.0962 17.3803 19.4752 17.2567 19.1684 16.7975C18.8617 16.3382 18.9853 15.7172 19.4445 15.4105C20.069 14.9934 20.5427 14.3865 20.7958 13.6794C21.0488 12.9724 21.0678 12.2027 20.8498 11.4841C20.6318 10.7655 20.1885 10.136 19.5853 9.6887C18.9821 9.24138 18.251 8.99993 17.5001 9.00002H15.71C15.2679 9.00002 14.8783 8.70973 14.7518 8.28611C14.4913 7.41374 14.0357 6.61208 13.4195 5.94186C12.8034 5.27164 12.0427 4.75043 11.1953 4.41771Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M11 14.4142V21C11 21.5523 11.4477 22 12 22C12.5523 22 13 21.5523 13 21V14.4142L15.2929 16.7071C15.6834 17.0976 16.3166 17.0976 16.7071 16.7071C17.0976 16.3166 17.0976 15.6834 16.7071 15.2929L12.7078 11.2936C12.7054 11.2912 12.703 11.2888 12.7005 11.2864C12.5208 11.1099 12.2746 11.0008 12.003 11L12 11L11.997 11C11.8625 11.0004 11.7343 11.0273 11.6172 11.0759C11.502 11.1236 11.3938 11.1937 11.2995 11.2864C11.297 11.2888 11.2946 11.2912 11.2922 11.2936L7.29289 15.2929C6.90237 15.6834 6.90237 16.3166 7.29289 16.7071C7.68342 17.0976 8.31658 17.0976 8.70711 16.7071L11 14.4142Z",
          fill: "currentColor"
        }
      )
    ]
  }
), w9 = () => /* @__PURE__ */ g(
  "svg",
  {
    width: "43",
    height: "57",
    viewBox: "0 0 43 57",
    fill: "currentColor",
    className: "tiptap-image-upload-dropzone-rect-primary",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ g(
      "path",
      {
        d: "M0.75 10.75C0.75 5.64137 4.89137 1.5 10 1.5H32.3431C33.2051 1.5 34.0317 1.84241 34.6412 2.4519L40.2981 8.10876C40.9076 8.71825 41.25 9.5449 41.25 10.4069V46.75C41.25 51.8586 37.1086 56 32 56H10C4.89137 56 0.75 51.8586 0.75 46.75V10.75Z",
        fill: "currentColor",
        fillOpacity: "0.11",
        stroke: "currentColor",
        strokeWidth: "1.5"
      }
    )
  }
), S9 = () => /* @__PURE__ */ g(
  "svg",
  {
    width: "10",
    height: "10",
    className: "tiptap-image-upload-dropzone-rect-secondary",
    viewBox: "0 0 10 10",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ g(
      "path",
      {
        d: "M0 0.75H0.343146C1.40401 0.75 2.42143 1.17143 3.17157 1.92157L8.82843 7.57843C9.57857 8.32857 10 9.34599 10 10.4069V10.75H4C1.79086 10.75 0 8.95914 0 6.75V0.75Z",
        fill: "currentColor"
      }
    )
  }
), x9 = ({
  onFile: t,
  children: e
}) => {
  const [n, r] = y.useState(!1), [o, i] = y.useState(!1);
  return /* @__PURE__ */ g(
    "div",
    {
      className: `tiptap-image-upload-drag-area ${o ? "drag-active" : ""} ${n ? "drag-over" : ""}`,
      onDragEnter: (u) => {
        u.preventDefault(), u.stopPropagation(), i(!0);
      },
      onDragLeave: (u) => {
        u.preventDefault(), u.stopPropagation(), u.currentTarget.contains(u.relatedTarget) || (i(!1), r(!1));
      },
      onDragOver: (u) => {
        u.preventDefault(), u.stopPropagation(), r(!0);
      },
      onDrop: (u) => {
        u.preventDefault(), u.stopPropagation(), i(!1), r(!1);
        const d = Array.from(u.dataTransfer.files);
        d.length > 0 && t(d);
      },
      children: e
    }
  );
}, k9 = ({
  fileItem: t,
  onRemove: e
}) => {
  const n = (r) => {
    if (r === 0) return "0 Bytes";
    const o = 1024, i = ["Bytes", "KB", "MB", "GB"], s = Math.floor(Math.log(r) / Math.log(o));
    return `${parseFloat((r / Math.pow(o, s)).toFixed(2))} ${i[s]}`;
  };
  return /* @__PURE__ */ R("div", { className: "tiptap-image-upload-preview", children: [
    t.status === "uploading" && /* @__PURE__ */ g(
      "div",
      {
        className: "tiptap-image-upload-progress",
        style: { width: `${t.progress}%` }
      }
    ),
    /* @__PURE__ */ R("div", { className: "tiptap-image-upload-preview-content", children: [
      /* @__PURE__ */ R("div", { className: "tiptap-image-upload-file-info", children: [
        /* @__PURE__ */ g("div", { className: "tiptap-image-upload-file-icon", children: /* @__PURE__ */ g(yg, {}) }),
        /* @__PURE__ */ R("div", { className: "tiptap-image-upload-details", children: [
          /* @__PURE__ */ g("span", { className: "tiptap-image-upload-text", children: t.file.name }),
          /* @__PURE__ */ g("span", { className: "tiptap-image-upload-subtext", children: n(t.file.size) })
        ] })
      ] }),
      /* @__PURE__ */ R("div", { className: "tiptap-image-upload-actions", children: [
        t.status === "uploading" && /* @__PURE__ */ R("span", { className: "tiptap-image-upload-progress-text", children: [
          t.progress,
          "%"
        ] }),
        /* @__PURE__ */ g(
          J,
          {
            type: "button",
            "data-style": "ghost",
            onClick: (r) => {
              r.stopPropagation(), e();
            },
            children: /* @__PURE__ */ g(gg, { className: "tiptap-button-icon" })
          }
        )
      ] })
    ] })
  ] });
}, E9 = ({
  maxSize: t,
  limit: e
}) => /* @__PURE__ */ R(le, { children: [
  /* @__PURE__ */ R("div", { className: "tiptap-image-upload-dropzone", children: [
    /* @__PURE__ */ g(w9, {}),
    /* @__PURE__ */ g(S9, {}),
    /* @__PURE__ */ g("div", { className: "tiptap-image-upload-icon-container", children: /* @__PURE__ */ g(yg, {}) })
  ] }),
  /* @__PURE__ */ R("div", { className: "tiptap-image-upload-content", children: [
    /* @__PURE__ */ R("span", { className: "tiptap-image-upload-text", children: [
      /* @__PURE__ */ g("em", { children: "Click to upload" }),
      " or drag and drop"
    ] }),
    /* @__PURE__ */ R("span", { className: "tiptap-image-upload-subtext", children: [
      "Maximum ",
      e,
      " file",
      e === 1 ? "" : "s",
      ", ",
      t / 1024 / 1024,
      "MB each."
    ] })
  ] })
] }), M9 = (t) => {
  const { accept: e, limit: n, maxSize: r } = t.node.attrs, o = y.useRef(null), i = t.extension, s = {
    maxSize: r,
    limit: n,
    accept: e,
    upload: i.options.upload,
    onSuccess: i.options.onSuccess,
    onError: i.options.onError
  }, { fileItems: l, uploadFiles: a, removeFileItem: c, clearAllFiles: u } = v9(s), d = async (m) => {
    const b = await a(m);
    if (b.length > 0) {
      const C = t.getPos();
      if (Ht(C)) {
        const v = b.map((S, w) => {
          const x = m[w]?.name.replace(/\.[^/.]+$/, "") || "unknown";
          return {
            type: "image",
            attrs: { src: S, alt: x, title: x }
          };
        });
        t.editor.chain().focus().deleteRange({ from: C, to: C + 1 }).insertContentAt(C, v).run();
      }
    }
  }, f = (m) => {
    const b = m.target.files;
    if (!b || b.length === 0) {
      i.options.onError?.(new Error("No file selected"));
      return;
    }
    d(Array.from(b));
  }, h = () => {
    o.current && l.length === 0 && (o.current.value = "", o.current.click());
  }, p = l.length > 0;
  return /* @__PURE__ */ R(
    Ls,
    {
      className: "tiptap-image-upload",
      tabIndex: 0,
      onClick: h,
      children: [
        !p && /* @__PURE__ */ g(x9, { onFile: d, children: /* @__PURE__ */ g(E9, { maxSize: r, limit: n }) }),
        p && /* @__PURE__ */ R("div", { className: "tiptap-image-upload-previews", children: [
          l.length > 1 && /* @__PURE__ */ R("div", { className: "tiptap-image-upload-header", children: [
            /* @__PURE__ */ R("span", { children: [
              "Uploading ",
              l.length,
              " files"
            ] }),
            /* @__PURE__ */ g(
              J,
              {
                type: "button",
                "data-style": "ghost",
                onClick: (m) => {
                  m.stopPropagation(), u();
                },
                children: "Clear All"
              }
            )
          ] }),
          l.map((m) => /* @__PURE__ */ g(
            k9,
            {
              fileItem: m,
              onRemove: () => c(m.id)
            },
            m.id
          ))
        ] }),
        /* @__PURE__ */ g(
          "input",
          {
            ref: o,
            name: "file",
            accept: e,
            type: "file",
            multiple: n > 1,
            onChange: f,
            onClick: (m) => m.stopPropagation()
          }
        )
      ]
    }
  );
}, T9 = Ce.create({
  name: "imageUpload",
  group: "block",
  draggable: !0,
  atom: !0,
  addOptions() {
    return {
      accept: "image/*",
      limit: 1,
      maxSize: 0,
      upload: void 0,
      onError: void 0,
      onSuccess: void 0
    };
  },
  addAttributes() {
    return {
      accept: {
        default: this.options.accept
      },
      limit: {
        default: this.options.limit
      },
      maxSize: {
        default: this.options.maxSize
      }
    };
  },
  parseHTML() {
    return [{ tag: 'div[data-type="image-upload"]' }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      X({ "data-type": "image-upload" }, t)
    ];
  },
  addNodeView() {
    return Ds(M9);
  },
  addCommands() {
    return {
      setImageUploadNode: (t = {}) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  /**
   * Adds Enter key handler to trigger the upload component when it's selected.
   */
  addKeyboardShortcuts() {
    return {
      Enter: ({ editor: t }) => {
        const { selection: e } = t.state, { nodeAfter: n } = e.$from;
        if (n && n.type.name === "imageUpload" && t.isActive("imageUpload")) {
          const r = t.view.nodeDOM(e.$from.pos);
          if (r && r instanceof HTMLElement) {
            const o = r.firstChild;
            if (o && o instanceof HTMLElement)
              return o.click(), !0;
          }
        }
        return !1;
      }
    };
  }
}), R9 = Q7.extend({
  renderHTML() {
    return [
      "div",
      X(this.options.HTMLAttributes, { "data-type": this.name }),
      ["hr"]
    ];
  }
});
function A9(t) {
  return /* @__PURE__ */ g(
    Ls,
    {
      className: "page-break-node-view",
      "data-drag-handle": !0,
      draggable: !0,
      "data-type": "page-break",
      children: /* @__PURE__ */ R("div", { className: "page-break-container", children: [
        /* @__PURE__ */ g("div", { className: "page-break-line" }),
        /* @__PURE__ */ g("div", { className: "page-break-label", children: "Page Break" }),
        /* @__PURE__ */ g("div", { className: "page-break-line" })
      ] })
    }
  );
}
const O9 = Ce.create({
  name: "pageBreak",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [
      {
        tag: 'div[data-type="page-break"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      X(
        {
          "data-type": "page-break",
          class: "page-break"
        },
        this.options.HTMLAttributes,
        t
      ),
      "Page Break"
    ];
  },
  addNodeView() {
    return Ds(A9);
  },
  addCommands() {
    return {
      insertPageBreak: () => ({ commands: t, state: e }) => {
        const { selection: n } = e, { from: r } = n;
        return t.insertContentAt(r, {
          type: this.name
        });
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.insertPageBreak()
    };
  }
});
function N9({ editor: t }) {
  const [e, n] = y.useState([]);
  y.useEffect(() => {
    if (!t) return;
    const o = () => {
      const s = [];
      t.state.doc.descendants((l, a) => {
        if (l.type.name === "heading") {
          const c = `heading-${a}`, u = l.textContent, d = l.attrs.level;
          u.trim() && s.push({
            id: c,
            text: u.trim(),
            level: d,
            position: a
          });
        }
      }), n(s);
    };
    o();
    const i = () => {
      o();
    };
    return t.on("update", i), t.on("selectionUpdate", i), () => {
      t.off("update", i), t.off("selectionUpdate", i);
    };
  }, [t]);
  const r = (o) => {
    if (!t) return;
    t.chain().focus().setTextSelection(o).run();
    const i = t.view.nodeDOM(o);
    i && i instanceof Element && i.scrollIntoView({ behavior: "smooth", block: "start" });
  };
  return /* @__PURE__ */ g(
    Ls,
    {
      className: "table-of-contents-node-view",
      "data-drag-handle": !0,
      draggable: !0,
      "data-type": "table-of-contents",
      children: /* @__PURE__ */ R("div", { className: "toc-container", children: [
        /* @__PURE__ */ g("div", { className: "toc-header", children: /* @__PURE__ */ g("h3", { className: "toc-title", children: "Table of Contents" }) }),
        /* @__PURE__ */ g("div", { className: "toc-content", children: e.length === 0 ? /* @__PURE__ */ g("div", { className: "toc-empty", children: "No headings found. Add headings to your document to generate a table of contents." }) : /* @__PURE__ */ g("ul", { className: "toc-list", children: e.map((o) => /* @__PURE__ */ g(
          "li",
          {
            className: `toc-item toc-level-${o.level}`,
            children: /* @__PURE__ */ g(
              "button",
              {
                type: "button",
                className: "toc-link",
                onClick: () => r(o.position),
                children: o.text
              }
            )
          },
          o.id
        )) }) })
      ] })
    }
  );
}
const I9 = Ce.create({
  name: "tableOfContents",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [
      {
        tag: 'div[data-type="table-of-contents"]'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return [
      "div",
      X(
        {
          "data-type": "table-of-contents",
          class: "table-of-contents"
        },
        this.options.HTMLAttributes,
        t
      )
    ];
  },
  addNodeView() {
    return Ds(N9);
  },
  addCommands() {
    return {
      insertTableOfContents: () => ({ commands: t, state: e }) => {
        const { selection: n } = e, { from: r } = n;
        return t.insertContentAt(r, {
          type: this.name
        });
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-t": () => this.editor.commands.insertTableOfContents()
    };
  }
}), Mo = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M5.29289 8.29289C5.68342 7.90237 6.31658 7.90237 6.70711 8.29289L12 13.5858L17.2929 8.29289C17.6834 7.90237 18.3166 7.90237 18.7071 8.29289C19.0976 8.68342 19.0976 9.31658 18.7071 9.70711L12.7071 15.7071C12.3166 16.0976 11.6834 16.0976 11.2929 15.7071L5.29289 9.70711C4.90237 9.31658 4.90237 8.68342 5.29289 8.29289Z",
          fill: "currentColor"
        }
      )
    }
  )
);
Mo.displayName = "ChevronDownIcon";
function Y(t) {
  const { editor: e } = Fc(), n = y.useMemo(
    () => t || e,
    [t, e]
  );
  return $m({
    editor: n,
    selector(o) {
      return o.editor ? {
        editor: o.editor,
        editorState: o.editor.state,
        canCommand: o.editor.can
      } : {
        editor: null,
        editorState: void 0,
        canCommand: void 0
      };
    }
  }) || { editor: null };
}
const ct = y.forwardRef(
  ({
    variant: t,
    size: e = "default",
    appearance: n = "default",
    trimText: r = !1,
    className: o,
    children: i,
    ...s
  }, l) => /* @__PURE__ */ g(
    "div",
    {
      ref: l,
      className: `tiptap-badge ${o || ""}`,
      "data-style": t,
      "data-size": e,
      "data-appearance": n,
      "data-text-trim": r ? "on" : "off",
      ...s,
      children: i
    }
  )
);
ct.displayName = "Badge";
function L9({
  level: t,
  shortcutKeys: e = Ga[t]
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: e }) });
}
const bg = y.forwardRef(
  ({
    editor: t,
    level: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onToggled: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), {
      isVisible: d,
      canToggle: f,
      isActive: h,
      handleToggle: p,
      label: m,
      Icon: b,
      shortcutKeys: C
    } = Z9({
      editor: u,
      level: e,
      hideWhenUnavailable: r,
      onToggled: o
    }), v = y.useCallback(
      (S) => {
        s?.(S), !S.defaultPrevented && p();
      },
      [p, s]
    );
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": h ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !f,
        "data-disabled": !f,
        "aria-label": m,
        "aria-pressed": h,
        tooltip: m,
        onClick: v,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(L9, { level: e, shortcutKeys: C })
        ] })
      }
    ) : null;
  }
);
bg.displayName = "HeadingButton";
const Cg = ["shift", "alt", "meta", "mod", "ctrl", "control"], D9 = {
  esc: "escape",
  return: "enter",
  left: "arrowleft",
  right: "arrowright",
  up: "arrowup",
  down: "arrowdown",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  AltLeft: "alt",
  AltRight: "alt",
  MetaLeft: "meta",
  MetaRight: "meta",
  OSLeft: "meta",
  OSRight: "meta",
  ControlLeft: "ctrl",
  ControlRight: "ctrl"
};
function En(t) {
  return (D9[t.trim()] || t.trim()).toLowerCase().replace(/key|digit|numpad/, "");
}
function vg(t) {
  return Cg.includes(t);
}
function Kl(t, e = ",") {
  return t.toLowerCase().split(e);
}
function jl(t, e = "+", n = ">", r = !1, o) {
  let i = [], s = !1;
  t.includes(n) ? (s = !0, i = t.toLocaleLowerCase().split(n).map((c) => En(c))) : i = t.toLocaleLowerCase().split(e).map((c) => En(c));
  const l = {
    alt: i.includes("alt"),
    ctrl: i.includes("ctrl") || i.includes("control"),
    shift: i.includes("shift"),
    meta: i.includes("meta"),
    mod: i.includes("mod"),
    useKey: r
  }, a = i.filter((c) => !Cg.includes(c));
  return {
    ...l,
    keys: a,
    description: o,
    isSequence: s
  };
}
typeof document < "u" && (document.addEventListener("keydown", (t) => {
  t.code !== void 0 && wg([En(t.code)]);
}), document.addEventListener("keyup", (t) => {
  t.code !== void 0 && Sg([En(t.code)]);
})), typeof window < "u" && (window.addEventListener("blur", () => {
  Gt.clear();
}), window.addEventListener("contextmenu", () => {
  setTimeout(() => {
    Gt.clear();
  }, 0);
}));
const Gt = /* @__PURE__ */ new Set();
function pu(t) {
  return Array.isArray(t);
}
function P9(t, e = ",") {
  return (pu(t) ? t : t.split(e)).every((n) => Gt.has(n.trim().toLowerCase()));
}
function wg(t) {
  const e = Array.isArray(t) ? t : [t];
  Gt.has("meta") && Gt.forEach((n) => !vg(n) && Gt.delete(n.toLowerCase())), e.forEach((n) => Gt.add(n.toLowerCase()));
}
function Sg(t) {
  const e = Array.isArray(t) ? t : [t];
  t === "meta" ? Gt.clear() : e.forEach((n) => Gt.delete(n.toLowerCase()));
}
function B9(t, e, n) {
  (typeof n == "function" && n(t, e) || n === !0) && t.preventDefault();
}
function H9(t, e, n) {
  return typeof n == "function" ? n(t, e) : n === !0 || n === void 0;
}
function F9(t) {
  return xg(t, ["input", "textarea", "select"]);
}
function xg(t, e = !1) {
  const { target: n, composed: r } = t;
  let o;
  return _9(n) && r ? o = t.composedPath()[0] && t.composedPath()[0].tagName : o = n && n.tagName, pu(e) ? !!(o && e && e.some((i) => i.toLowerCase() === o.toLowerCase())) : !!(o && e && e);
}
function _9(t) {
  return !!t.tagName && !t.tagName.startsWith("-") && t.tagName.includes("-");
}
function z9(t, e) {
  return t.length === 0 && e ? (console.warn(
    'A hotkey has the "scopes" option set, however no active scopes were found. If you want to use the global scopes feature, you need to wrap your app in a <HotkeysProvider>'
  ), !0) : e ? t.some((n) => e.includes(n)) || t.includes("*") : !0;
}
const V9 = (t, e, n = !1) => {
  const { alt: r, meta: o, mod: i, shift: s, ctrl: l, keys: a, useKey: c } = e, { code: u, key: d, ctrlKey: f, metaKey: h, shiftKey: p, altKey: m } = t, b = En(u);
  if (c && a?.length === 1 && a.includes(d))
    return !0;
  if (!(a != null && a.includes(b)) && !["ctrl", "control", "unknown", "meta", "alt", "shift", "os"].includes(b))
    return !1;
  if (!n) {
    if (r !== m && b !== "alt" || s !== p && b !== "shift")
      return !1;
    if (i) {
      if (!h && !f)
        return !1;
    } else if (o !== h && b !== "meta" && b !== "os" || l !== f && b !== "ctrl" && b !== "control")
      return !1;
  }
  return a && a.length === 1 && a.includes(b) ? !0 : a ? P9(a) : !a;
}, $9 = gs(void 0), U9 = () => ys($9);
function kg(t, e) {
  return t && e && typeof t == "object" && typeof e == "object" ? Object.keys(t).length === Object.keys(e).length && // @ts-expect-error TS7053
  Object.keys(t).reduce((n, r) => n && kg(t[r], e[r]), !0) : t === e;
}
const W9 = gs({
  hotkeys: [],
  activeScopes: [],
  // This array has to be empty instead of containing '*' as default, to check if the provider is set or not
  toggleScope: () => {
  },
  enableScope: () => {
  },
  disableScope: () => {
  }
}), K9 = () => ys(W9);
function j9(t) {
  const e = Nt(void 0);
  return kg(e.current, t) || (e.current = t), e.current;
}
const mh = (t) => {
  t.stopPropagation(), t.preventDefault(), t.stopImmediatePropagation();
}, q9 = typeof window < "u" ? bs : Zt;
function Lr(t, e, n, r) {
  const o = Nt(null), i = Nt(!1), s = n instanceof Array ? r instanceof Array ? void 0 : r : n, l = pu(t) ? t.join(s?.delimiter) : t, a = n instanceof Array ? n : r instanceof Array ? r : void 0, c = Pn(e, a ?? []), u = Nt(c);
  a ? u.current = c : u.current = e;
  const d = j9(s), { activeScopes: f } = K9(), h = U9();
  return q9(() => {
    if (d?.enabled === !1 || !z9(f, d?.scopes))
      return;
    let p = [], m;
    const b = (w, x = !1) => {
      var k;
      if (!(F9(w) && !xg(w, d?.enableOnFormTags))) {
        if (o.current !== null) {
          const E = o.current.getRootNode();
          if ((E instanceof Document || E instanceof ShadowRoot) && E.activeElement !== o.current && !o.current.contains(E.activeElement)) {
            mh(w);
            return;
          }
        }
        (k = w.target) != null && k.isContentEditable && !(d != null && d.enableOnContentEditable) || Kl(l, d?.delimiter).forEach((E) => {
          var M, N, T, P;
          if (E.includes(d?.splitKey ?? "+") && E.includes(d?.sequenceSplitKey ?? ">")) {
            console.warn(`Hotkey ${E} contains both ${d?.splitKey ?? "+"} and ${d?.sequenceSplitKey ?? ">"} which is not supported.`);
            return;
          }
          const _ = jl(E, d?.splitKey, d?.sequenceSplitKey, d?.useKey, d?.description);
          if (_.isSequence) {
            m = setTimeout(() => {
              p = [];
            }, d?.sequenceTimeoutMs ?? 1e3);
            const F = _.useKey ? w.key : En(w.code);
            if (vg(F.toLowerCase()))
              return;
            p.push(F);
            const D = (M = _.keys) == null ? void 0 : M[p.length - 1];
            if (F !== D) {
              p = [], m && clearTimeout(m);
              return;
            }
            p.length === ((N = _.keys) == null ? void 0 : N.length) && (u.current(w, _), m && clearTimeout(m), p = []);
          } else if (V9(w, _, d?.ignoreModifiers) || (T = _.keys) != null && T.includes("*")) {
            if ((P = d?.ignoreEventWhen) != null && P.call(d, w) || x && i.current)
              return;
            if (B9(w, _, d?.preventDefault), !H9(w, _, d?.enabled)) {
              mh(w);
              return;
            }
            u.current(w, _), x || (i.current = !0);
          }
        });
      }
    }, C = (w) => {
      w.code !== void 0 && (wg(En(w.code)), (d?.keydown === void 0 && d?.keyup !== !0 || d != null && d.keydown) && b(w));
    }, v = (w) => {
      w.code !== void 0 && (Sg(En(w.code)), i.current = !1, d != null && d.keyup && b(w, !0));
    }, S = o.current || s?.document || document;
    return S.addEventListener("keyup", v, s?.eventListenerOptions), S.addEventListener("keydown", C, s?.eventListenerOptions), h && Kl(l, d?.delimiter).forEach(
      (w) => h.addHotkey(
        jl(w, d?.splitKey, d?.sequenceSplitKey, d?.useKey, d?.description)
      )
    ), () => {
      S.removeEventListener("keyup", v, s?.eventListenerOptions), S.removeEventListener("keydown", C, s?.eventListenerOptions), h && Kl(l, d?.delimiter).forEach(
        (w) => h.removeHotkey(
          jl(w, d?.splitKey, d?.sequenceSplitKey, d?.useKey, d?.description)
        )
      ), p = [], m && clearTimeout(m);
    };
  }, [l, d, f]), o;
}
function ut(t = 768) {
  const [e, n] = y.useState(
    void 0
  );
  return y.useEffect(() => {
    const r = window.matchMedia(`(max-width: ${t - 1}px)`), o = () => {
      n(window.innerWidth < t);
    };
    return r.addEventListener("change", o), n(window.innerWidth < t), () => r.removeEventListener("change", o);
  }, [t]), !!e;
}
const Eg = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M21.0001 10C21.0001 9.63121 20.7971 9.29235 20.472 9.11833C20.1468 8.94431 19.7523 8.96338 19.4454 9.16795L16.4454 11.168C15.9859 11.4743 15.8617 12.0952 16.1681 12.5547C16.4744 13.0142 17.0953 13.1384 17.5548 12.8321L19.0001 11.8685V18C19.0001 18.5523 19.4478 19 20.0001 19C20.5524 19 21.0001 18.5523 21.0001 18V10Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Eg.displayName = "HeadingOneIcon";
const Mg = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M22.0001 12C22.0001 10.7611 21.1663 9.79297 20.0663 9.42632C18.9547 9.05578 17.6171 9.28724 16.4001 10.2C15.9582 10.5314 15.8687 11.1582 16.2001 11.6C16.5314 12.0418 17.1582 12.1314 17.6001 11.8C18.383 11.2128 19.0455 11.1942 19.4338 11.3237C19.8339 11.457 20.0001 11.7389 20.0001 12C20.0001 12.4839 19.8554 12.7379 19.6537 12.9481C19.4275 13.1837 19.1378 13.363 18.7055 13.6307C18.6313 13.6767 18.553 13.7252 18.4701 13.777C17.9572 14.0975 17.3128 14.5261 16.8163 15.2087C16.3007 15.9177 16.0001 16.8183 16.0001 18C16.0001 18.5523 16.4478 19 17.0001 19H21.0001C21.5523 19 22.0001 18.5523 22.0001 18C22.0001 17.4477 21.5523 17 21.0001 17H18.131C18.21 16.742 18.3176 16.5448 18.4338 16.385C18.6873 16.0364 19.0429 15.7775 19.5301 15.473C19.5898 15.4357 19.6536 15.3966 19.7205 15.3556C20.139 15.0992 20.6783 14.7687 21.0964 14.3332C21.6447 13.7621 22.0001 13.0161 22.0001 12Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Mg.displayName = "HeadingTwoIcon";
const Tg = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M4 5C4.55228 5 5 5.44772 5 6V11H11V6C11 5.44772 11.4477 5 12 5C12.5523 5 13 5.44772 13 6V18C13 18.5523 12.5523 19 12 19C11.4477 19 11 18.5523 11 18V13H5V18C5 18.5523 4.55228 19 4 19C3.44772 19 3 18.5523 3 18V6C3 5.44772 3.44772 5 4 5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.4608 11.2169C19.1135 11.0531 18.5876 11.0204 18.0069 11.3619C17.5309 11.642 16.918 11.4831 16.638 11.007C16.358 10.531 16.5169 9.91809 16.9929 9.63807C18.1123 8.97962 19.3364 8.94691 20.314 9.40808C21.2839 9.86558 21.9999 10.818 21.9999 12C21.9999 12.7957 21.6838 13.5587 21.1212 14.1213C20.5586 14.6839 19.7956 15 18.9999 15C18.4476 15 17.9999 14.5523 17.9999 14C17.9999 13.4477 18.4476 13 18.9999 13C19.2651 13 19.5195 12.8947 19.707 12.7071C19.8946 12.5196 19.9999 12.2652 19.9999 12C19.9999 11.6821 19.8159 11.3844 19.4608 11.2169Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M18.0001 14C18.0001 13.4477 18.4478 13 19.0001 13C19.7957 13 20.5588 13.3161 21.1214 13.8787C21.684 14.4413 22.0001 15.2043 22.0001 16C22.0001 17.2853 21.2767 18.3971 20.1604 18.8994C19.0257 19.41 17.642 19.2315 16.4001 18.3C15.9582 17.9686 15.8687 17.3418 16.2001 16.9C16.5314 16.4582 17.1582 16.3686 17.6001 16.7C18.3581 17.2685 18.9744 17.24 19.3397 17.0756C19.7234 16.9029 20.0001 16.5147 20.0001 16C20.0001 15.7348 19.8947 15.4804 19.7072 15.2929C19.5196 15.1054 19.2653 15 19.0001 15C18.4478 15 18.0001 14.5523 18.0001 14Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Tg.displayName = "HeadingThreeIcon";
const Rg = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M4 5C4.55228 5 5 5.44772 5 6V11H11V6C11 5.44772 11.4477 5 12 5C12.5523 5 13 5.44772 13 6V18C13 18.5523 12.5523 19 12 19C11.4477 19 11 18.5523 11 18V13H5V18C5 18.5523 4.55228 19 4 19C3.44772 19 3 18.5523 3 18V6C3 5.44772 3.44772 5 4 5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M17 9C17.5523 9 18 9.44772 18 10V13H20V10C20 9.44772 20.4477 9 21 9C21.5523 9 22 9.44772 22 10V18C22 18.5523 21.5523 19 21 19C20.4477 19 20 18.5523 20 18V15H17C16.4477 15 16 14.5523 16 14V10C16 9.44772 16.4477 9 17 9Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Rg.displayName = "HeadingFourIcon";
const Ag = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M16 10C16 9.44772 16.4477 9 17 9H21C21.5523 9 22 9.44772 22 10C22 10.5523 21.5523 11 21 11H18V12H18.3C20.2754 12 22 13.4739 22 15.5C22 17.5261 20.2754 19 18.3 19C17.6457 19 17.0925 18.8643 16.5528 18.5944C16.0588 18.3474 15.8586 17.7468 16.1055 17.2528C16.3525 16.7588 16.9532 16.5586 17.4472 16.8056C17.7074 16.9357 17.9542 17 18.3 17C19.3246 17 20 16.2739 20 15.5C20 14.7261 19.3246 14 18.3 14H17C16.4477 14 16 13.5523 16 13L16 12.9928V10Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Ag.displayName = "HeadingFiveIcon";
const Og = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M20.7071 9.29289C21.0976 9.68342 21.0976 10.3166 20.7071 10.7071C19.8392 11.575 19.2179 12.2949 18.7889 13.0073C18.8587 13.0025 18.929 13 19 13C20.6569 13 22 14.3431 22 16C22 17.6569 20.6569 19 19 19C17.3431 19 16 17.6569 16 16C16 14.6007 16.2837 13.4368 16.8676 12.3419C17.4384 11.2717 18.2728 10.3129 19.2929 9.29289C19.6834 8.90237 20.3166 8.90237 20.7071 9.29289ZM19 17C18.4477 17 18 16.5523 18 16C18 15.4477 18.4477 15 19 15C19.5523 15 20 15.4477 20 16C20 16.5523 19.5523 17 19 17Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Og.displayName = "HeadingSixIcon";
const Ng = {
  1: Eg,
  2: Mg,
  3: Tg,
  4: Rg,
  5: Ag,
  6: Og
}, Ga = {
  1: "ctrl+alt+1",
  2: "ctrl+alt+2",
  3: "ctrl+alt+3",
  4: "ctrl+alt+4",
  5: "ctrl+alt+5",
  6: "ctrl+alt+6"
};
function po(t, e, n = !0) {
  if (!t || !t.isEditable || !rn("heading", t) || wt(t, ["image"]))
    return !1;
  if (!n)
    return e ? t.can().setNode("heading", { level: e }) : t.can().setNode("heading");
  try {
    const o = t.view.state, i = o.selection;
    if (i.empty || i instanceof V) {
      const s = In({
        editor: t,
        node: o.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(s)) return !1;
    }
    return !0;
  } catch {
    return !1;
  }
}
function mu(t, e) {
  return !t || !t.isEditable ? !1 : Array.isArray(e) ? e.some((n) => t.isActive("heading", { level: n })) : e ? t.isActive("heading", { level: e }) : t.isActive("heading");
}
function G9(t, e) {
  if (!t || !t.isEditable) return !1;
  const n = Array.isArray(e) ? e : [e], r = n.find((o) => po(t, o));
  if (!r) return !1;
  try {
    const o = t.view;
    let i = o.state, s = i.tr;
    if (i.selection.empty || i.selection instanceof V) {
      const d = In({
        editor: t,
        node: i.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(d)) return !1;
      s = s.setSelection(z.create(i.doc, d)), o.dispatch(s), i = o.state;
    }
    const l = i.selection;
    let a = t.chain().focus();
    if (l instanceof z) {
      const d = l.node.firstChild?.firstChild, f = l.node.lastChild?.lastChild, h = d ? l.from + d.nodeSize : l.from + 1, p = f ? l.to - f.nodeSize : l.to - 1;
      a = a.setTextSelection({ from: h, to: p }).clearNodes();
    }
    return (n.some(
      (d) => t.isActive("heading", { level: d })
    ) ? a.setNode("paragraph") : a.setNode("heading", { level: r })).run(), t.chain().focus().selectTextblockEnd().run(), !0;
  } catch {
    return !1;
  }
}
function Ig(t) {
  const { editor: e, level: n, hideWhenUnavailable: r } = t;
  return !e || !e.isEditable || !rn("heading", e) ? !1 : r && !e.isActive("code") ? Array.isArray(n) ? n.some((o) => po(e, o)) : po(e, n) : !0;
}
function Z9(t) {
  const {
    editor: e,
    level: n,
    hideWhenUnavailable: r = !1,
    onToggled: o
  } = t, { editor: i } = Y(e), s = ut(), [l, a] = y.useState(!0), c = po(i, n), u = mu(i, n);
  y.useEffect(() => {
    if (!i) return;
    const f = () => {
      a(Ig({ editor: i, level: n, hideWhenUnavailable: r }));
    };
    return f(), i.on("selectionUpdate", f), () => {
      i.off("selectionUpdate", f);
    };
  }, [i, n, r]);
  const d = y.useCallback(() => {
    if (!i) return !1;
    const f = G9(i, n);
    return f && o?.(), f;
  }, [i, n, o]);
  return Lr(
    Ga[n],
    (f) => {
      f.preventDefault(), d();
    },
    {
      enabled: l && c,
      enableOnContentEditable: !s,
      enableOnFormTags: !0
    }
  ), {
    isVisible: l,
    isActive: u,
    handleToggle: d,
    canToggle: c,
    label: `Heading ${n}`,
    shortcutKeys: Ga[n],
    Icon: Ng[n]
  };
}
function Z(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (t?.(o), n === !1 || !o.defaultPrevented)
      return e?.(o);
  };
}
function gh(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function Vs(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((o) => {
      const i = gh(o, e);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const i = r[o];
          typeof i == "function" ? i() : gh(t[o], null);
        }
      };
  };
}
function He(...t) {
  return y.useCallback(Vs(...t), t);
}
function Dr(t, e = []) {
  let n = [];
  function r(i, s) {
    const l = y.createContext(s), a = n.length;
    n = [...n, s];
    const c = (d) => {
      const { scope: f, children: h, ...p } = d, m = f?.[t]?.[a] || l, b = y.useMemo(() => p, Object.values(p));
      return /* @__PURE__ */ g(m.Provider, { value: b, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      const h = f?.[t]?.[a] || l, p = y.useContext(h);
      if (p) return p;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const o = () => {
    const i = n.map((s) => y.createContext(s));
    return function(l) {
      const a = l?.[t] || i;
      return y.useMemo(
        () => ({ [`__scope${t}`]: { ...l, [t]: a } }),
        [l, a]
      );
    };
  };
  return o.scopeName = t, [r, J9(o, ...e)];
}
function J9(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i) {
      const s = r.reduce((l, { useScope: a, scopeName: c }) => {
        const d = a(i)[`__scope${c}`];
        return { ...l, ...d };
      }, {});
      return y.useMemo(() => ({ [`__scope${e.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var An = globalThis?.document ? y.useLayoutEffect : () => {
}, Y9 = y[" useInsertionEffect ".trim().toString()] || An;
function gu({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  },
  caller: r
}) {
  const [o, i, s] = X9({
    defaultProp: e,
    onChange: n
  }), l = t !== void 0, a = l ? t : o;
  {
    const u = y.useRef(t !== void 0);
    y.useEffect(() => {
      const d = u.current;
      d !== l && console.warn(
        `${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${l ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), u.current = l;
    }, [l, r]);
  }
  const c = y.useCallback(
    (u) => {
      if (l) {
        const d = Q9(u) ? u(t) : u;
        d !== t && s.current?.(d);
      } else
        i(u);
    },
    [l, t, i, s]
  );
  return [a, c];
}
function X9({
  defaultProp: t,
  onChange: e
}) {
  const [n, r] = y.useState(t), o = y.useRef(n), i = y.useRef(e);
  return Y9(() => {
    i.current = e;
  }, [e]), y.useEffect(() => {
    o.current !== n && (i.current?.(n), o.current = n);
  }, [n, o]), [n, r, i];
}
function Q9(t) {
  return typeof t == "function";
}
// @__NO_SIDE_EFFECTS__
function mo(t) {
  const e = /* @__PURE__ */ ek(t), n = y.forwardRef((r, o) => {
    const { children: i, ...s } = r, l = y.Children.toArray(i), a = l.find(nk);
    if (a) {
      const c = a.props.children, u = l.map((d) => d === a ? y.Children.count(c) > 1 ? y.Children.only(null) : y.isValidElement(c) ? c.props.children : null : d);
      return /* @__PURE__ */ g(e, { ...s, ref: o, children: y.isValidElement(c) ? y.cloneElement(c, void 0, u) : null });
    }
    return /* @__PURE__ */ g(e, { ...s, ref: o, children: i });
  });
  return n.displayName = `${t}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function ek(t) {
  const e = y.forwardRef((n, r) => {
    const { children: o, ...i } = n;
    if (y.isValidElement(o)) {
      const s = ok(o), l = rk(i, o.props);
      return o.type !== y.Fragment && (l.ref = r ? Vs(r, s) : s), y.cloneElement(o, l);
    }
    return y.Children.count(o) > 1 ? y.Children.only(null) : null;
  });
  return e.displayName = `${t}.SlotClone`, e;
}
var tk = Symbol("radix.slottable");
function nk(t) {
  return y.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === tk;
}
function rk(t, e) {
  const n = { ...e };
  for (const r in e) {
    const o = t[r], i = e[r];
    /^on[A-Z]/.test(r) ? o && i ? n[r] = (...l) => {
      const a = i(...l);
      return o(...l), a;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function ok(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var ik = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Ie = ik.reduce((t, e) => {
  const n = /* @__PURE__ */ mo(`Primitive.${e}`), r = y.forwardRef((o, i) => {
    const { asChild: s, ...l } = o, a = s ? n : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ g(a, { ...l, ref: i });
  });
  return r.displayName = `Primitive.${e}`, { ...t, [e]: r };
}, {});
function Lg(t, e) {
  t && sc.flushSync(() => t.dispatchEvent(e));
}
function Dg(t) {
  const e = t + "CollectionProvider", [n, r] = Dr(e), [o, i] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (m) => {
    const { scope: b, children: C } = m, v = ve.useRef(null), S = ve.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ g(o, { scope: b, itemMap: S, collectionRef: v, children: C });
  };
  s.displayName = e;
  const l = t + "CollectionSlot", a = /* @__PURE__ */ mo(l), c = ve.forwardRef(
    (m, b) => {
      const { scope: C, children: v } = m, S = i(l, C), w = He(b, S.collectionRef);
      return /* @__PURE__ */ g(a, { ref: w, children: v });
    }
  );
  c.displayName = l;
  const u = t + "CollectionItemSlot", d = "data-radix-collection-item", f = /* @__PURE__ */ mo(u), h = ve.forwardRef(
    (m, b) => {
      const { scope: C, children: v, ...S } = m, w = ve.useRef(null), x = He(b, w), k = i(u, C);
      return ve.useEffect(() => (k.itemMap.set(w, { ref: w, ...S }), () => void k.itemMap.delete(w))), /* @__PURE__ */ g(f, { [d]: "", ref: x, children: v });
    }
  );
  h.displayName = u;
  function p(m) {
    const b = i(t + "CollectionConsumer", m);
    return ve.useCallback(() => {
      const v = b.collectionRef.current;
      if (!v) return [];
      const S = Array.from(v.querySelectorAll(`[${d}]`));
      return Array.from(b.itemMap.values()).sort(
        (k, E) => S.indexOf(k.ref.current) - S.indexOf(E.ref.current)
      );
    }, [b.collectionRef, b.itemMap]);
  }
  return [
    { Provider: s, Slot: c, ItemSlot: h },
    p,
    r
  ];
}
var sk = y.createContext(void 0);
function Pg(t) {
  const e = y.useContext(sk);
  return t || e || "ltr";
}
function en(t) {
  const e = y.useRef(t);
  return y.useEffect(() => {
    e.current = t;
  }), y.useMemo(() => (...n) => e.current?.(...n), []);
}
function lk(t, e = globalThis?.document) {
  const n = en(t);
  y.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var ak = "DismissableLayer", Za = "dismissableLayer.update", ck = "dismissableLayer.pointerDownOutside", uk = "dismissableLayer.focusOutside", yh, Bg = y.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), yu = y.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: i,
      onInteractOutside: s,
      onDismiss: l,
      ...a
    } = t, c = y.useContext(Bg), [u, d] = y.useState(null), f = u?.ownerDocument ?? globalThis?.document, [, h] = y.useState({}), p = He(e, (E) => d(E)), m = Array.from(c.layers), [b] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), C = m.indexOf(b), v = u ? m.indexOf(u) : -1, S = c.layersWithOutsidePointerEventsDisabled.size > 0, w = v >= C, x = hk((E) => {
      const M = E.target, N = [...c.branches].some((T) => T.contains(M));
      !w || N || (o?.(E), s?.(E), E.defaultPrevented || l?.());
    }, f), k = pk((E) => {
      const M = E.target;
      [...c.branches].some((T) => T.contains(M)) || (i?.(E), s?.(E), E.defaultPrevented || l?.());
    }, f);
    return lk((E) => {
      v === c.layers.size - 1 && (r?.(E), !E.defaultPrevented && l && (E.preventDefault(), l()));
    }, f), y.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (yh = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), bh(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = yh);
        };
    }, [u, f, n, c]), y.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), bh());
    }, [u, c]), y.useEffect(() => {
      const E = () => h({});
      return document.addEventListener(Za, E), () => document.removeEventListener(Za, E);
    }, []), /* @__PURE__ */ g(
      Ie.div,
      {
        ...a,
        ref: p,
        style: {
          pointerEvents: S ? w ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Z(t.onFocusCapture, k.onFocusCapture),
        onBlurCapture: Z(t.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: Z(
          t.onPointerDownCapture,
          x.onPointerDownCapture
        )
      }
    );
  }
);
yu.displayName = ak;
var dk = "DismissableLayerBranch", fk = y.forwardRef((t, e) => {
  const n = y.useContext(Bg), r = y.useRef(null), o = He(e, r);
  return y.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ g(Ie.div, { ...t, ref: o });
});
fk.displayName = dk;
function hk(t, e = globalThis?.document) {
  const n = en(t), r = y.useRef(!1), o = y.useRef(() => {
  });
  return y.useEffect(() => {
    const i = (l) => {
      if (l.target && !r.current) {
        let a = function() {
          Hg(
            ck,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: l };
        l.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = a, e.addEventListener("click", o.current, { once: !0 })) : a();
      } else
        e.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(s), e.removeEventListener("pointerdown", i), e.removeEventListener("click", o.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function pk(t, e = globalThis?.document) {
  const n = en(t), r = y.useRef(!1);
  return y.useEffect(() => {
    const o = (i) => {
      i.target && !r.current && Hg(uk, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function bh() {
  const t = new CustomEvent(Za);
  document.dispatchEvent(t);
}
function Hg(t, e, n, { discrete: r }) {
  const o = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && o.addEventListener(t, e, { once: !0 }), r ? Lg(o, i) : o.dispatchEvent(i);
}
var ql = 0;
function Fg() {
  y.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? Ch()), document.body.insertAdjacentElement("beforeend", t[1] ?? Ch()), ql++, () => {
      ql === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), ql--;
    };
  }, []);
}
function Ch() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var Gl = "focusScope.autoFocusOnMount", Zl = "focusScope.autoFocusOnUnmount", vh = { bubbles: !1, cancelable: !0 }, mk = "FocusScope", bu = y.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: i,
    ...s
  } = t, [l, a] = y.useState(null), c = en(o), u = en(i), d = y.useRef(null), f = He(e, (m) => a(m)), h = y.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  y.useEffect(() => {
    if (r) {
      let m = function(S) {
        if (h.paused || !l) return;
        const w = S.target;
        l.contains(w) ? d.current = w : an(d.current, { select: !0 });
      }, b = function(S) {
        if (h.paused || !l) return;
        const w = S.relatedTarget;
        w !== null && (l.contains(w) || an(d.current, { select: !0 }));
      }, C = function(S) {
        if (document.activeElement === document.body)
          for (const x of S)
            x.removedNodes.length > 0 && an(l);
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", b);
      const v = new MutationObserver(C);
      return l && v.observe(l, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", b), v.disconnect();
      };
    }
  }, [r, l, h.paused]), y.useEffect(() => {
    if (l) {
      Sh.add(h);
      const m = document.activeElement;
      if (!l.contains(m)) {
        const C = new CustomEvent(Gl, vh);
        l.addEventListener(Gl, c), l.dispatchEvent(C), C.defaultPrevented || (gk(wk(_g(l)), { select: !0 }), document.activeElement === m && an(l));
      }
      return () => {
        l.removeEventListener(Gl, c), setTimeout(() => {
          const C = new CustomEvent(Zl, vh);
          l.addEventListener(Zl, u), l.dispatchEvent(C), C.defaultPrevented || an(m ?? document.body, { select: !0 }), l.removeEventListener(Zl, u), Sh.remove(h);
        }, 0);
      };
    }
  }, [l, c, u, h]);
  const p = y.useCallback(
    (m) => {
      if (!n && !r || h.paused) return;
      const b = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, C = document.activeElement;
      if (b && C) {
        const v = m.currentTarget, [S, w] = yk(v);
        S && w ? !m.shiftKey && C === w ? (m.preventDefault(), n && an(S, { select: !0 })) : m.shiftKey && C === S && (m.preventDefault(), n && an(w, { select: !0 })) : C === v && m.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ g(Ie.div, { tabIndex: -1, ...s, ref: f, onKeyDown: p });
});
bu.displayName = mk;
function gk(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (an(r, { select: e }), document.activeElement !== n) return;
}
function yk(t) {
  const e = _g(t), n = wh(e, t), r = wh(e.reverse(), t);
  return [n, r];
}
function _g(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function wh(t, e) {
  for (const n of t)
    if (!bk(n, { upTo: e })) return n;
}
function bk(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function Ck(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function an(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && Ck(t) && e && t.select();
  }
}
var Sh = vk();
function vk() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = xh(t, e), t.unshift(e);
    },
    remove(e) {
      t = xh(t, e), t[0]?.resume();
    }
  };
}
function xh(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function wk(t) {
  return t.filter((e) => e.tagName !== "A");
}
var Sk = y[" useId ".trim().toString()] || (() => {
}), xk = 0;
function fs(t) {
  const [e, n] = y.useState(Sk());
  return An(() => {
    n((r) => r ?? String(xk++));
  }, [t]), t || (e ? `radix-${e}` : "");
}
var kk = "Arrow", zg = y.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = t;
  return /* @__PURE__ */ g(
    Ie.svg,
    {
      ...i,
      ref: e,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ g("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
zg.displayName = kk;
var Ek = zg;
function Mk(t) {
  const [e, n] = y.useState(void 0);
  return An(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i = o[0];
        let s, l;
        if ("borderBoxSize" in i) {
          const a = i.borderBoxSize, c = Array.isArray(a) ? a[0] : a;
          s = c.inlineSize, l = c.blockSize;
        } else
          s = t.offsetWidth, l = t.offsetHeight;
        n({ width: s, height: l });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var Cu = "Popper", [Vg, $s] = Dr(Cu), [Tk, $g] = Vg(Cu), Ug = (t) => {
  const { __scopePopper: e, children: n } = t, [r, o] = y.useState(null);
  return /* @__PURE__ */ g(Tk, { scope: e, anchor: r, onAnchorChange: o, children: n });
};
Ug.displayName = Cu;
var Wg = "PopperAnchor", Kg = y.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...o } = t, i = $g(Wg, n), s = y.useRef(null), l = He(e, s);
    return y.useEffect(() => {
      i.onAnchorChange(r?.current || s.current);
    }), r ? null : /* @__PURE__ */ g(Ie.div, { ...o, ref: l });
  }
);
Kg.displayName = Wg;
var vu = "PopperContent", [Rk, Ak] = Vg(vu), jg = y.forwardRef(
  (t, e) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: i = "center",
      alignOffset: s = 0,
      arrowPadding: l = 0,
      avoidCollisions: a = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: p,
      ...m
    } = t, b = $g(vu, n), [C, v] = y.useState(null), S = He(e, (ne) => v(ne)), [w, x] = y.useState(null), k = Mk(w), E = k?.width ?? 0, M = k?.height ?? 0, N = r + (i !== "center" ? "-" + i : ""), T = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, P = Array.isArray(c) ? c : [c], _ = P.length > 0, F = {
      padding: T,
      boundary: P.filter(Nk),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: _
    }, { refs: D, floatingStyles: W, placement: $, isPositioned: H, middlewareData: O } = rg({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: N,
      whileElementsMounted: (...ne) => Q1(...ne, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: b.anchor
      },
      middleware: [
        og({ mainAxis: o + M, alignmentAxis: s }),
        a && ig({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? Ox() : void 0,
          ...F
        }),
        a && sg({ ...F }),
        Nx({
          ...F,
          apply: ({ elements: ne, rects: oe, availableWidth: Xe, availableHeight: Ft }) => {
            const { width: rr, height: ol } = oe.reference, or = ne.floating.style;
            or.setProperty("--radix-popper-available-width", `${Xe}px`), or.setProperty("--radix-popper-available-height", `${Ft}px`), or.setProperty("--radix-popper-anchor-width", `${rr}px`), or.setProperty("--radix-popper-anchor-height", `${ol}px`);
          }
        }),
        w && Lx({ element: w, padding: l }),
        Ik({ arrowWidth: E, arrowHeight: M }),
        f && Ix({ strategy: "referenceHidden", ...F })
      ]
    }), [I, j] = Zg($), re = en(p);
    An(() => {
      H && re?.();
    }, [H, re]);
    const q = O.arrow?.x, te = O.arrow?.y, Ye = O.arrow?.centerOffset !== 0, [fe, xe] = y.useState();
    return An(() => {
      C && xe(window.getComputedStyle(C).zIndex);
    }, [C]), /* @__PURE__ */ g(
      "div",
      {
        ref: D.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...W,
          transform: H ? W.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: fe,
          "--radix-popper-transform-origin": [
            O.transformOrigin?.x,
            O.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...O.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ g(
          Rk,
          {
            scope: n,
            placedSide: I,
            onArrowChange: x,
            arrowX: q,
            arrowY: te,
            shouldHideArrow: Ye,
            children: /* @__PURE__ */ g(
              Ie.div,
              {
                "data-side": I,
                "data-align": j,
                ...m,
                ref: S,
                style: {
                  ...m.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: H ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
jg.displayName = vu;
var qg = "PopperArrow", Ok = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Gg = y.forwardRef(function(e, n) {
  const { __scopePopper: r, ...o } = e, i = Ak(qg, r), s = Ok[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ g(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ g(
          Ek,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
Gg.displayName = qg;
function Nk(t) {
  return t !== null;
}
var Ik = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    const { placement: n, rects: r, middlewareData: o } = e, s = o.arrow?.centerOffset !== 0, l = s ? 0 : t.arrowWidth, a = s ? 0 : t.arrowHeight, [c, u] = Zg(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (o.arrow?.x ?? 0) + l / 2, h = (o.arrow?.y ?? 0) + a / 2;
    let p = "", m = "";
    return c === "bottom" ? (p = s ? d : `${f}px`, m = `${-a}px`) : c === "top" ? (p = s ? d : `${f}px`, m = `${r.floating.height + a}px`) : c === "right" ? (p = `${-a}px`, m = s ? d : `${h}px`) : c === "left" && (p = `${r.floating.width + a}px`, m = s ? d : `${h}px`), { data: { x: p, y: m } };
  }
});
function Zg(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var Jg = Ug, wu = Kg, Yg = jg, Xg = Gg, Lk = "Portal", Su = y.forwardRef((t, e) => {
  const { container: n, ...r } = t, [o, i] = y.useState(!1);
  An(() => i(!0), []);
  const s = n || o && globalThis?.document?.body;
  return s ? Ih.createPortal(/* @__PURE__ */ g(Ie.div, { ...r, ref: e }), s) : null;
});
Su.displayName = Lk;
function Dk(t, e) {
  return y.useReducer((n, r) => e[n][r] ?? n, t);
}
var er = (t) => {
  const { present: e, children: n } = t, r = Pk(e), o = typeof n == "function" ? n({ present: r.isPresent }) : y.Children.only(n), i = He(r.ref, Bk(o));
  return typeof n == "function" || r.isPresent ? y.cloneElement(o, { ref: i }) : null;
};
er.displayName = "Presence";
function Pk(t) {
  const [e, n] = y.useState(), r = y.useRef(null), o = y.useRef(t), i = y.useRef("none"), s = t ? "mounted" : "unmounted", [l, a] = Dk(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return y.useEffect(() => {
    const c = Qo(r.current);
    i.current = l === "mounted" ? c : "none";
  }, [l]), An(() => {
    const c = r.current, u = o.current;
    if (u !== t) {
      const f = i.current, h = Qo(c);
      t ? a("MOUNT") : h === "none" || c?.display === "none" ? a("UNMOUNT") : a(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), o.current = t;
    }
  }, [t, a]), An(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const m = Qo(r.current).includes(h.animationName);
        if (h.target === e && m && (a("ANIMATION_END"), !o.current)) {
          const b = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = b);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = Qo(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      a("ANIMATION_END");
  }, [e, a]), {
    isPresent: ["mounted", "unmountSuspended"].includes(l),
    ref: y.useCallback((c) => {
      r.current = c ? getComputedStyle(c) : null, n(c);
    }, [])
  };
}
function Qo(t) {
  return t?.animationName || "none";
}
function Bk(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Jl = "rovingFocusGroup.onEntryFocus", Hk = { bubbles: !1, cancelable: !0 }, To = "RovingFocusGroup", [Ja, Qg, Fk] = Dg(To), [_k, e0] = Dr(
  To,
  [Fk]
), [zk, Vk] = _k(To), t0 = y.forwardRef(
  (t, e) => /* @__PURE__ */ g(Ja.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ g(Ja.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ g($k, { ...t, ref: e }) }) })
);
t0.displayName = To;
var $k = y.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: i,
    currentTabStopId: s,
    defaultCurrentTabStopId: l,
    onCurrentTabStopIdChange: a,
    onEntryFocus: c,
    preventScrollOnEntryFocus: u = !1,
    ...d
  } = t, f = y.useRef(null), h = He(e, f), p = Pg(i), [m, b] = gu({
    prop: s,
    defaultProp: l ?? null,
    onChange: a,
    caller: To
  }), [C, v] = y.useState(!1), S = en(c), w = Qg(n), x = y.useRef(!1), [k, E] = y.useState(0);
  return y.useEffect(() => {
    const M = f.current;
    if (M)
      return M.addEventListener(Jl, S), () => M.removeEventListener(Jl, S);
  }, [S]), /* @__PURE__ */ g(
    zk,
    {
      scope: n,
      orientation: r,
      dir: p,
      loop: o,
      currentTabStopId: m,
      onItemFocus: y.useCallback(
        (M) => b(M),
        [b]
      ),
      onItemShiftTab: y.useCallback(() => v(!0), []),
      onFocusableItemAdd: y.useCallback(
        () => E((M) => M + 1),
        []
      ),
      onFocusableItemRemove: y.useCallback(
        () => E((M) => M - 1),
        []
      ),
      children: /* @__PURE__ */ g(
        Ie.div,
        {
          tabIndex: C || k === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: h,
          style: { outline: "none", ...t.style },
          onMouseDown: Z(t.onMouseDown, () => {
            x.current = !0;
          }),
          onFocus: Z(t.onFocus, (M) => {
            const N = !x.current;
            if (M.target === M.currentTarget && N && !C) {
              const T = new CustomEvent(Jl, Hk);
              if (M.currentTarget.dispatchEvent(T), !T.defaultPrevented) {
                const P = w().filter(($) => $.focusable), _ = P.find(($) => $.active), F = P.find(($) => $.id === m), W = [_, F, ...P].filter(
                  Boolean
                ).map(($) => $.ref.current);
                o0(W, u);
              }
            }
            x.current = !1;
          }),
          onBlur: Z(t.onBlur, () => v(!1))
        }
      )
    }
  );
}), n0 = "RovingFocusGroupItem", r0 = y.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: i,
      children: s,
      ...l
    } = t, a = fs(), c = i || a, u = Vk(n0, n), d = u.currentTabStopId === c, f = Qg(n), { onFocusableItemAdd: h, onFocusableItemRemove: p, currentTabStopId: m } = u;
    return y.useEffect(() => {
      if (r)
        return h(), () => p();
    }, [r, h, p]), /* @__PURE__ */ g(
      Ja.ItemSlot,
      {
        scope: n,
        id: c,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ g(
          Ie.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": u.orientation,
            ...l,
            ref: e,
            onMouseDown: Z(t.onMouseDown, (b) => {
              r ? u.onItemFocus(c) : b.preventDefault();
            }),
            onFocus: Z(t.onFocus, () => u.onItemFocus(c)),
            onKeyDown: Z(t.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                u.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const C = Kk(b, u.orientation, u.dir);
              if (C !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let S = f().filter((w) => w.focusable).map((w) => w.ref.current);
                if (C === "last") S.reverse();
                else if (C === "prev" || C === "next") {
                  C === "prev" && S.reverse();
                  const w = S.indexOf(b.currentTarget);
                  S = u.loop ? jk(S, w + 1) : S.slice(w + 1);
                }
                setTimeout(() => o0(S));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: d, hasTabStop: m != null }) : s
          }
        )
      }
    );
  }
);
r0.displayName = n0;
var Uk = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Wk(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function Kk(t, e, n) {
  const r = Wk(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Uk[r];
}
function o0(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function jk(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var qk = t0, Gk = r0, Zk = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, lr = /* @__PURE__ */ new WeakMap(), ei = /* @__PURE__ */ new WeakMap(), ti = {}, Yl = 0, i0 = function(t) {
  return t && (t.host || i0(t.parentNode));
}, Jk = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = i0(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, Yk = function(t, e, n, r) {
  var o = Jk(e, Array.isArray(t) ? t : [t]);
  ti[n] || (ti[n] = /* @__PURE__ */ new WeakMap());
  var i = ti[n], s = [], l = /* @__PURE__ */ new Set(), a = new Set(o), c = function(d) {
    !d || l.has(d) || (l.add(d), c(d.parentNode));
  };
  o.forEach(c);
  var u = function(d) {
    !d || a.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (l.has(f))
        u(f);
      else
        try {
          var h = f.getAttribute(r), p = h !== null && h !== "false", m = (lr.get(f) || 0) + 1, b = (i.get(f) || 0) + 1;
          lr.set(f, m), i.set(f, b), s.push(f), m === 1 && p && ei.set(f, !0), b === 1 && f.setAttribute(n, "true"), p || f.setAttribute(r, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", f, C);
        }
    });
  };
  return u(e), l.clear(), Yl++, function() {
    s.forEach(function(d) {
      var f = lr.get(d) - 1, h = i.get(d) - 1;
      lr.set(d, f), i.set(d, h), f || (ei.has(d) || d.removeAttribute(r), ei.delete(d)), h || d.removeAttribute(n);
    }), Yl--, Yl || (lr = /* @__PURE__ */ new WeakMap(), lr = /* @__PURE__ */ new WeakMap(), ei = /* @__PURE__ */ new WeakMap(), ti = {});
  };
}, s0 = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), o = Zk(t);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), Yk(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, At = function() {
  return At = Object.assign || function(e) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, At.apply(this, arguments);
};
function l0(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
      e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n;
}
function Xk(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, o = e.length, i; r < o; r++)
    (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var pi = "right-scroll-bar-position", mi = "width-before-scroll-bar", Qk = "with-scroll-bars-hidden", eE = "--removed-body-scroll-bar-size";
function Xl(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function tE(t, e) {
  var n = Xr(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var nE = typeof window < "u" ? y.useLayoutEffect : y.useEffect, kh = /* @__PURE__ */ new WeakMap();
function rE(t, e) {
  var n = tE(null, function(r) {
    return t.forEach(function(o) {
      return Xl(o, r);
    });
  });
  return nE(function() {
    var r = kh.get(n);
    if (r) {
      var o = new Set(r), i = new Set(t), s = n.current;
      o.forEach(function(l) {
        i.has(l) || Xl(l, null);
      }), i.forEach(function(l) {
        o.has(l) || Xl(l, s);
      });
    }
    kh.set(n, t);
  }, [t]), n;
}
function oE(t) {
  return t;
}
function iE(t, e) {
  e === void 0 && (e = oE);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(i) {
      var s = e(i, r);
      return n.push(s), function() {
        n = n.filter(function(l) {
          return l !== s;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(i);
      }
      n = {
        push: function(l) {
          return i(l);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var s = [];
      if (n.length) {
        var l = n;
        n = [], l.forEach(i), s = n;
      }
      var a = function() {
        var u = s;
        s = [], u.forEach(i);
      }, c = function() {
        return Promise.resolve().then(a);
      };
      c(), n = {
        push: function(u) {
          s.push(u), c();
        },
        filter: function(u) {
          return s = s.filter(u), n;
        }
      };
    }
  };
  return o;
}
function sE(t) {
  t === void 0 && (t = {});
  var e = iE(null);
  return e.options = At({ async: !0, ssr: !1 }, t), e;
}
var a0 = function(t) {
  var e = t.sideCar, n = l0(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return y.createElement(r, At({}, n));
};
a0.isSideCarExport = !0;
function lE(t, e) {
  return t.useMedium(e), a0;
}
var c0 = sE(), Ql = function() {
}, Us = y.forwardRef(function(t, e) {
  var n = y.useRef(null), r = y.useState({
    onScrollCapture: Ql,
    onWheelCapture: Ql,
    onTouchMoveCapture: Ql
  }), o = r[0], i = r[1], s = t.forwardProps, l = t.children, a = t.className, c = t.removeScrollBar, u = t.enabled, d = t.shards, f = t.sideCar, h = t.noRelative, p = t.noIsolation, m = t.inert, b = t.allowPinchZoom, C = t.as, v = C === void 0 ? "div" : C, S = t.gapMode, w = l0(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = f, k = rE([n, e]), E = At(At({}, w), o);
  return y.createElement(
    y.Fragment,
    null,
    u && y.createElement(x, { sideCar: c0, removeScrollBar: c, shards: d, noRelative: h, noIsolation: p, inert: m, setCallbacks: i, allowPinchZoom: !!b, lockRef: n, gapMode: S }),
    s ? y.cloneElement(y.Children.only(l), At(At({}, E), { ref: k })) : y.createElement(v, At({}, E, { className: a, ref: k }), l)
  );
});
Us.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Us.classNames = {
  fullWidth: mi,
  zeroRight: pi
};
var aE = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function cE() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = aE();
  return e && t.setAttribute("nonce", e), t;
}
function uE(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function dE(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var fE = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = cE()) && (uE(e, n), dE(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, hE = function() {
  var t = fE();
  return function(e, n) {
    y.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, u0 = function() {
  var t = hE(), e = function(n) {
    var r = n.styles, o = n.dynamic;
    return t(r, o), null;
  };
  return e;
}, pE = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, ea = function(t) {
  return parseInt(t || "", 10) || 0;
}, mE = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], o = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [ea(n), ea(r), ea(o)];
}, gE = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return pE;
  var e = mE(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, yE = u0(), Cr = "data-scroll-locked", bE = function(t, e, n, r) {
  var o = t.left, i = t.top, s = t.right, l = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Qk, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(l, "px ").concat(r, `;
  }
  body[`).concat(Cr, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(l, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(l, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(pi, ` {
    right: `).concat(l, "px ").concat(r, `;
  }
  
  .`).concat(mi, ` {
    margin-right: `).concat(l, "px ").concat(r, `;
  }
  
  .`).concat(pi, " .").concat(pi, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(mi, " .").concat(mi, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Cr, `] {
    `).concat(eE, ": ").concat(l, `px;
  }
`);
}, Eh = function() {
  var t = parseInt(document.body.getAttribute(Cr) || "0", 10);
  return isFinite(t) ? t : 0;
}, CE = function() {
  y.useEffect(function() {
    return document.body.setAttribute(Cr, (Eh() + 1).toString()), function() {
      var t = Eh() - 1;
      t <= 0 ? document.body.removeAttribute(Cr) : document.body.setAttribute(Cr, t.toString());
    };
  }, []);
}, vE = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, o = r === void 0 ? "margin" : r;
  CE();
  var i = y.useMemo(function() {
    return gE(o);
  }, [o]);
  return y.createElement(yE, { styles: bE(i, !e, o, n ? "" : "!important") });
}, Ya = !1;
if (typeof window < "u")
  try {
    var ni = Object.defineProperty({}, "passive", {
      get: function() {
        return Ya = !0, !0;
      }
    });
    window.addEventListener("test", ni, ni), window.removeEventListener("test", ni, ni);
  } catch {
    Ya = !1;
  }
var ar = Ya ? { passive: !1 } : !1, wE = function(t) {
  return t.tagName === "TEXTAREA";
}, d0 = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !wE(t) && n[e] === "visible")
  );
}, SE = function(t) {
  return d0(t, "overflowY");
}, xE = function(t) {
  return d0(t, "overflowX");
}, Mh = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = f0(t, r);
    if (o) {
      var i = h0(t, r), s = i[1], l = i[2];
      if (s > l)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, kE = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, EE = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, f0 = function(t, e) {
  return t === "v" ? SE(e) : xE(e);
}, h0 = function(t, e) {
  return t === "v" ? kE(e) : EE(e);
}, ME = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, TE = function(t, e, n, r, o) {
  var i = ME(t, window.getComputedStyle(e).direction), s = i * r, l = n.target, a = e.contains(l), c = !1, u = s > 0, d = 0, f = 0;
  do {
    if (!l)
      break;
    var h = h0(t, l), p = h[0], m = h[1], b = h[2], C = m - b - i * p;
    (p || C) && f0(t, l) && (d += C, f += p);
    var v = l.parentNode;
    l = v && v.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? v.host : v;
  } while (
    // portaled content
    !a && l !== document.body || // self content
    a && (e.contains(l) || e === l)
  );
  return (u && Math.abs(d) < 1 || !u && Math.abs(f) < 1) && (c = !0), c;
}, ri = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, Th = function(t) {
  return [t.deltaX, t.deltaY];
}, Rh = function(t) {
  return t && "current" in t ? t.current : t;
}, RE = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, AE = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, OE = 0, cr = [];
function NE(t) {
  var e = y.useRef([]), n = y.useRef([0, 0]), r = y.useRef(), o = y.useState(OE++)[0], i = y.useState(u0)[0], s = y.useRef(t);
  y.useEffect(function() {
    s.current = t;
  }, [t]), y.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var m = Xk([t.lockRef.current], (t.shards || []).map(Rh), !0).filter(Boolean);
      return m.forEach(function(b) {
        return b.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), m.forEach(function(b) {
          return b.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var l = y.useCallback(function(m, b) {
    if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
      return !s.current.allowPinchZoom;
    var C = ri(m), v = n.current, S = "deltaX" in m ? m.deltaX : v[0] - C[0], w = "deltaY" in m ? m.deltaY : v[1] - C[1], x, k = m.target, E = Math.abs(S) > Math.abs(w) ? "h" : "v";
    if ("touches" in m && E === "h" && k.type === "range")
      return !1;
    var M = Mh(E, k);
    if (!M)
      return !0;
    if (M ? x = E : (x = E === "v" ? "h" : "v", M = Mh(E, k)), !M)
      return !1;
    if (!r.current && "changedTouches" in m && (S || w) && (r.current = x), !x)
      return !0;
    var N = r.current || x;
    return TE(N, b, m, N === "h" ? S : w);
  }, []), a = y.useCallback(function(m) {
    var b = m;
    if (!(!cr.length || cr[cr.length - 1] !== i)) {
      var C = "deltaY" in b ? Th(b) : ri(b), v = e.current.filter(function(x) {
        return x.name === b.type && (x.target === b.target || b.target === x.shadowParent) && RE(x.delta, C);
      })[0];
      if (v && v.should) {
        b.cancelable && b.preventDefault();
        return;
      }
      if (!v) {
        var S = (s.current.shards || []).map(Rh).filter(Boolean).filter(function(x) {
          return x.contains(b.target);
        }), w = S.length > 0 ? l(b, S[0]) : !s.current.noIsolation;
        w && b.cancelable && b.preventDefault();
      }
    }
  }, []), c = y.useCallback(function(m, b, C, v) {
    var S = { name: m, delta: b, target: C, should: v, shadowParent: IE(C) };
    e.current.push(S), setTimeout(function() {
      e.current = e.current.filter(function(w) {
        return w !== S;
      });
    }, 1);
  }, []), u = y.useCallback(function(m) {
    n.current = ri(m), r.current = void 0;
  }, []), d = y.useCallback(function(m) {
    c(m.type, Th(m), m.target, l(m, t.lockRef.current));
  }, []), f = y.useCallback(function(m) {
    c(m.type, ri(m), m.target, l(m, t.lockRef.current));
  }, []);
  y.useEffect(function() {
    return cr.push(i), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", a, ar), document.addEventListener("touchmove", a, ar), document.addEventListener("touchstart", u, ar), function() {
      cr = cr.filter(function(m) {
        return m !== i;
      }), document.removeEventListener("wheel", a, ar), document.removeEventListener("touchmove", a, ar), document.removeEventListener("touchstart", u, ar);
    };
  }, []);
  var h = t.removeScrollBar, p = t.inert;
  return y.createElement(
    y.Fragment,
    null,
    p ? y.createElement(i, { styles: AE(o) }) : null,
    h ? y.createElement(vE, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function IE(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const LE = lE(c0, NE);
var xu = y.forwardRef(function(t, e) {
  return y.createElement(Us, At({}, t, { ref: e, sideCar: LE }));
});
xu.classNames = Us.classNames;
var Xa = ["Enter", " "], DE = ["ArrowDown", "PageUp", "Home"], p0 = ["ArrowUp", "PageDown", "End"], PE = [...DE, ...p0], BE = {
  ltr: [...Xa, "ArrowRight"],
  rtl: [...Xa, "ArrowLeft"]
}, HE = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Ro = "Menu", [go, FE, _E] = Dg(Ro), [tr, m0] = Dr(Ro, [
  _E,
  $s,
  e0
]), Ws = $s(), g0 = e0(), [zE, nr] = tr(Ro), [VE, Ao] = tr(Ro), y0 = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: o, onOpenChange: i, modal: s = !0 } = t, l = Ws(e), [a, c] = y.useState(null), u = y.useRef(!1), d = en(i), f = Pg(o);
  return y.useEffect(() => {
    const h = () => {
      u.current = !0, document.addEventListener("pointerdown", p, { capture: !0, once: !0 }), document.addEventListener("pointermove", p, { capture: !0, once: !0 });
    }, p = () => u.current = !1;
    return document.addEventListener("keydown", h, { capture: !0 }), () => {
      document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", p, { capture: !0 }), document.removeEventListener("pointermove", p, { capture: !0 });
    };
  }, []), /* @__PURE__ */ g(Jg, { ...l, children: /* @__PURE__ */ g(
    zE,
    {
      scope: e,
      open: n,
      onOpenChange: d,
      content: a,
      onContentChange: c,
      children: /* @__PURE__ */ g(
        VE,
        {
          scope: e,
          onClose: y.useCallback(() => d(!1), [d]),
          isUsingKeyboardRef: u,
          dir: f,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
y0.displayName = Ro;
var $E = "MenuAnchor", ku = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ws(n);
    return /* @__PURE__ */ g(wu, { ...o, ...r, ref: e });
  }
);
ku.displayName = $E;
var Eu = "MenuPortal", [UE, b0] = tr(Eu, {
  forceMount: void 0
}), C0 = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: o } = t, i = nr(Eu, e);
  return /* @__PURE__ */ g(UE, { scope: e, forceMount: n, children: /* @__PURE__ */ g(er, { present: n || i.open, children: /* @__PURE__ */ g(Su, { asChild: !0, container: o, children: r }) }) });
};
C0.displayName = Eu;
var it = "MenuContent", [WE, Mu] = tr(it), v0 = y.forwardRef(
  (t, e) => {
    const n = b0(it, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, i = nr(it, t.__scopeMenu), s = Ao(it, t.__scopeMenu);
    return /* @__PURE__ */ g(go.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ g(er, { present: r || i.open, children: /* @__PURE__ */ g(go.Slot, { scope: t.__scopeMenu, children: s.modal ? /* @__PURE__ */ g(KE, { ...o, ref: e }) : /* @__PURE__ */ g(jE, { ...o, ref: e }) }) }) });
  }
), KE = y.forwardRef(
  (t, e) => {
    const n = nr(it, t.__scopeMenu), r = y.useRef(null), o = He(e, r);
    return y.useEffect(() => {
      const i = r.current;
      if (i) return s0(i);
    }, []), /* @__PURE__ */ g(
      Tu,
      {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Z(
          t.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), jE = y.forwardRef((t, e) => {
  const n = nr(it, t.__scopeMenu);
  return /* @__PURE__ */ g(
    Tu,
    {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), qE = /* @__PURE__ */ mo("MenuContent.ScrollLock"), Tu = y.forwardRef(
  (t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: l,
      onEntryFocus: a,
      onEscapeKeyDown: c,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      onDismiss: h,
      disableOutsideScroll: p,
      ...m
    } = t, b = nr(it, n), C = Ao(it, n), v = Ws(n), S = g0(n), w = FE(n), [x, k] = y.useState(null), E = y.useRef(null), M = He(e, E, b.onContentChange), N = y.useRef(0), T = y.useRef(""), P = y.useRef(0), _ = y.useRef(null), F = y.useRef("right"), D = y.useRef(0), W = p ? xu : y.Fragment, $ = p ? { as: qE, allowPinchZoom: !0 } : void 0, H = (I) => {
      const j = T.current + I, re = w().filter((ne) => !ne.disabled), q = document.activeElement, te = re.find((ne) => ne.ref.current === q)?.textValue, Ye = re.map((ne) => ne.textValue), fe = iM(Ye, j, te), xe = re.find((ne) => ne.textValue === fe)?.ref.current;
      (function ne(oe) {
        T.current = oe, window.clearTimeout(N.current), oe !== "" && (N.current = window.setTimeout(() => ne(""), 1e3));
      })(j), xe && setTimeout(() => xe.focus());
    };
    y.useEffect(() => () => window.clearTimeout(N.current), []), Fg();
    const O = y.useCallback((I) => F.current === _.current?.side && lM(I, _.current?.area), []);
    return /* @__PURE__ */ g(
      WE,
      {
        scope: n,
        searchRef: T,
        onItemEnter: y.useCallback(
          (I) => {
            O(I) && I.preventDefault();
          },
          [O]
        ),
        onItemLeave: y.useCallback(
          (I) => {
            O(I) || (E.current?.focus(), k(null));
          },
          [O]
        ),
        onTriggerLeave: y.useCallback(
          (I) => {
            O(I) && I.preventDefault();
          },
          [O]
        ),
        pointerGraceTimerRef: P,
        onPointerGraceIntentChange: y.useCallback((I) => {
          _.current = I;
        }, []),
        children: /* @__PURE__ */ g(W, { ...$, children: /* @__PURE__ */ g(
          bu,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: Z(i, (I) => {
              I.preventDefault(), E.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ g(
              yu,
              {
                asChild: !0,
                disableOutsidePointerEvents: l,
                onEscapeKeyDown: c,
                onPointerDownOutside: u,
                onFocusOutside: d,
                onInteractOutside: f,
                onDismiss: h,
                children: /* @__PURE__ */ g(
                  qk,
                  {
                    asChild: !0,
                    ...S,
                    dir: C.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: x,
                    onCurrentTabStopIdChange: k,
                    onEntryFocus: Z(a, (I) => {
                      C.isUsingKeyboardRef.current || I.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ g(
                      Yg,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": B0(b.open),
                        "data-radix-menu-content": "",
                        dir: C.dir,
                        ...v,
                        ...m,
                        ref: M,
                        style: { outline: "none", ...m.style },
                        onKeyDown: Z(m.onKeyDown, (I) => {
                          const re = I.target.closest("[data-radix-menu-content]") === I.currentTarget, q = I.ctrlKey || I.altKey || I.metaKey, te = I.key.length === 1;
                          re && (I.key === "Tab" && I.preventDefault(), !q && te && H(I.key));
                          const Ye = E.current;
                          if (I.target !== Ye || !PE.includes(I.key)) return;
                          I.preventDefault();
                          const xe = w().filter((ne) => !ne.disabled).map((ne) => ne.ref.current);
                          p0.includes(I.key) && xe.reverse(), rM(xe);
                        }),
                        onBlur: Z(t.onBlur, (I) => {
                          I.currentTarget.contains(I.target) || (window.clearTimeout(N.current), T.current = "");
                        }),
                        onPointerMove: Z(
                          t.onPointerMove,
                          yo((I) => {
                            const j = I.target, re = D.current !== I.clientX;
                            if (I.currentTarget.contains(j) && re) {
                              const q = I.clientX > D.current ? "right" : "left";
                              F.current = q, D.current = I.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
v0.displayName = it;
var GE = "MenuGroup", Ru = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ g(Ie.div, { role: "group", ...r, ref: e });
  }
);
Ru.displayName = GE;
var ZE = "MenuLabel", w0 = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ g(Ie.div, { ...r, ref: e });
  }
);
w0.displayName = ZE;
var hs = "MenuItem", Ah = "menu.itemSelect", Ks = y.forwardRef(
  (t, e) => {
    const { disabled: n = !1, onSelect: r, ...o } = t, i = y.useRef(null), s = Ao(hs, t.__scopeMenu), l = Mu(hs, t.__scopeMenu), a = He(e, i), c = y.useRef(!1), u = () => {
      const d = i.current;
      if (!n && d) {
        const f = new CustomEvent(Ah, { bubbles: !0, cancelable: !0 });
        d.addEventListener(Ah, (h) => r?.(h), { once: !0 }), Lg(d, f), f.defaultPrevented ? c.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ g(
      S0,
      {
        ...o,
        ref: a,
        disabled: n,
        onClick: Z(t.onClick, u),
        onPointerDown: (d) => {
          t.onPointerDown?.(d), c.current = !0;
        },
        onPointerUp: Z(t.onPointerUp, (d) => {
          c.current || d.currentTarget?.click();
        }),
        onKeyDown: Z(t.onKeyDown, (d) => {
          const f = l.searchRef.current !== "";
          n || f && d.key === " " || Xa.includes(d.key) && (d.currentTarget.click(), d.preventDefault());
        })
      }
    );
  }
);
Ks.displayName = hs;
var S0 = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = t, s = Mu(hs, n), l = g0(n), a = y.useRef(null), c = He(e, a), [u, d] = y.useState(!1), [f, h] = y.useState("");
    return y.useEffect(() => {
      const p = a.current;
      p && h((p.textContent ?? "").trim());
    }, [i.children]), /* @__PURE__ */ g(
      go.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? f,
        children: /* @__PURE__ */ g(Gk, { asChild: !0, ...l, focusable: !r, children: /* @__PURE__ */ g(
          Ie.div,
          {
            role: "menuitem",
            "data-highlighted": u ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: c,
            onPointerMove: Z(
              t.onPointerMove,
              yo((p) => {
                r ? s.onItemLeave(p) : (s.onItemEnter(p), p.defaultPrevented || p.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Z(
              t.onPointerLeave,
              yo((p) => s.onItemLeave(p))
            ),
            onFocus: Z(t.onFocus, () => d(!0)),
            onBlur: Z(t.onBlur, () => d(!1))
          }
        ) })
      }
    );
  }
), JE = "MenuCheckboxItem", x0 = y.forwardRef(
  (t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = t;
    return /* @__PURE__ */ g(R0, { scope: t.__scopeMenu, checked: n, children: /* @__PURE__ */ g(
      Ks,
      {
        role: "menuitemcheckbox",
        "aria-checked": ps(n) ? "mixed" : n,
        ...o,
        ref: e,
        "data-state": Ou(n),
        onSelect: Z(
          o.onSelect,
          () => r?.(ps(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
x0.displayName = JE;
var k0 = "MenuRadioGroup", [YE, XE] = tr(
  k0,
  { value: void 0, onValueChange: () => {
  } }
), E0 = y.forwardRef(
  (t, e) => {
    const { value: n, onValueChange: r, ...o } = t, i = en(r);
    return /* @__PURE__ */ g(YE, { scope: t.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ g(Ru, { ...o, ref: e }) });
  }
);
E0.displayName = k0;
var M0 = "MenuRadioItem", T0 = y.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, o = XE(M0, t.__scopeMenu), i = n === o.value;
    return /* @__PURE__ */ g(R0, { scope: t.__scopeMenu, checked: i, children: /* @__PURE__ */ g(
      Ks,
      {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: e,
        "data-state": Ou(i),
        onSelect: Z(
          r.onSelect,
          () => o.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
T0.displayName = M0;
var Au = "MenuItemIndicator", [R0, QE] = tr(
  Au,
  { checked: !1 }
), A0 = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, forceMount: r, ...o } = t, i = QE(Au, n);
    return /* @__PURE__ */ g(
      er,
      {
        present: r || ps(i.checked) || i.checked === !0,
        children: /* @__PURE__ */ g(
          Ie.span,
          {
            ...o,
            ref: e,
            "data-state": Ou(i.checked)
          }
        )
      }
    );
  }
);
A0.displayName = Au;
var eM = "MenuSeparator", O0 = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ g(
      Ie.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
O0.displayName = eM;
var tM = "MenuArrow", N0 = y.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ws(n);
    return /* @__PURE__ */ g(Xg, { ...o, ...r, ref: e });
  }
);
N0.displayName = tM;
var nM = "MenuSub", [r8, I0] = tr(nM), Vr = "MenuSubTrigger", L0 = y.forwardRef(
  (t, e) => {
    const n = nr(Vr, t.__scopeMenu), r = Ao(Vr, t.__scopeMenu), o = I0(Vr, t.__scopeMenu), i = Mu(Vr, t.__scopeMenu), s = y.useRef(null), { pointerGraceTimerRef: l, onPointerGraceIntentChange: a } = i, c = { __scopeMenu: t.__scopeMenu }, u = y.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return y.useEffect(() => u, [u]), y.useEffect(() => {
      const d = l.current;
      return () => {
        window.clearTimeout(d), a(null);
      };
    }, [l, a]), /* @__PURE__ */ g(ku, { asChild: !0, ...c, children: /* @__PURE__ */ g(
      S0,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": B0(n.open),
        ...t,
        ref: Vs(e, o.onTriggerChange),
        onClick: (d) => {
          t.onClick?.(d), !(t.disabled || d.defaultPrevented) && (d.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Z(
          t.onPointerMove,
          yo((d) => {
            i.onItemEnter(d), !d.defaultPrevented && !t.disabled && !n.open && !s.current && (i.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), u();
            }, 100));
          })
        ),
        onPointerLeave: Z(
          t.onPointerLeave,
          yo((d) => {
            u();
            const f = n.content?.getBoundingClientRect();
            if (f) {
              const h = n.content?.dataset.side, p = h === "right", m = p ? -5 : 5, b = f[p ? "left" : "right"], C = f[p ? "right" : "left"];
              i.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: d.clientX + m, y: d.clientY },
                  { x: b, y: f.top },
                  { x: C, y: f.top },
                  { x: C, y: f.bottom },
                  { x: b, y: f.bottom }
                ],
                side: h
              }), window.clearTimeout(l.current), l.current = window.setTimeout(
                () => i.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (i.onTriggerLeave(d), d.defaultPrevented) return;
              i.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Z(t.onKeyDown, (d) => {
          const f = i.searchRef.current !== "";
          t.disabled || f && d.key === " " || BE[r.dir].includes(d.key) && (n.onOpenChange(!0), n.content?.focus(), d.preventDefault());
        })
      }
    ) });
  }
);
L0.displayName = Vr;
var D0 = "MenuSubContent", P0 = y.forwardRef(
  (t, e) => {
    const n = b0(it, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, i = nr(it, t.__scopeMenu), s = Ao(it, t.__scopeMenu), l = I0(D0, t.__scopeMenu), a = y.useRef(null), c = He(e, a);
    return /* @__PURE__ */ g(go.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ g(er, { present: r || i.open, children: /* @__PURE__ */ g(go.Slot, { scope: t.__scopeMenu, children: /* @__PURE__ */ g(
      Tu,
      {
        id: l.contentId,
        "aria-labelledby": l.triggerId,
        ...o,
        ref: c,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (u) => {
          s.isUsingKeyboardRef.current && a.current?.focus(), u.preventDefault();
        },
        onCloseAutoFocus: (u) => u.preventDefault(),
        onFocusOutside: Z(t.onFocusOutside, (u) => {
          u.target !== l.trigger && i.onOpenChange(!1);
        }),
        onEscapeKeyDown: Z(t.onEscapeKeyDown, (u) => {
          s.onClose(), u.preventDefault();
        }),
        onKeyDown: Z(t.onKeyDown, (u) => {
          const d = u.currentTarget.contains(u.target), f = HE[s.dir].includes(u.key);
          d && f && (i.onOpenChange(!1), l.trigger?.focus(), u.preventDefault());
        })
      }
    ) }) }) });
  }
);
P0.displayName = D0;
function B0(t) {
  return t ? "open" : "closed";
}
function ps(t) {
  return t === "indeterminate";
}
function Ou(t) {
  return ps(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function rM(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function oM(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function iM(t, e, n) {
  const o = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e, i = n ? t.indexOf(n) : -1;
  let s = oM(t, Math.max(i, 0));
  o.length === 1 && (s = s.filter((c) => c !== n));
  const a = s.find(
    (c) => c.toLowerCase().startsWith(o.toLowerCase())
  );
  return a !== n ? a : void 0;
}
function sM(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const l = e[i], a = e[s], c = l.x, u = l.y, d = a.x, f = a.y;
    u > r != f > r && n < (d - c) * (r - u) / (f - u) + c && (o = !o);
  }
  return o;
}
function lM(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return sM(n, e);
}
function yo(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
var aM = y0, cM = ku, uM = C0, dM = v0, fM = Ru, hM = w0, pM = Ks, mM = x0, gM = E0, yM = T0, bM = A0, CM = O0, vM = N0, wM = L0, SM = P0, js = "DropdownMenu", [xM, o8] = Dr(
  js,
  [m0]
), $e = m0(), [kM, H0] = xM(js), F0 = (t) => {
  const {
    __scopeDropdownMenu: e,
    children: n,
    dir: r,
    open: o,
    defaultOpen: i,
    onOpenChange: s,
    modal: l = !0
  } = t, a = $e(e), c = y.useRef(null), [u, d] = gu({
    prop: o,
    defaultProp: i ?? !1,
    onChange: s,
    caller: js
  });
  return /* @__PURE__ */ g(
    kM,
    {
      scope: e,
      triggerId: fs(),
      triggerRef: c,
      contentId: fs(),
      open: u,
      onOpenChange: d,
      onOpenToggle: y.useCallback(() => d((f) => !f), [d]),
      modal: l,
      children: /* @__PURE__ */ g(aM, { ...a, open: u, onOpenChange: d, dir: r, modal: l, children: n })
    }
  );
};
F0.displayName = js;
var _0 = "DropdownMenuTrigger", z0 = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = t, i = H0(_0, n), s = $e(n);
    return /* @__PURE__ */ g(cM, { asChild: !0, ...s, children: /* @__PURE__ */ g(
      Ie.button,
      {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: Vs(e, i.triggerRef),
        onPointerDown: Z(t.onPointerDown, (l) => {
          !r && l.button === 0 && l.ctrlKey === !1 && (i.onOpenToggle(), i.open || l.preventDefault());
        }),
        onKeyDown: Z(t.onKeyDown, (l) => {
          r || (["Enter", " "].includes(l.key) && i.onOpenToggle(), l.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(l.key) && l.preventDefault());
        })
      }
    ) });
  }
);
z0.displayName = _0;
var EM = "DropdownMenuPortal", V0 = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = $e(e);
  return /* @__PURE__ */ g(uM, { ...r, ...n });
};
V0.displayName = EM;
var $0 = "DropdownMenuContent", U0 = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = H0($0, n), i = $e(n), s = y.useRef(!1);
    return /* @__PURE__ */ g(
      dM,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...i,
        ...r,
        ref: e,
        onCloseAutoFocus: Z(t.onCloseAutoFocus, (l) => {
          s.current || o.triggerRef.current?.focus(), s.current = !1, l.preventDefault();
        }),
        onInteractOutside: Z(t.onInteractOutside, (l) => {
          const a = l.detail.originalEvent, c = a.button === 0 && a.ctrlKey === !0, u = a.button === 2 || c;
          (!o.modal || u) && (s.current = !0);
        }),
        style: {
          ...t.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
U0.displayName = $0;
var MM = "DropdownMenuGroup", TM = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
    return /* @__PURE__ */ g(fM, { ...o, ...r, ref: e });
  }
);
TM.displayName = MM;
var RM = "DropdownMenuLabel", AM = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
    return /* @__PURE__ */ g(hM, { ...o, ...r, ref: e });
  }
);
AM.displayName = RM;
var OM = "DropdownMenuItem", W0 = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
    return /* @__PURE__ */ g(pM, { ...o, ...r, ref: e });
  }
);
W0.displayName = OM;
var NM = "DropdownMenuCheckboxItem", IM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(mM, { ...o, ...r, ref: e });
});
IM.displayName = NM;
var LM = "DropdownMenuRadioGroup", DM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(gM, { ...o, ...r, ref: e });
});
DM.displayName = LM;
var PM = "DropdownMenuRadioItem", BM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(yM, { ...o, ...r, ref: e });
});
BM.displayName = PM;
var HM = "DropdownMenuItemIndicator", FM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(bM, { ...o, ...r, ref: e });
});
FM.displayName = HM;
var _M = "DropdownMenuSeparator", zM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(CM, { ...o, ...r, ref: e });
});
zM.displayName = _M;
var VM = "DropdownMenuArrow", $M = y.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
    return /* @__PURE__ */ g(vM, { ...o, ...r, ref: e });
  }
);
$M.displayName = VM;
var UM = "DropdownMenuSubTrigger", WM = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(wM, { ...o, ...r, ref: e });
});
WM.displayName = UM;
var KM = "DropdownMenuSubContent", K0 = y.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = $e(n);
  return /* @__PURE__ */ g(
    SM,
    {
      ...o,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
K0.displayName = KM;
var jM = F0, j0 = z0, qM = V0, q0 = U0, GM = W0, G0 = K0;
function qs({
  ...t
}) {
  return /* @__PURE__ */ g(jM, { modal: !1, ...t });
}
function Z0({
  ...t
}) {
  return /* @__PURE__ */ g(qM, { ...t });
}
const Oo = y.forwardRef(({ ...t }, e) => /* @__PURE__ */ g(j0, { ref: e, ...t }));
Oo.displayName = j0.displayName;
const Gs = GM, ZM = y.forwardRef(({ className: t, portal: e = !0, ...n }, r) => {
  const o = /* @__PURE__ */ g(
    G0,
    {
      ref: r,
      className: Re("tiptap-dropdown-menu", t),
      ...n
    }
  );
  return e ? /* @__PURE__ */ g(Z0, { ...typeof e == "object" ? e : {}, children: o }) : o;
});
ZM.displayName = G0.displayName;
const No = y.forwardRef(({ className: t, sideOffset: e = 4, portal: n = !1, ...r }, o) => {
  const i = /* @__PURE__ */ g(
    q0,
    {
      ref: o,
      sideOffset: e,
      onCloseAutoFocus: (s) => s.preventDefault(),
      className: Re("tiptap-dropdown-menu", t),
      ...r
    }
  );
  return n ? /* @__PURE__ */ g(Z0, { ...typeof n == "object" ? n : {}, children: i }) : i;
});
No.displayName = q0.displayName;
const J0 = y.forwardRef(
  ({
    editor: t,
    levels: e = [1, 2, 3, 4, 5, 6],
    hideWhenUnavailable: n = !1,
    portal: r = !1,
    onOpenChange: o,
    ...i
  }, s) => {
    const { editor: l } = Y(t), [a, c] = y.useState(!1), { isVisible: u, isActive: d, canToggle: f, Icon: h } = YM({
      editor: l,
      levels: e,
      hideWhenUnavailable: n
    }), p = y.useCallback(
      (m) => {
        !l || !f || (c(m), o?.(m));
      },
      [f, l, o]
    );
    return u ? /* @__PURE__ */ R(qs, { modal: !0, open: a, onOpenChange: p, children: [
      /* @__PURE__ */ g(Oo, { asChild: !0, children: /* @__PURE__ */ R(
        J,
        {
          type: "button",
          "data-style": "ghost",
          "data-active-state": d ? "on" : "off",
          role: "button",
          tabIndex: -1,
          disabled: !f,
          "data-disabled": !f,
          "aria-label": "Format text as heading",
          "aria-pressed": d,
          tooltip: "Heading",
          ...i,
          ref: s,
          children: [
            /* @__PURE__ */ g(h, { className: "tiptap-button-icon" }),
            /* @__PURE__ */ g(Mo, { className: "tiptap-button-dropdown-small" })
          ]
        }
      ) }),
      /* @__PURE__ */ g(No, { align: "start", portal: r, children: /* @__PURE__ */ g(St, { children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { children: e.map((m) => /* @__PURE__ */ g(Gs, { asChild: !0, children: /* @__PURE__ */ g(
        bg,
        {
          editor: l,
          level: m,
          text: `Heading ${m}`,
          showTooltip: !1,
          showShortcut: !0
        }
      ) }, `heading-${m}`)) }) }) }) })
    ] }) : null;
  }
);
J0.displayName = "HeadingDropdownMenu";
const Y0 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          d: "M6 3C6.55228 3 7 3.44772 7 4V11H17V4C17 3.44772 17.4477 3 18 3C18.5523 3 19 3.44772 19 4V20C19 20.5523 18.5523 21 18 21C17.4477 21 17 20.5523 17 20V13H7V20C7 20.5523 6.55228 21 6 21C5.44772 21 5 20.5523 5 20V4C5 3.44772 5.44772 3 6 3Z",
          fill: "currentColor"
        }
      )
    }
  )
);
Y0.displayName = "HeadingIcon";
function JM(t, e = [1, 2, 3, 4, 5, 6]) {
  if (!(!t || !t.isEditable))
    return e.find((n) => mu(t, n));
}
function YM(t) {
  const {
    editor: e,
    levels: n = [1, 2, 3, 4, 5, 6],
    hideWhenUnavailable: r = !1
  } = t || {}, { editor: o } = Y(e), [i, s] = y.useState(!0), l = JM(o, n), a = mu(o), c = po(o);
  return y.useEffect(() => {
    if (!o) return;
    const u = () => {
      s(
        Ig({ editor: o, hideWhenUnavailable: r, level: n })
      );
    };
    return u(), o.on("selectionUpdate", u), () => {
      o.off("selectionUpdate", u);
    };
  }, [o, r, n]), {
    isVisible: i,
    activeLevel: l,
    isActive: a,
    canToggle: c,
    levels: n,
    label: "Heading",
    Icon: l ? Ng[l] : Y0
  };
}
function XM({
  type: t,
  shortcutKeys: e = Qa[t]
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: e }) });
}
const X0 = y.forwardRef(
  ({
    editor: t,
    type: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onToggled: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), {
      isVisible: d,
      canToggle: f,
      isActive: h,
      handleToggle: p,
      label: m,
      shortcutKeys: b,
      Icon: C
    } = t6({
      editor: u,
      type: e,
      hideWhenUnavailable: r,
      onToggled: o
    }), v = y.useCallback(
      (S) => {
        s?.(S), !S.defaultPrevented && p();
      },
      [p, s]
    );
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": h ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !f,
        "data-disabled": !f,
        "aria-label": m,
        "aria-pressed": h,
        tooltip: m,
        onClick: v,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(C, { className: "tiptap-button-icon" }),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(XM, { type: e, shortcutKeys: b })
        ] })
      }
    ) : null;
  }
);
X0.displayName = "ListButton";
const Zs = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7 6C7 5.44772 7.44772 5 8 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H8C7.44772 7 7 6.55228 7 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7 12C7 11.4477 7.44772 11 8 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H8C7.44772 13 7 12.5523 7 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7 18C7 17.4477 7.44772 17 8 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H8C7.44772 19 7 18.5523 7 18Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 5.44772 2.44772 5 3 5H3.01C3.56228 5 4.01 5.44772 4.01 6C4.01 6.55228 3.56228 7 3.01 7H3C2.44772 7 2 6.55228 2 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 12C2 11.4477 2.44772 11 3 11H3.01C3.56228 11 4.01 11.4477 4.01 12C4.01 12.5523 3.56228 13 3.01 13H3C2.44772 13 2 12.5523 2 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 18C2 17.4477 2.44772 17 3 17H3.01C3.56228 17 4.01 17.4477 4.01 18C4.01 18.5523 3.56228 19 3.01 19H3C2.44772 19 2 18.5523 2 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Zs.displayName = "ListIcon";
const Nu = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9 6C9 5.44772 9.44772 5 10 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H10C9.44772 7 9 6.55228 9 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9 12C9 11.4477 9.44772 11 10 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H10C9.44772 13 9 12.5523 9 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9 18C9 17.4477 9.44772 17 10 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H10C9.44772 19 9 18.5523 9 18Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M3 6C3 5.44772 3.44772 5 4 5H5C5.55228 5 6 5.44772 6 6V10C6 10.5523 5.55228 11 5 11C4.44772 11 4 10.5523 4 10V7C3.44772 7 3 6.55228 3 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M3 10C3 9.44772 3.44772 9 4 9H6C6.55228 9 7 9.44772 7 10C7 10.5523 6.55228 11 6 11H4C3.44772 11 3 10.5523 3 10Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M5.82219 13.0431C6.54543 13.4047 6.99997 14.1319 6.99997 15C6.99997 15.5763 6.71806 16.0426 6.48747 16.35C6.31395 16.5814 6.1052 16.8044 5.91309 17H5.99997C6.55226 17 6.99997 17.4477 6.99997 18C6.99997 18.5523 6.55226 19 5.99997 19H3.99997C3.44769 19 2.99997 18.5523 2.99997 18C2.99997 17.4237 3.28189 16.9575 3.51247 16.65C3.74323 16.3424 4.03626 16.0494 4.26965 15.8161C4.27745 15.8083 4.2852 15.8006 4.29287 15.7929C4.55594 15.5298 4.75095 15.3321 4.88748 15.15C4.96287 15.0495 4.99021 14.9922 4.99911 14.9714C4.99535 14.9112 4.9803 14.882 4.9739 14.8715C4.96613 14.8588 4.95382 14.845 4.92776 14.8319C4.87723 14.8067 4.71156 14.7623 4.44719 14.8944C3.95321 15.1414 3.35254 14.9412 3.10555 14.4472C2.85856 13.9533 3.05878 13.3526 3.55276 13.1056C4.28839 12.7378 5.12272 12.6934 5.82219 13.0431Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Nu.displayName = "ListOrderedIcon";
const Iu = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 4.89543 2.89543 4 4 4H8C9.10457 4 10 4.89543 10 6V10C10 11.1046 9.10457 12 8 12H4C2.89543 12 2 11.1046 2 10V6ZM8 6H4V10H8V6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.70711 14.2929C10.0976 14.6834 10.0976 15.3166 9.70711 15.7071L5.70711 19.7071C5.31658 20.0976 4.68342 20.0976 4.29289 19.7071L2.29289 17.7071C1.90237 17.3166 1.90237 16.6834 2.29289 16.2929C2.68342 15.9024 3.31658 15.9024 3.70711 16.2929L5 17.5858L8.29289 14.2929C8.68342 13.9024 9.31658 13.9024 9.70711 14.2929Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12 6C12 5.44772 12.4477 5 13 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H13C12.4477 7 12 6.55228 12 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12 12C12 11.4477 12.4477 11 13 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H13C12.4477 13 12 12.5523 12 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12 18C12 17.4477 12.4477 17 13 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H13C12.4477 19 12 18.5523 12 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Iu.displayName = "ListTodoIcon";
const Q0 = {
  bulletList: Zs,
  orderedList: Nu,
  taskList: Iu
}, QM = {
  bulletList: "Bullet List",
  orderedList: "Ordered List",
  taskList: "Task List"
}, Qa = {
  bulletList: "mod+shift+8",
  orderedList: "mod+shift+7",
  taskList: "mod+shift+9"
};
function Js(t, e, n = !0) {
  if (!t || !t.isEditable || !rn(e, t) || wt(t, ["image"]))
    return !1;
  if (!n)
    switch (e) {
      case "bulletList":
        return t.can().toggleBulletList();
      case "orderedList":
        return t.can().toggleOrderedList();
      case "taskList":
        return t.can().toggleList("taskList", "taskItem");
      default:
        return !1;
    }
  try {
    const o = t.view.state, i = o.selection;
    if (i.empty || i instanceof V) {
      const s = In({
        editor: t,
        node: o.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(s)) return !1;
    }
    return !0;
  } catch {
    return !1;
  }
}
function Lu(t, e) {
  if (!t || !t.isEditable) return !1;
  switch (e) {
    case "bulletList":
      return t.isActive("bulletList");
    case "orderedList":
      return t.isActive("orderedList");
    case "taskList":
      return t.isActive("taskList");
    default:
      return !1;
  }
}
function e2(t, e) {
  if (!t || !t.isEditable || !Js(t, e)) return !1;
  try {
    const n = t.view, r = n.state, o = r.selection;
    let i = t.chain().focus();
    if (o instanceof V && !o.empty)
      if (t.isActive(e))
        i.liftListItem("listItem").lift("bulletList").lift("orderedList").lift("taskList").run();
      else {
        const l = {
          bulletList: () => i.toggleBulletList(),
          orderedList: () => i.toggleOrderedList(),
          taskList: () => i.toggleList("taskList", "taskItem")
        }[e];
        if (!l) return !1;
        l().run();
      }
    else if (o instanceof z) {
      const s = o.node.firstChild?.firstChild, l = o.node.lastChild?.lastChild, a = s ? o.from + s.nodeSize : o.from + 1, c = l ? o.to - l.nodeSize : o.to - 1;
      if (i = i.setTextSelection({ from: a, to: c }).clearNodes(), t.isActive(e))
        i.liftListItem("listItem").lift("bulletList").lift("orderedList").lift("taskList").run();
      else {
        const d = {
          bulletList: () => i.toggleBulletList(),
          orderedList: () => i.toggleOrderedList(),
          taskList: () => i.toggleList("taskList", "taskItem")
        }[e];
        if (!d) return !1;
        d().run();
      }
    } else {
      const s = In({
        editor: t,
        node: r.selection.$anchor.node(1)
      })?.pos;
      if (Ht(s)) {
        const l = r.tr.setSelection(z.create(r.doc, s));
        return n.dispatch(l), e2(t, e);
      }
      if (t.isActive(e))
        i.liftListItem("listItem").lift("bulletList").lift("orderedList").lift("taskList").run();
      else {
        const a = {
          bulletList: () => i.toggleBulletList(),
          orderedList: () => i.toggleOrderedList(),
          taskList: () => i.toggleList("taskList", "taskItem")
        }[e];
        if (!a) return !1;
        a().run();
      }
    }
    return !0;
  } catch {
    return !1;
  }
}
function e6(t) {
  const { editor: e, type: n, hideWhenUnavailable: r } = t;
  return !e || !e.isEditable || !rn(n, e) ? !1 : r && !e.isActive("code") ? Js(e, n) : !0;
}
function t6(t) {
  const {
    editor: e,
    type: n,
    hideWhenUnavailable: r = !1,
    onToggled: o
  } = t, { editor: i } = Y(e), s = ut(), [l, a] = y.useState(!0), c = Js(i, n), u = Lu(i, n);
  y.useEffect(() => {
    if (!i) return;
    const f = () => {
      a(e6({ editor: i, type: n, hideWhenUnavailable: r }));
    };
    return f(), i.on("selectionUpdate", f), () => {
      i.off("selectionUpdate", f);
    };
  }, [i, n, r]);
  const d = y.useCallback(() => {
    if (!i) return !1;
    const f = e2(i, n);
    return f && o?.(), f;
  }, [i, n, o]);
  return Lr(
    Qa[n],
    (f) => {
      f.preventDefault(), d();
    },
    {
      enabled: l && c,
      enableOnContentEditable: !s,
      enableOnFormTags: !0
    }
  ), {
    isVisible: l,
    isActive: u,
    handleToggle: d,
    canToggle: c,
    label: QM[n],
    shortcutKeys: Qa[n],
    Icon: Q0[n]
  };
}
const n6 = [
  {
    label: "Bullet List",
    type: "bulletList",
    icon: Zs
  },
  {
    label: "Ordered List",
    type: "orderedList",
    icon: Nu
  },
  {
    label: "Task List",
    type: "taskList",
    icon: Iu
  }
];
function r6(t, e) {
  return !t || !t.isEditable ? !1 : e.some((n) => Js(t, n));
}
function o6(t, e) {
  return !t || !t.isEditable ? !1 : e.some((n) => Lu(t, n));
}
function i6(t) {
  return n6.filter(
    (e) => !e.type || t.includes(e.type)
  );
}
function s6(t) {
  const { editor: e, hideWhenUnavailable: n, listInSchema: r, canToggleAny: o } = t;
  return !r || !e ? !1 : n && !e.isActive("code") ? o : !0;
}
function l6(t, e) {
  if (!(!t || !t.isEditable))
    return e.find((n) => Lu(t, n));
}
function a6(t) {
  const {
    editor: e,
    types: n = ["bulletList", "orderedList", "taskList"],
    hideWhenUnavailable: r = !1
  } = t || {}, { editor: o } = Y(e), [i, s] = y.useState(!1), l = n.some((h) => rn(h, o)), a = y.useMemo(
    () => i6(n),
    [n]
  ), c = r6(o, n), u = o6(o, n), d = l6(o, n), f = a.find((h) => h.type === d);
  return y.useEffect(() => {
    if (!o) return;
    const h = () => {
      s(
        s6({
          editor: o,
          hideWhenUnavailable: r,
          listInSchema: l,
          canToggleAny: c
        })
      );
    };
    return h(), o.on("selectionUpdate", h), () => {
      o.off("selectionUpdate", h);
    };
  }, [c, o, r, l, n]), {
    isVisible: i,
    activeType: d,
    isActive: u,
    canToggle: c,
    types: n,
    filteredLists: a,
    label: "List",
    Icon: f ? Q0[f.type] : Zs
  };
}
function c6({
  editor: t,
  types: e = ["bulletList", "orderedList", "taskList"],
  hideWhenUnavailable: n = !1,
  onOpenChange: r,
  portal: o = !1,
  ...i
}) {
  const { editor: s } = Y(t), [l, a] = y.useState(!1), { filteredLists: c, canToggle: u, isActive: d, isVisible: f, Icon: h } = a6({
    editor: s,
    types: e,
    hideWhenUnavailable: n
  }), p = y.useCallback(
    (m) => {
      a(m), r?.(m);
    },
    [r]
  );
  return !f || !s || !s.isEditable ? null : /* @__PURE__ */ R(qs, { open: l, onOpenChange: p, children: [
    /* @__PURE__ */ g(Oo, { asChild: !0, children: /* @__PURE__ */ R(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": d ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !u,
        "data-disabled": !u,
        "aria-label": "List options",
        tooltip: "List",
        ...i,
        children: [
          /* @__PURE__ */ g(h, { className: "tiptap-button-icon" }),
          /* @__PURE__ */ g(Mo, { className: "tiptap-button-dropdown-small" })
        ]
      }
    ) }),
    /* @__PURE__ */ g(No, { align: "start", portal: o, children: /* @__PURE__ */ g(St, { children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { children: c.map((m) => /* @__PURE__ */ g(Gs, { asChild: !0, children: /* @__PURE__ */ g(
      X0,
      {
        editor: s,
        type: m.type,
        text: m.label,
        showTooltip: !1,
        showShortcut: !0
      }
    ) }, m.type)) }) }) }) })
  ] });
}
function t2(t) {
  return t ? Eo(t, "table") : !1;
}
function n2(t) {
  if (!t) return !1;
  try {
    return t.isActive("table");
  } catch {
    return !1;
  }
}
function ec(t, e) {
  if (!t) return !1;
  switch (e) {
    case "insertTable":
      return t.can().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 });
    case "addColumnBefore":
      return t.can().addColumnBefore();
    case "addColumnAfter":
      return t.can().addColumnAfter();
    case "deleteColumn":
      return t.can().deleteColumn();
    case "addRowBefore":
      return t.can().addRowBefore();
    case "addRowAfter":
      return t.can().addRowAfter();
    case "deleteRow":
      return t.can().deleteRow();
    case "deleteTable":
      return t.can().deleteTable();
    case "mergeCells":
      return t.can().mergeCells();
    case "splitCell":
      return t.can().splitCell();
    case "toggleHeaderColumn":
      return t.can().toggleHeaderColumn();
    case "toggleHeaderRow":
      return t.can().toggleHeaderRow();
    case "toggleHeaderCell":
      return t.can().toggleHeaderCell();
    case "mergeOrSplit":
      return t.can().mergeOrSplit();
    case "fixTables":
      return t.can().fixTables();
    case "goToNextCell":
      return t.can().goToNextCell();
    case "goToPreviousCell":
      return t.can().goToPreviousCell();
    default:
      return !1;
  }
}
function r2(t, e) {
  if (t)
    switch (e) {
      case "insertTable":
        t.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run();
        break;
      case "addColumnBefore":
        t.chain().focus().addColumnBefore().run();
        break;
      case "addColumnAfter":
        t.chain().focus().addColumnAfter().run();
        break;
      case "deleteColumn":
        t.chain().focus().deleteColumn().run();
        break;
      case "addRowBefore":
        t.chain().focus().addRowBefore().run();
        break;
      case "addRowAfter":
        t.chain().focus().addRowAfter().run();
        break;
      case "deleteRow":
        t.chain().focus().deleteRow().run();
        break;
      case "deleteTable":
        t.chain().focus().deleteTable().run();
        break;
      case "mergeCells":
        t.chain().focus().mergeCells().run();
        break;
      case "splitCell":
        t.chain().focus().splitCell().run();
        break;
      case "toggleHeaderColumn":
        t.chain().focus().toggleHeaderColumn().run();
        break;
      case "toggleHeaderRow":
        t.chain().focus().toggleHeaderRow().run();
        break;
      case "toggleHeaderCell":
        t.chain().focus().toggleHeaderCell().run();
        break;
      case "mergeOrSplit":
        t.chain().focus().mergeOrSplit().run();
        break;
      case "fixTables":
        t.chain().focus().fixTables().run();
        break;
      case "goToNextCell":
        t.chain().focus().goToNextCell().run();
        break;
      case "goToPreviousCell":
        t.chain().focus().goToPreviousCell().run();
        break;
    }
}
function u6(t) {
  const {
    editor: e,
    action: n = "insertTable",
    hideWhenUnavailable: r = !1,
    onExecuted: o
  } = t || {}, { editor: i } = Y(e), s = ut(), [l, a] = y.useState(!0), c = t2(i), u = n2(i), d = ec(i, n);
  y.useEffect(() => {
    if (!i) return;
    const p = () => {
      a(r ? c : !0);
    };
    return p(), i.on("selectionUpdate", p), () => {
      i.off("selectionUpdate", p);
    };
  }, [i, r, c]);
  const f = y.useCallback(() => {
    i && d && (r2(i, n), o?.());
  }, [i, n, d, o]), h = y.useMemo(() => {
  }, [n]);
  return Lr(
    h || "",
    () => {
      !s && d && f();
    },
    {
      enabled: !s && !!h && !!i?.isEditable
    },
    [f, s, d, i]
  ), {
    isVisible: l,
    isAvailable: c,
    isInTable: u,
    canExecute: d,
    handleClick: f,
    action: n,
    label: `Table: ${n}`,
    Icon: he
  };
}
const d6 = y.forwardRef(
  ({
    editor: t,
    action: e = "insertTable",
    text: n,
    hideWhenUnavailable: r = !1,
    onExecuted: o,
    children: i,
    ...s
  }, l) => {
    const { editor: a } = Y(t), { isVisible: c, canExecute: u, handleClick: d, Icon: f } = u6({
      editor: a,
      action: e,
      hideWhenUnavailable: r,
      onExecuted: o
    });
    if (!c || !a || !a.isEditable)
      return null;
    const h = i || /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ g(f, { className: "tiptap-button-icon" }),
      n && /* @__PURE__ */ g("span", { children: n })
    ] });
    return /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        role: "button",
        tabIndex: -1,
        disabled: !u,
        "data-disabled": !u,
        "aria-label": `Table: ${e}`,
        tooltip: n || "Table",
        onClick: d,
        ...s,
        ref: l,
        children: h
      }
    );
  }
);
d6.displayName = "TableButton";
function f6(t) {
  const e = {
    insertTable: { label: "Insert table", icon: he },
    addColumnBefore: {
      label: "Add column before",
      icon: he,
      separator: !0
    },
    addColumnAfter: { label: "Add column after", icon: he },
    deleteColumn: { label: "Delete column", icon: kn },
    addRowBefore: { label: "Add row before", icon: he, separator: !0 },
    addRowAfter: { label: "Add row after", icon: he },
    deleteRow: { label: "Delete row", icon: kn },
    mergeCells: { label: "Merge cells", icon: he, separator: !0 },
    splitCell: { label: "Split cell", icon: he },
    toggleHeaderColumn: {
      label: "Toggle header column",
      icon: he,
      separator: !0
    },
    toggleHeaderRow: { label: "Toggle header row", icon: he },
    toggleHeaderCell: { label: "Toggle header cell", icon: he },
    mergeOrSplit: { label: "Merge or split", icon: he },
    fixTables: { label: "Fix tables", icon: he, separator: !0 },
    goToNextCell: { label: "Go to next cell", icon: he },
    goToPreviousCell: { label: "Go to previous cell", icon: he },
    deleteTable: { label: "Delete table", icon: kn, separator: !0 }
  };
  return t.map((n) => ({
    action: n,
    ...e[n]
  }));
}
function h6(t) {
  const {
    editor: e,
    actions: n = [
      "insertTable",
      "addColumnBefore",
      "addColumnAfter",
      "deleteColumn",
      "addRowBefore",
      "addRowAfter",
      "deleteRow",
      "toggleHeaderRow",
      "deleteTable"
    ],
    hideWhenUnavailable: r = !1
  } = t || {}, { editor: o } = Y(e), [i, s] = y.useState(!0), l = t2(o), a = n2(o), c = f6(n), u = y.useMemo(() => o ? c.filter((f) => f.action === "insertTable" ? !a && ec(o, f.action) : a && ec(o, f.action)) : [], [o, c, a]);
  y.useEffect(() => {
    if (!o) return;
    const f = () => {
      s(r ? l && u.length > 0 : l);
    };
    return f(), o.on("selectionUpdate", f), () => {
      o.off("selectionUpdate", f);
    };
  }, [o, r, l, u]);
  const d = y.useCallback(
    (f) => {
      r2(o, f);
    },
    [o]
  );
  return {
    isVisible: i,
    isAvailable: l,
    isInTable: a,
    filteredActions: u,
    handleActionClick: d,
    label: "Table",
    Icon: he
  };
}
const o2 = y.forwardRef(
  ({
    editor: t,
    actions: e = [
      "insertTable",
      "addColumnBefore",
      "addColumnAfter",
      "deleteColumn",
      "addRowBefore",
      "addRowAfter",
      "deleteRow",
      "toggleHeaderRow",
      "deleteTable"
    ],
    hideWhenUnavailable: n = !1,
    portal: r = !1,
    onOpenChange: o,
    ...i
  }, s) => {
    const { editor: l } = Y(t), [a, c] = y.useState(!1), { isVisible: u, isInTable: d, filteredActions: f, handleActionClick: h, Icon: p } = h6({
      editor: l,
      actions: e,
      hideWhenUnavailable: n
    }), m = y.useCallback(
      (b) => {
        c(b), o?.(b);
      },
      [o]
    );
    return !u || !l || !l.isEditable ? null : /* @__PURE__ */ R(qs, { open: a, onOpenChange: m, children: [
      /* @__PURE__ */ g(Oo, { asChild: !0, children: /* @__PURE__ */ R(
        J,
        {
          type: "button",
          "data-style": "ghost",
          "data-active-state": d ? "on" : "off",
          role: "button",
          tabIndex: -1,
          "aria-label": "Table options",
          "aria-pressed": d,
          tooltip: "Table",
          ...i,
          ref: s,
          children: [
            /* @__PURE__ */ g(p, { className: "tiptap-button-icon" }),
            /* @__PURE__ */ g(Mo, { className: "tiptap-button-dropdown-small" })
          ]
        }
      ) }),
      /* @__PURE__ */ g(No, { align: "start", portal: r, children: /* @__PURE__ */ g(St, { children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { children: f.map((b, C) => /* @__PURE__ */ R(y.Fragment, { children: [
        b.separator && C > 0 && /* @__PURE__ */ g(Ir, { orientation: "horizontal" }),
        /* @__PURE__ */ g(Gs, { asChild: !0, children: /* @__PURE__ */ R(
          J,
          {
            type: "button",
            "data-style": "ghost",
            onClick: () => h(b.action),
            disabled: !l.isEditable,
            showTooltip: !1,
            style: { justifyContent: "flex-start" },
            children: [
              b.icon && /* @__PURE__ */ g(b.icon, { className: "tiptap-button-icon" }),
              /* @__PURE__ */ g("span", { children: b.label })
            ]
          }
        ) })
      ] }, b.action)) }) }) }) })
    ] });
  }
);
o2.displayName = "TableDropdownMenu";
function p6({
  shortcutKeys: t = l2
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const i2 = y.forwardRef(
  ({
    editor: t,
    text: e,
    hideWhenUnavailable: n = !1,
    onToggled: r,
    showShortcut: o = !1,
    onClick: i,
    children: s,
    ...l
  }, a) => {
    const { editor: c } = Y(t), {
      isVisible: u,
      canToggle: d,
      isActive: f,
      handleToggle: h,
      label: p,
      shortcutKeys: m,
      Icon: b
    } = y6({
      editor: c,
      hideWhenUnavailable: n,
      onToggled: r
    }), C = y.useCallback(
      (v) => {
        i?.(v), !v.defaultPrevented && h();
      },
      [h, i]
    );
    return u ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": f ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !d,
        "data-disabled": !d,
        "aria-label": p,
        "aria-pressed": f,
        tooltip: "Blockquote",
        shortcutKeys: m,
        onClick: C,
        ...l,
        ref: a,
        children: s ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          e && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: e }),
          o && /* @__PURE__ */ g(p6, { shortcutKeys: m })
        ] })
      }
    ) : null;
  }
);
i2.displayName = "BlockquoteButton";
const s2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M8 6C8 5.44772 8.44772 5 9 5H16C16.5523 5 17 5.44772 17 6C17 6.55228 16.5523 7 16 7H9C8.44772 7 8 6.55228 8 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4 3C4.55228 3 5 3.44772 5 4L5 20C5 20.5523 4.55229 21 4 21C3.44772 21 3 20.5523 3 20L3 4C3 3.44772 3.44772 3 4 3Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M8 12C8 11.4477 8.44772 11 9 11H20C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H9C8.44772 13 8 12.5523 8 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M8 18C8 17.4477 8.44772 17 9 17H16C16.5523 17 17 17.4477 17 18C17 18.5523 16.5523 19 16 19H9C8.44772 19 8 18.5523 8 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
s2.displayName = "BlockquoteIcon";
const l2 = "mod+shift+b";
function Du(t, e = !0) {
  if (!t || !t.isEditable || !rn("blockquote", t) || wt(t, ["image"]))
    return !1;
  if (!e)
    return t.can().toggleWrap("blockquote");
  try {
    const r = t.view.state, o = r.selection;
    if (o.empty || o instanceof V) {
      const i = In({
        editor: t,
        node: r.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(i)) return !1;
    }
    return !0;
  } catch {
    return !1;
  }
}
function m6(t) {
  if (!t || !t.isEditable || !Du(t)) return !1;
  try {
    const e = t.view;
    let n = e.state, r = n.tr;
    if (n.selection.empty || n.selection instanceof V) {
      const l = In({
        editor: t,
        node: n.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(l)) return !1;
      r = r.setSelection(z.create(n.doc, l)), e.dispatch(r), n = e.state;
    }
    const o = n.selection;
    let i = t.chain().focus();
    if (o instanceof z) {
      const l = o.node.firstChild?.firstChild, a = o.node.lastChild?.lastChild, c = l ? o.from + l.nodeSize : o.from + 1, u = a ? o.to - a.nodeSize : o.to - 1;
      i = i.setTextSelection({ from: c, to: u }).clearNodes();
    }
    return (t.isActive("blockquote") ? i.lift("blockquote") : i.wrapIn("blockquote")).run(), t.chain().focus().selectTextblockEnd().run(), !0;
  } catch {
    return !1;
  }
}
function g6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !rn("blockquote", e) ? !1 : n && !e.isActive("code") ? Du(e) : !0;
}
function y6(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onToggled: r
  } = t || {}, { editor: o } = Y(e), [i, s] = y.useState(!0), l = Du(o), a = o?.isActive("blockquote") || !1;
  y.useEffect(() => {
    if (!o) return;
    const u = () => {
      s(g6({ editor: o, hideWhenUnavailable: n }));
    };
    return u(), o.on("selectionUpdate", u), () => {
      o.off("selectionUpdate", u);
    };
  }, [o, n]);
  const c = y.useCallback(() => {
    if (!o) return !1;
    const u = m6(o);
    return u && r?.(), u;
  }, [o, r]);
  return {
    isVisible: i,
    isActive: a,
    handleToggle: c,
    canToggle: l,
    label: "Blockquote",
    shortcutKeys: l2,
    Icon: s2
  };
}
function b6({
  shortcutKeys: t = u2
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const a2 = y.forwardRef(
  ({
    editor: t,
    text: e,
    hideWhenUnavailable: n = !1,
    onToggled: r,
    showShortcut: o = !1,
    onClick: i,
    children: s,
    ...l
  }, a) => {
    const { editor: c } = Y(t), {
      isVisible: u,
      canToggle: d,
      isActive: f,
      handleToggle: h,
      label: p,
      shortcutKeys: m,
      Icon: b
    } = w6({
      editor: c,
      hideWhenUnavailable: n,
      onToggled: r
    }), C = y.useCallback(
      (v) => {
        i?.(v), !v.defaultPrevented && h();
      },
      [h, i]
    );
    return u ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": f ? "on" : "off",
        role: "button",
        disabled: !d,
        "data-disabled": !d,
        tabIndex: -1,
        "aria-label": p,
        "aria-pressed": f,
        tooltip: "Code Block",
        shortcutKeys: m,
        onClick: C,
        ...l,
        ref: a,
        children: s ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          e && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: e }),
          o && /* @__PURE__ */ g(b6, { shortcutKeys: m })
        ] })
      }
    ) : null;
  }
);
a2.displayName = "CodeBlockButton";
const c2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6.70711 2.29289C7.09763 2.68342 7.09763 3.31658 6.70711 3.70711L4.41421 6L6.70711 8.29289C7.09763 8.68342 7.09763 9.31658 6.70711 9.70711C6.31658 10.0976 5.68342 10.0976 5.29289 9.70711L2.29289 6.70711C1.90237 6.31658 1.90237 5.68342 2.29289 5.29289L5.29289 2.29289C5.68342 1.90237 6.31658 1.90237 6.70711 2.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M10.2929 2.29289C10.6834 1.90237 11.3166 1.90237 11.7071 2.29289L14.7071 5.29289C15.0976 5.68342 15.0976 6.31658 14.7071 6.70711L11.7071 9.70711C11.3166 10.0976 10.6834 10.0976 10.2929 9.70711C9.90237 9.31658 9.90237 8.68342 10.2929 8.29289L12.5858 6L10.2929 3.70711C9.90237 3.31658 9.90237 2.68342 10.2929 2.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M17 4C17 3.44772 17.4477 3 18 3H19C20.6569 3 22 4.34315 22 6V18C22 19.6569 20.6569 21 19 21H5C3.34315 21 2 19.6569 2 18V12C2 11.4477 2.44772 11 3 11C3.55228 11 4 11.4477 4 12V18C4 18.5523 4.44772 19 5 19H19C19.5523 19 20 18.5523 20 18V6C20 5.44772 19.5523 5 19 5H18C17.4477 5 17 4.55228 17 4Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
c2.displayName = "CodeBlockIcon";
const u2 = "mod+alt+c";
function Pu(t, e = !0) {
  if (!t || !t.isEditable || !rn("codeBlock", t) || wt(t, ["image"]))
    return !1;
  if (!e)
    return t.can().toggleNode("codeBlock", "paragraph");
  try {
    const r = t.view.state, o = r.selection;
    if (o.empty || o instanceof V) {
      const i = In({
        editor: t,
        node: r.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(i)) return !1;
    }
    return !0;
  } catch {
    return !1;
  }
}
function C6(t) {
  if (!t || !t.isEditable || !Pu(t)) return !1;
  try {
    const e = t.view;
    let n = e.state, r = n.tr;
    if (n.selection.empty || n.selection instanceof V) {
      const l = In({
        editor: t,
        node: n.selection.$anchor.node(1)
      })?.pos;
      if (!Ht(l)) return !1;
      r = r.setSelection(z.create(n.doc, l)), e.dispatch(r), n = e.state;
    }
    const o = n.selection;
    let i = t.chain().focus();
    if (o instanceof z) {
      const l = o.node.firstChild?.firstChild, a = o.node.lastChild?.lastChild, c = l ? o.from + l.nodeSize : o.from + 1, u = a ? o.to - a.nodeSize : o.to - 1;
      i = i.setTextSelection({ from: c, to: u }).clearNodes();
    }
    return (t.isActive("codeBlock") ? i.setNode("paragraph") : i.toggleNode("codeBlock", "paragraph")).run(), t.chain().focus().selectTextblockEnd().run(), !0;
  } catch {
    return !1;
  }
}
function v6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !rn("codeBlock", e) ? !1 : n && !e.isActive("code") ? Pu(e) : !0;
}
function w6(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onToggled: r
  } = t || {}, { editor: o } = Y(e), [i, s] = y.useState(!0), l = Pu(o), a = o?.isActive("codeBlock") || !1;
  y.useEffect(() => {
    if (!o) return;
    const u = () => {
      s(v6({ editor: o, hideWhenUnavailable: n }));
    };
    return u(), o.on("selectionUpdate", u), () => {
      o.off("selectionUpdate", u);
    };
  }, [o, n]);
  const c = y.useCallback(() => {
    if (!o) return !1;
    const u = C6(o);
    return u && r?.(), u;
  }, [o, r]);
  return {
    isVisible: i,
    isActive: a,
    handleToggle: c,
    canToggle: l,
    label: "Code Block",
    shortcutKeys: u2,
    Icon: c2
  };
}
const Bu = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M4.43471 4.01458C4.34773 4.06032 4.26607 4.11977 4.19292 4.19292C4.11977 4.26607 4.06032 4.34773 4.01458 4.43471C2.14611 6.40628 1 9.0693 1 12C1 18.0751 5.92487 23 12 23C14.9306 23 17.5936 21.854 19.5651 19.9856C19.6522 19.9398 19.7339 19.8803 19.8071 19.8071C19.8803 19.7339 19.9398 19.6522 19.9856 19.5651C21.854 17.5936 23 14.9306 23 12C23 5.92487 18.0751 1 12 1C9.0693 1 6.40628 2.14611 4.43471 4.01458ZM6.38231 4.9681C7.92199 3.73647 9.87499 3 12 3C16.9706 3 21 7.02944 21 12C21 14.125 20.2635 16.078 19.0319 17.6177L6.38231 4.9681ZM17.6177 19.0319C16.078 20.2635 14.125 21 12 21C7.02944 21 3 16.9706 3 12C3 9.87499 3.73647 7.92199 4.9681 6.38231L17.6177 19.0319Z",
          fill: "currentColor"
        }
      )
    }
  )
);
Bu.displayName = "BanIcon";
const Ys = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M14.7072 4.70711C15.0977 4.31658 15.0977 3.68342 14.7072 3.29289C14.3167 2.90237 13.6835 2.90237 13.293 3.29289L8.69294 7.89286L8.68594 7.9C8.13626 8.46079 7.82837 9.21474 7.82837 10C7.82837 10.2306 7.85491 10.4584 7.90631 10.6795L2.29289 16.2929C2.10536 16.4804 2 16.7348 2 17V20C2 20.5523 2.44772 21 3 21H12C12.2652 21 12.5196 20.8946 12.7071 20.7071L15.3205 18.0937C15.5416 18.1452 15.7695 18.1717 16.0001 18.1717C16.7853 18.1717 17.5393 17.8639 18.1001 17.3142L22.7072 12.7071C23.0977 12.3166 23.0977 11.6834 22.7072 11.2929C22.3167 10.9024 21.6835 10.9024 21.293 11.2929L16.6971 15.8887C16.5105 16.0702 16.2605 16.1717 16.0001 16.1717C15.7397 16.1717 15.4897 16.0702 15.303 15.8887L10.1113 10.697C9.92992 10.5104 9.82837 10.2604 9.82837 10C9.82837 9.73963 9.92992 9.48958 10.1113 9.30297L14.7072 4.70711ZM13.5858 17L9.00004 12.4142L4 17.4142V19H11.5858L13.5858 17Z",
          fill: "currentColor"
        }
      )
    }
  )
);
Ys.displayName = "HighlighterIcon";
var Xs = "Popover", [d2, i8] = Dr(Xs, [
  $s
]), Io = $s(), [S6, Ln] = d2(Xs), f2 = (t) => {
  const {
    __scopePopover: e,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: i,
    modal: s = !1
  } = t, l = Io(e), a = y.useRef(null), [c, u] = y.useState(!1), [d, f] = gu({
    prop: r,
    defaultProp: o ?? !1,
    onChange: i,
    caller: Xs
  });
  return /* @__PURE__ */ g(Jg, { ...l, children: /* @__PURE__ */ g(
    S6,
    {
      scope: e,
      contentId: fs(),
      triggerRef: a,
      open: d,
      onOpenChange: f,
      onOpenToggle: y.useCallback(() => f((h) => !h), [f]),
      hasCustomAnchor: c,
      onCustomAnchorAdd: y.useCallback(() => u(!0), []),
      onCustomAnchorRemove: y.useCallback(() => u(!1), []),
      modal: s,
      children: n
    }
  ) });
};
f2.displayName = Xs;
var h2 = "PopoverAnchor", x6 = y.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, o = Ln(h2, n), i = Io(n), { onCustomAnchorAdd: s, onCustomAnchorRemove: l } = o;
    return y.useEffect(() => (s(), () => l()), [s, l]), /* @__PURE__ */ g(wu, { ...i, ...r, ref: e });
  }
);
x6.displayName = h2;
var p2 = "PopoverTrigger", m2 = y.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, o = Ln(p2, n), i = Io(n), s = He(e, o.triggerRef), l = /* @__PURE__ */ g(
      Ie.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": v2(o.open),
        ...r,
        ref: s,
        onClick: Z(t.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? l : /* @__PURE__ */ g(wu, { asChild: !0, ...i, children: l });
  }
);
m2.displayName = p2;
var Hu = "PopoverPortal", [k6, E6] = d2(Hu, {
  forceMount: void 0
}), g2 = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: o } = t, i = Ln(Hu, e);
  return /* @__PURE__ */ g(k6, { scope: e, forceMount: n, children: /* @__PURE__ */ g(er, { present: n || i.open, children: /* @__PURE__ */ g(Su, { asChild: !0, container: o, children: r }) }) });
};
g2.displayName = Hu;
var Rr = "PopoverContent", y2 = y.forwardRef(
  (t, e) => {
    const n = E6(Rr, t.__scopePopover), { forceMount: r = n.forceMount, ...o } = t, i = Ln(Rr, t.__scopePopover);
    return /* @__PURE__ */ g(er, { present: r || i.open, children: i.modal ? /* @__PURE__ */ g(T6, { ...o, ref: e }) : /* @__PURE__ */ g(R6, { ...o, ref: e }) });
  }
);
y2.displayName = Rr;
var M6 = /* @__PURE__ */ mo("PopoverContent.RemoveScroll"), T6 = y.forwardRef(
  (t, e) => {
    const n = Ln(Rr, t.__scopePopover), r = y.useRef(null), o = He(e, r), i = y.useRef(!1);
    return y.useEffect(() => {
      const s = r.current;
      if (s) return s0(s);
    }, []), /* @__PURE__ */ g(xu, { as: M6, allowPinchZoom: !0, children: /* @__PURE__ */ g(
      b2,
      {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Z(t.onCloseAutoFocus, (s) => {
          s.preventDefault(), i.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: Z(
          t.onPointerDownOutside,
          (s) => {
            const l = s.detail.originalEvent, a = l.button === 0 && l.ctrlKey === !0, c = l.button === 2 || a;
            i.current = c;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Z(
          t.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), R6 = y.forwardRef(
  (t, e) => {
    const n = Ln(Rr, t.__scopePopover), r = y.useRef(!1), o = y.useRef(!1);
    return /* @__PURE__ */ g(
      b2,
      {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          t.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (i) => {
          t.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const s = i.target;
          n.triggerRef.current?.contains(s) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
        }
      }
    );
  }
), b2 = y.forwardRef(
  (t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: s,
      onEscapeKeyDown: l,
      onPointerDownOutside: a,
      onFocusOutside: c,
      onInteractOutside: u,
      ...d
    } = t, f = Ln(Rr, n), h = Io(n);
    return Fg(), /* @__PURE__ */ g(
      bu,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: i,
        children: /* @__PURE__ */ g(
          yu,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: u,
            onEscapeKeyDown: l,
            onPointerDownOutside: a,
            onFocusOutside: c,
            onDismiss: () => f.onOpenChange(!1),
            children: /* @__PURE__ */ g(
              Yg,
              {
                "data-state": v2(f.open),
                role: "dialog",
                id: f.contentId,
                ...h,
                ...d,
                ref: e,
                style: {
                  ...d.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), C2 = "PopoverClose", A6 = y.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, o = Ln(C2, n);
    return /* @__PURE__ */ g(
      Ie.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: Z(t.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
A6.displayName = C2;
var O6 = "PopoverArrow", N6 = y.forwardRef(
  (t, e) => {
    const { __scopePopover: n, ...r } = t, o = Io(n);
    return /* @__PURE__ */ g(Xg, { ...o, ...r, ref: e });
  }
);
N6.displayName = O6;
function v2(t) {
  return t ? "open" : "closed";
}
var I6 = f2, L6 = m2, D6 = g2, P6 = y2;
function Qs({
  ...t
}) {
  return /* @__PURE__ */ g(I6, { ...t });
}
function el({
  ...t
}) {
  return /* @__PURE__ */ g(L6, { ...t });
}
function tl({
  className: t,
  align: e = "center",
  sideOffset: n = 4,
  ...r
}) {
  return /* @__PURE__ */ g(D6, { children: /* @__PURE__ */ g(
    P6,
    {
      align: e,
      sideOffset: n,
      className: Re("tiptap-popover", t),
      ...r
    }
  ) });
}
function B6({
  shortcutKeys: t = Fu
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const w2 = y.forwardRef(
  ({
    editor: t,
    highlightColor: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onApplied: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    style: a,
    ...c
  }, u) => {
    const { editor: d } = Y(t), {
      isVisible: f,
      canColorHighlight: h,
      isActive: p,
      handleColorHighlight: m,
      label: b,
      shortcutKeys: C
    } = zu({
      editor: d,
      highlightColor: e,
      label: n || `Toggle highlight (${e})`,
      hideWhenUnavailable: r,
      onApplied: o
    }), v = y.useCallback(
      (w) => {
        s?.(w), !w.defaultPrevented && m();
      },
      [m, s]
    ), S = y.useMemo(
      () => ({
        ...a,
        "--highlight-color": e
      }),
      [e, a]
    );
    return f ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": p ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !h,
        "data-disabled": !h,
        "aria-label": b,
        "aria-pressed": p,
        tooltip: b,
        onClick: v,
        style: S,
        ...c,
        ref: u,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(
            "span",
            {
              className: "tiptap-button-highlight",
              style: { "--highlight-color": e }
            }
          ),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(B6, { shortcutKeys: C })
        ] })
      }
    ) : null;
  }
);
w2.displayName = "ColorHighlightButton";
const Fu = "mod+shift+h", H6 = [
  {
    label: "Default background",
    value: "var(--tt-bg-color)",
    border: "var(--tt-bg-color-contrast)"
  },
  {
    label: "Gray background",
    value: "var(--tt-color-highlight-gray)",
    border: "var(--tt-color-highlight-gray-contrast)"
  },
  {
    label: "Brown background",
    value: "var(--tt-color-highlight-brown)",
    border: "var(--tt-color-highlight-brown-contrast)"
  },
  {
    label: "Orange background",
    value: "var(--tt-color-highlight-orange)",
    border: "var(--tt-color-highlight-orange-contrast)"
  },
  {
    label: "Yellow background",
    value: "var(--tt-color-highlight-yellow)",
    border: "var(--tt-color-highlight-yellow-contrast)"
  },
  {
    label: "Green background",
    value: "var(--tt-color-highlight-green)",
    border: "var(--tt-color-highlight-green-contrast)"
  },
  {
    label: "Blue background",
    value: "var(--tt-color-highlight-blue)",
    border: "var(--tt-color-highlight-blue-contrast)"
  },
  {
    label: "Purple background",
    value: "var(--tt-color-highlight-purple)",
    border: "var(--tt-color-highlight-purple-contrast)"
  },
  {
    label: "Pink background",
    value: "var(--tt-color-highlight-pink)",
    border: "var(--tt-color-highlight-pink-contrast)"
  },
  {
    label: "Red background",
    value: "var(--tt-color-highlight-red)",
    border: "var(--tt-color-highlight-red-contrast)"
  }
];
function S2(t) {
  const e = new Map(
    H6.map((n) => [n.value, n])
  );
  return t.map((n) => e.get(n)).filter((n) => !!n);
}
function _u(t) {
  return !t || !t.isEditable || !nn("highlight", t) || wt(t, ["image"]) ? !1 : t.can().setMark("highlight");
}
function F6(t, e) {
  return !t || !t.isEditable ? !1 : e ? t.isActive("highlight", { color: e }) : t.isActive("highlight");
}
function _6(t) {
  return !t || !t.isEditable || !_u(t) ? !1 : t.chain().focus().unsetMark("highlight").run();
}
function z6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !nn("highlight", e) ? !1 : n && !e.isActive("code") ? _u(e) : !0;
}
function zu(t) {
  const {
    editor: e,
    label: n,
    highlightColor: r,
    hideWhenUnavailable: o = !1,
    onApplied: i
  } = t, { editor: s } = Y(e), [l, a] = y.useState(!0), c = _u(s), u = F6(s, r);
  y.useEffect(() => {
    if (!s) return;
    const h = () => {
      a(z6({ editor: s, hideWhenUnavailable: o }));
    };
    return h(), s.on("selectionUpdate", h), () => {
      s.off("selectionUpdate", h);
    };
  }, [s, o]);
  const d = y.useCallback(() => {
    if (!s || !c || !r || !n)
      return !1;
    if (s.state.storedMarks) {
      const h = s.schema.marks.highlight;
      h && s.view.dispatch(
        s.state.tr.removeStoredMark(h)
      );
    }
    setTimeout(() => {
      const h = s.chain().focus().toggleMark("highlight", { color: r }).run();
      return h && i?.({ color: r, label: n }), h;
    }, 0);
  }, [c, r, s, n, i]), f = y.useCallback(() => {
    const h = _6(s);
    return h && i?.({ color: "", label: "Remove highlight" }), h;
  }, [s, i]);
  return {
    isVisible: l,
    isActive: u,
    handleColorHighlight: d,
    handleRemoveHighlight: f,
    canColorHighlight: c,
    label: n || "Highlight",
    shortcutKeys: Fu,
    Icon: Ys
  };
}
const Vu = y.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g(
  J,
  {
    type: "button",
    className: t,
    "data-style": "ghost",
    "data-appearance": "default",
    role: "button",
    tabIndex: -1,
    "aria-label": "Highlight text",
    tooltip: "Highlight",
    shortcutKeys: Fu,
    ref: r,
    ...n,
    children: e ?? /* @__PURE__ */ g(Ys, { className: "tiptap-button-icon" })
  }
));
Vu.displayName = "ColorHighlightPopoverButton";
function x2({
  editor: t,
  colors: e = S2([
    "var(--tt-color-highlight-green)",
    "var(--tt-color-highlight-blue)",
    "var(--tt-color-highlight-red)",
    "var(--tt-color-highlight-purple)",
    "var(--tt-color-highlight-yellow)"
  ])
}) {
  const { handleRemoveHighlight: n } = zu({ editor: t }), r = ut(), o = y.useRef(null), i = y.useMemo(
    () => [...e, { label: "Remove highlight", value: "none" }],
    [e]
  ), { selectedIndex: s } = pg({
    containerRef: o,
    items: i,
    orientation: "both",
    onSelect: (l) => {
      if (!o.current) return !1;
      const a = o.current.querySelector(
        '[data-highlighted="true"]'
      );
      a && a.click(), l.value === "none" && n();
    },
    autoSelectFirstItem: !1
  });
  return /* @__PURE__ */ g(
    St,
    {
      ref: o,
      tabIndex: 0,
      style: r ? { boxShadow: "none", border: 0 } : {},
      children: /* @__PURE__ */ g(xt, { style: r ? { padding: 0 } : {}, children: /* @__PURE__ */ R(Xn, { orientation: "horizontal", children: [
        /* @__PURE__ */ g(lt, { orientation: "horizontal", children: e.map((l, a) => /* @__PURE__ */ g(
          w2,
          {
            editor: t,
            highlightColor: l.value,
            tooltip: l.label,
            "aria-label": `${l.label} highlight color`,
            tabIndex: a === s ? 0 : -1,
            "data-highlighted": s === a
          },
          l.value
        )) }),
        /* @__PURE__ */ g(Ir, {}),
        /* @__PURE__ */ g(lt, { orientation: "horizontal", children: /* @__PURE__ */ g(
          J,
          {
            onClick: n,
            "aria-label": "Remove highlight",
            tooltip: "Remove highlight",
            tabIndex: s === e.length ? 0 : -1,
            type: "button",
            role: "menuitem",
            "data-style": "ghost",
            "data-highlighted": s === e.length,
            children: /* @__PURE__ */ g(Bu, { className: "tiptap-button-icon" })
          }
        ) })
      ] }) })
    }
  );
}
function V6({
  editor: t,
  colors: e = S2([
    "var(--tt-color-highlight-green)",
    "var(--tt-color-highlight-blue)",
    "var(--tt-color-highlight-red)",
    "var(--tt-color-highlight-purple)",
    "var(--tt-color-highlight-yellow)"
  ]),
  hideWhenUnavailable: n = !1,
  onApplied: r,
  ...o
}) {
  const { editor: i } = Y(t), [s, l] = y.useState(!1), { isVisible: a, canColorHighlight: c, isActive: u, label: d, Icon: f } = zu({
    editor: i,
    hideWhenUnavailable: n,
    onApplied: r
  });
  return a ? /* @__PURE__ */ R(Qs, { open: s, onOpenChange: l, children: [
    /* @__PURE__ */ g(el, { asChild: !0, children: /* @__PURE__ */ g(
      Vu,
      {
        disabled: !c,
        "data-active-state": u ? "on" : "off",
        "data-disabled": !c,
        "aria-pressed": u,
        "aria-label": d,
        tooltip: d,
        ...o,
        children: /* @__PURE__ */ g(f, { className: "tiptap-button-icon" })
      }
    ) }),
    /* @__PURE__ */ g(tl, { "aria-label": "Highlight colors", children: /* @__PURE__ */ g(x2, { editor: i, colors: e }) })
  ] }) : null;
}
const $u = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ R(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: t,
    ref: n,
    ...e,
    children: [
      /* @__PURE__ */ g(
        "path",
        {
          d: "M9 3H15L19 12H16.5L15.5 9.5H8.5L7.5 12H5L9 3Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g("path", { d: "M12 7.5L10.5 7.5H13.5L12 7.5Z", fill: "currentColor" }),
      /* @__PURE__ */ g("rect", { x: "3", y: "18", width: "18", height: "3", rx: "1", fill: "currentColor" })
    ]
  }
));
$u.displayName = "TextColorIcon";
const $6 = [
  {
    label: "Default text",
    value: "",
    border: "var(--tt-gray-light-a-400)"
  },
  {
    label: "Gray text",
    value: "var(--tt-gray-light-600)",
    border: "var(--tt-gray-light-600)"
  },
  {
    label: "Brown text",
    value: "#8B4513",
    border: "#8B4513"
  },
  {
    label: "Orange text",
    value: "#FF8C00",
    border: "#FF8C00"
  },
  {
    label: "Yellow text",
    value: "#FFD700",
    border: "#FFD700"
  },
  {
    label: "Green text",
    value: "#228B22",
    border: "#228B22"
  },
  {
    label: "Blue text",
    value: "#1E90FF",
    border: "#1E90FF"
  },
  {
    label: "Purple text",
    value: "#9932CC",
    border: "#9932CC"
  },
  {
    label: "Pink text",
    value: "#FF69B4",
    border: "#FF69B4"
  },
  {
    label: "Red text",
    value: "#DC143C",
    border: "#DC143C"
  }
];
function U6(t) {
  const e = new Map($6.map((n) => [n.value, n]));
  return t.map((n) => e.get(n)).filter((n) => !!n);
}
function Uu(t) {
  return !t || !t.isEditable || !nn("textStyle", t) || wt(t, ["image"]) ? !1 : t.can().setColor("#000000");
}
function W6(t, e) {
  return !t || !t.isEditable ? !1 : e ? t.isActive("textStyle", { color: e }) : t.getAttributes("textStyle").color !== void 0;
}
function K6(t) {
  return !t || !t.isEditable || !Uu(t) ? !1 : t.chain().focus().unsetColor().run();
}
function j6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !nn("textStyle", e) ? !1 : n && !e.isActive("code") ? Uu(e) : !0;
}
function k2(t) {
  const {
    editor: e,
    label: n,
    textColor: r,
    hideWhenUnavailable: o = !1,
    onApplied: i
  } = t, { editor: s } = Y(e), l = ut(), [a, c] = y.useState(!0), u = Uu(s), d = W6(s, r);
  y.useEffect(() => {
    if (!s) return;
    const p = () => {
      c(j6({ editor: s, hideWhenUnavailable: o }));
    };
    return p(), s.on("selectionUpdate", p), () => {
      s.off("selectionUpdate", p);
    };
  }, [s, o]);
  const f = y.useCallback(() => {
    if (!s || !u || !r || !n) return !1;
    if (s.state.storedMarks) {
      const p = s.schema.marks.textStyle;
      p && s.view.dispatch(
        s.state.tr.removeStoredMark(p)
      );
    }
    return setTimeout(() => {
      (r ? s.chain().focus().setColor(r).run() : s.chain().focus().unsetColor().run()) && i?.({ color: r, label: n });
    }, 0), !0;
  }, [s, u, r, n, i]), h = y.useCallback(() => K6(s), [s]);
  return {
    editor: s,
    canTextColor: u,
    isActive: d,
    isVisible: a,
    isMobile: l,
    handleTextColor: f,
    handleRemoveTextColor: h
  };
}
const Wu = y.forwardRef(({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g(
  J,
  {
    type: "button",
    className: t,
    "data-style": "ghost",
    "data-appearance": "default",
    role: "button",
    tabIndex: -1,
    "aria-label": "Change text color",
    tooltip: "Text Color",
    ref: r,
    ...n,
    children: e ?? /* @__PURE__ */ g($u, { className: "tiptap-button-icon" })
  }
));
Wu.displayName = "TextColorPopoverButton";
function E2({
  editor: t,
  colors: e = U6([
    "#DC143C",
    // Red
    "#FF8C00",
    // Orange
    "#FFD700",
    // Yellow
    "#228B22",
    // Green
    "#1E90FF",
    // Blue
    "#9932CC",
    // Purple
    "#FF69B4"
    // Pink
  ])
}) {
  const { handleRemoveTextColor: n } = k2({ editor: t }), r = y.useRef(null), o = y.useCallback(
    (i) => {
      t && (i ? t.chain().focus().setColor(i).run() : t.chain().focus().unsetColor().run());
    },
    [t]
  );
  return t ? /* @__PURE__ */ g(St, { className: "tiptap-text-color-popover", ref: r, children: /* @__PURE__ */ g(xt, { className: "p-2", children: /* @__PURE__ */ g(Xn, { children: /* @__PURE__ */ R(lt, { orientation: "horizontal", children: [
    /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-appearance": "default",
        onClick: n,
        className: "text-color-remove-button",
        "aria-label": "Remove text color",
        tooltip: "Remove text color",
        children: /* @__PURE__ */ g(Bu, { className: "tiptap-button-icon" })
      }
    ),
    e.map((i) => /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-appearance": "default",
        onClick: () => o(i.value),
        className: "text-color-button",
        "aria-label": i.label,
        tooltip: i.label,
        style: {
          "--color-preview": i.value
        },
        children: /* @__PURE__ */ g(
          "div",
          {
            className: "color-preview",
            style: {
              backgroundColor: i.value,
              width: "16px",
              height: "16px",
              borderRadius: "2px",
              border: `1px solid ${i.border}`
            }
          }
        )
      },
      i.value
    ))
  ] }) }) }) }) : null;
}
const M2 = y.forwardRef(
  ({
    editor: t,
    colors: e,
    hideWhenUnavailable: n,
    onApplied: r,
    ...o
  }, i) => {
    const { editor: s } = Y(t), { isVisible: l } = k2({
      editor: s,
      hideWhenUnavailable: n,
      onApplied: r
    });
    return !l || !s ? null : /* @__PURE__ */ R(Qs, { children: [
      /* @__PURE__ */ g(el, { asChild: !0, children: /* @__PURE__ */ g(Wu, { ref: i, ...o }) }),
      /* @__PURE__ */ g(tl, { children: /* @__PURE__ */ g(E2, { editor: s, colors: e }) })
    ] });
  }
);
M2.displayName = "TextColorPopover";
const T2 = y.forwardRef(
  ({ className: t, ...e }, n) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: t,
      ref: n,
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M3 7C2.44772 7 2 6.55228 2 6C2 5.44772 2.44772 5 3 5H11C11.5523 5 12 5.44772 12 6C12 6.55228 11.5523 7 11 7H8V17C8 17.5523 7.55228 18 7 18C6.44772 18 6 17.5523 6 17V7H3Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M13 12C13 11.4477 13.4477 11 14 11H20C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H18V19C18 19.5523 17.5523 20 17 20C16.4477 20 16 19.5523 16 19V13H14C13.4477 13 13 12.5523 13 12Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
T2.displayName = "TextSizeIcon";
const q6 = [
  {
    label: "Small",
    value: "14px"
  },
  {
    label: "Normal",
    value: "16px"
  },
  {
    label: "Medium",
    value: "18px"
  },
  {
    label: "Large",
    value: "20px"
  },
  {
    label: "Extra Large",
    value: "24px"
  },
  {
    label: "Huge",
    value: "32px"
  }
];
function Ku(t) {
  return !t || !t.isEditable || !nn("textStyle", t) || wt(t, ["image"]) ? !1 : t.can().setFontSize("16px");
}
function G6(t, e) {
  return !t || !t.isEditable ? !1 : e ? t.isActive("textStyle", { fontSize: e }) : t.isActive("textStyle");
}
function Z6(t) {
  return !t || !t.isEditable || !Ku(t) ? !1 : t.chain().focus().unsetFontSize().run();
}
function J6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !nn("textStyle", e) ? !1 : n && !e.isActive("code") ? Ku(e) : !0;
}
function R2(t) {
  const {
    editor: e,
    label: n,
    textSize: r,
    hideWhenUnavailable: o = !1,
    onApplied: i
  } = t, { editor: s } = Y(e), l = ut(), [a, c] = y.useState(!0), u = Ku(s), d = G6(s, r);
  y.useEffect(() => {
    if (!s) return;
    const p = () => {
      c(J6({ editor: s, hideWhenUnavailable: o }));
    };
    return p(), s.on("selectionUpdate", p), () => {
      s.off("selectionUpdate", p);
    };
  }, [s, o]);
  const f = y.useCallback(() => {
    if (!s || !u || !r || !n) return !1;
    if (s.state.storedMarks) {
      const p = s.schema.marks.textStyle;
      p && s.view.dispatch(
        s.state.tr.removeStoredMark(p)
      );
    }
    return setTimeout(() => {
      s.chain().focus().setFontSize(r).run() && i?.({ size: r, label: n });
    }, 0), !0;
  }, [s, u, r, n, i]), h = y.useCallback(() => Z6(s), [s]);
  return {
    editor: s,
    canTextSize: u,
    isActive: d,
    isVisible: a,
    isMobile: l,
    handleTextSize: f,
    handleRemoveTextSize: h
  };
}
const A2 = y.forwardRef(
  ({
    editor: t,
    textSize: e,
    label: n,
    hideWhenUnavailable: r = !1,
    onApplied: o,
    text: i,
    className: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), { canTextSize: d, isActive: f, isVisible: h, handleTextSize: p } = R2({
      editor: u,
      textSize: e,
      label: n,
      hideWhenUnavailable: r,
      onApplied: o
    });
    return h ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": f ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !d,
        "aria-label": n || "Set text size",
        "aria-pressed": f,
        tooltip: n || "Text Size",
        style: {
          width: "100%",
          gap: "1rem",
          justifyContent: "space-between"
        },
        onClick: p,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          i && /* @__PURE__ */ g("span", { children: i }),
          e && /* @__PURE__ */ g("span", { children: e })
        ] })
      }
    ) : null;
  }
);
A2.displayName = "TextSizeButton";
const O2 = y.forwardRef(({ className: t, children: e, text: n, ...r }, o) => /* @__PURE__ */ g(
  J,
  {
    type: "button",
    "data-style": "ghost",
    className: `tiptap-text-size-trigger ${t || ""}`,
    role: "button",
    tabIndex: -1,
    "aria-label": "Change text size",
    tooltip: "Text Size",
    ref: o,
    ...r,
    children: e ?? /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ g(T2, { className: "tiptap-button-icon" }),
      n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
      /* @__PURE__ */ g(Mo, { className: "tiptap-button-dropdown-arrows" })
    ] })
  }
));
O2.displayName = "TextSizeDropdownMenuButton";
const N2 = y.forwardRef(
  ({
    editor: t,
    sizes: e = q6,
    hideWhenUnavailable: n,
    onApplied: r,
    text: o,
    ...i
  }, s) => {
    const { editor: l } = Y(t), { isVisible: a } = R2({
      editor: l,
      hideWhenUnavailable: n,
      onApplied: r
    });
    if (!a || !l)
      return null;
    const c = l.getAttributes("textStyle").fontSize, u = e.find((f) => f.value === c), d = !!c;
    return /* @__PURE__ */ R(qs, { children: [
      /* @__PURE__ */ g(Oo, { asChild: !0, children: /* @__PURE__ */ g(
        O2,
        {
          ref: s,
          text: u?.label || o,
          "data-active-state": d ? "on" : "off",
          ...i
        }
      ) }),
      /* @__PURE__ */ g(No, { align: "start", children: /* @__PURE__ */ g(St, { children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { children: e.map((f) => /* @__PURE__ */ g(Gs, { style: { width: "100%" }, children: /* @__PURE__ */ g(
        A2,
        {
          editor: l,
          textSize: f.value,
          label: f.label,
          hideWhenUnavailable: n,
          text: f.label
        }
      ) }, f.value)) }) }) }) })
    ] });
  }
);
N2.displayName = "TextSizeDropdownMenu";
const ju = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M21 4C21 3.44772 20.5523 3 20 3C19.4477 3 19 3.44772 19 4V11C19 11.7956 18.6839 12.5587 18.1213 13.1213C17.5587 13.6839 16.7956 14 16 14H6.41421L9.70711 10.7071C10.0976 10.3166 10.0976 9.68342 9.70711 9.29289C9.31658 8.90237 8.68342 8.90237 8.29289 9.29289L3.29289 14.2929C2.90237 14.6834 2.90237 15.3166 3.29289 15.7071L8.29289 20.7071C8.68342 21.0976 9.31658 21.0976 9.70711 20.7071C10.0976 20.3166 10.0976 19.6834 9.70711 19.2929L6.41421 16H16C17.3261 16 18.5979 15.4732 19.5355 14.5355C20.4732 13.5979 21 12.3261 21 11V4Z",
          fill: "currentColor"
        }
      )
    }
  )
);
ju.displayName = "CornerDownLeftIcon";
const I2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M14 3C14 2.44772 14.4477 2 15 2H21C21.5523 2 22 2.44772 22 3V9C22 9.55228 21.5523 10 21 10C20.4477 10 20 9.55228 20 9V5.41421L10.7071 14.7071C10.3166 15.0976 9.68342 15.0976 9.29289 14.7071C8.90237 14.3166 8.90237 13.6834 9.29289 13.2929L18.5858 4H15C14.4477 4 14 3.55228 14 3Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M4.29289 7.29289C4.48043 7.10536 4.73478 7 5 7H11C11.5523 7 12 6.55228 12 6C12 5.44772 11.5523 5 11 5H5C4.20435 5 3.44129 5.31607 2.87868 5.87868C2.31607 6.44129 2 7.20435 2 8V19C2 19.7957 2.31607 20.5587 2.87868 21.1213C3.44129 21.6839 4.20435 22 5 22H16C16.7957 22 17.5587 21.6839 18.1213 21.1213C18.6839 20.5587 19 19.7957 19 19V13C19 12.4477 18.5523 12 18 12C17.4477 12 17 12.4477 17 13V19C17 19.2652 16.8946 19.5196 16.7071 19.7071C16.5196 19.8946 16.2652 20 16 20H5C4.73478 20 4.48043 19.8946 4.29289 19.7071C4.10536 19.5196 4 19.2652 4 19V8C4 7.73478 4.10536 7.48043 4.29289 7.29289Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
I2.displayName = "ExternalLinkIcon";
const nl = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M16.9958 1.06669C15.4226 1.05302 13.907 1.65779 12.7753 2.75074L12.765 2.76086L11.045 4.47086C10.6534 4.86024 10.6515 5.49341 11.0409 5.88507C11.4303 6.27673 12.0634 6.27858 12.4551 5.88919L14.1697 4.18456C14.9236 3.45893 15.9319 3.05752 16.9784 3.06662C18.0272 3.07573 19.0304 3.49641 19.772 4.23804C20.5137 4.97967 20.9344 5.98292 20.9435 7.03171C20.9526 8.07776 20.5515 9.08563 19.8265 9.83941L16.833 12.8329C16.4274 13.2386 15.9393 13.5524 15.4019 13.7529C14.8645 13.9533 14.2903 14.0359 13.7181 13.9949C13.146 13.9539 12.5894 13.7904 12.0861 13.5154C11.5827 13.2404 11.1444 12.8604 10.8008 12.401C10.47 11.9588 9.84333 11.8685 9.40108 12.1993C8.95883 12.5301 8.86849 13.1568 9.1993 13.599C9.71464 14.288 10.3721 14.858 11.1272 15.2705C11.8822 15.683 12.7171 15.9283 13.5753 15.9898C14.4334 16.0513 15.2948 15.9274 16.1009 15.6267C16.907 15.326 17.639 14.8555 18.2473 14.247L21.2472 11.2471L21.2593 11.2347C22.3523 10.1031 22.9571 8.58751 22.9434 7.01433C22.9297 5.44115 22.2987 3.93628 21.1863 2.82383C20.0738 1.71138 18.5689 1.08036 16.9958 1.06669Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M10.4247 8.0102C9.56657 7.94874 8.70522 8.07256 7.89911 8.37326C7.09305 8.67395 6.36096 9.14458 5.75272 9.753L2.75285 12.7529L2.74067 12.7653C1.64772 13.8969 1.04295 15.4125 1.05662 16.9857C1.07029 18.5589 1.70131 20.0637 2.81376 21.1762C3.9262 22.2886 5.43108 22.9196 7.00426 22.9333C8.57744 22.947 10.0931 22.3422 11.2247 21.2493L11.2371 21.2371L12.9471 19.5271C13.3376 19.1366 13.3376 18.5034 12.9471 18.1129C12.5565 17.7223 11.9234 17.7223 11.5328 18.1129L9.82932 19.8164C9.07555 20.5414 8.06768 20.9425 7.02164 20.9334C5.97285 20.9243 4.9696 20.5036 4.22797 19.762C3.48634 19.0203 3.06566 18.0171 3.05655 16.9683C3.04746 15.9222 3.44851 14.9144 4.17355 14.1606L7.16719 11.167C7.5727 10.7613 8.06071 10.4476 8.59811 10.2471C9.13552 10.0467 9.70976 9.96412 10.2819 10.0051C10.854 10.0461 11.4106 10.2096 11.9139 10.4846C12.4173 10.7596 12.8556 11.1397 13.1992 11.599C13.53 12.0412 14.1567 12.1316 14.5989 11.8007C15.0412 11.4699 15.1315 10.8433 14.8007 10.401C14.2854 9.71205 13.6279 9.14198 12.8729 8.72948C12.1178 8.31697 11.2829 8.07166 10.4247 8.0102Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
nl.displayName = "LinkIcon";
function L2({ className: t, type: e, ...n }) {
  return /* @__PURE__ */ g("input", { type: e, className: Re("tiptap-input", t), ...n });
}
function D2({
  className: t,
  children: e,
  ...n
}) {
  return /* @__PURE__ */ g("div", { className: Re("tiptap-input-group", t), ...n, children: e });
}
const P2 = y.forwardRef(
  ({ className: t, checked: e, onChange: n, label: r, disabled: o, name: i, id: s, ...l }, a) => {
    const c = (u) => {
      n?.(u.target.checked);
    };
    return /* @__PURE__ */ R(
      "label",
      {
        htmlFor: s,
        className: Re("tiptap-checkbox", t),
        "data-disabled": o ? "true" : "false",
        children: [
          /* @__PURE__ */ g(
            "input",
            {
              ref: a,
              type: "checkbox",
              id: s,
              name: i,
              checked: e,
              disabled: o,
              onChange: c,
              ...l
            }
          ),
          /* @__PURE__ */ g("span", { className: "tiptap-checkbox-control" }),
          r && /* @__PURE__ */ g("span", { className: "tiptap-checkbox-label", children: r })
        ]
      }
    );
  }
);
P2.displayName = "Checkbox";
const qu = y.forwardRef(
  ({ className: t, children: e, ...n }, r) => /* @__PURE__ */ g(
    J,
    {
      type: "button",
      className: t,
      "data-style": "ghost",
      role: "button",
      tabIndex: -1,
      "aria-label": "Link",
      tooltip: "Link",
      ref: r,
      ...n,
      children: e || /* @__PURE__ */ g(nl, { className: "tiptap-button-icon" })
    }
  )
);
qu.displayName = "LinkButton";
const B2 = ({
  url: t,
  setUrl: e,
  openInNewTab: n,
  setOpenInNewTab: r,
  setLink: o,
  removeLink: i,
  openLink: s,
  isActive: l
}) => {
  const a = ut(), c = (u) => {
    u.key === "Enter" && (u.preventDefault(), o());
  };
  return /* @__PURE__ */ g(
    St,
    {
      style: {
        ...a ? { boxShadow: "none", border: 0 } : {}
      },
      children: /* @__PURE__ */ R(
        xt,
        {
          style: {
            ...a ? { padding: 0 } : {}
          },
          children: [
            /* @__PURE__ */ g(Xn, { orientation: "vertical", children: /* @__PURE__ */ R(D2, { children: [
              /* @__PURE__ */ g(
                L2,
                {
                  type: "url",
                  placeholder: "Paste a link...",
                  value: t,
                  onChange: (u) => e(u.target.value),
                  onKeyDown: c,
                  autoFocus: !0,
                  autoComplete: "off",
                  autoCorrect: "off",
                  autoCapitalize: "off"
                }
              ),
              /* @__PURE__ */ g(
                P2,
                {
                  name: "openInNewTab",
                  label: "Open in new tab",
                  checked: n,
                  onChange: r
                }
              )
            ] }) }),
            /* @__PURE__ */ R(Xn, { orientation: "horizontal", children: [
              /* @__PURE__ */ R(lt, { orientation: "horizontal", children: [
                /* @__PURE__ */ g(
                  J,
                  {
                    type: "button",
                    onClick: s,
                    title: "Preview link",
                    disabled: !t && !l,
                    "data-style": "ghost",
                    children: /* @__PURE__ */ g(I2, { className: "tiptap-button-icon" })
                  }
                ),
                /* @__PURE__ */ g(
                  J,
                  {
                    type: "button",
                    onClick: i,
                    title: "Remove link",
                    disabled: !t && !l,
                    "data-style": "ghost",
                    children: /* @__PURE__ */ g(kn, { className: "tiptap-button-icon" })
                  }
                )
              ] }),
              /* @__PURE__ */ g(Ir, {}),
              /* @__PURE__ */ g(
                J,
                {
                  type: "button",
                  onClick: o,
                  title: "Apply link",
                  disabled: !t && !l,
                  style: { marginLeft: "auto" },
                  "data-style": "ghost",
                  children: /* @__PURE__ */ g(ju, { className: "tiptap-button-icon" })
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, Y6 = ({ editor: t }) => {
  const e = _2({
    editor: t
  });
  return /* @__PURE__ */ g(B2, { ...e });
}, H2 = y.forwardRef(
  ({
    editor: t,
    hideWhenUnavailable: e = !1,
    onSetLink: n,
    onOpenChange: r,
    autoOpenOnLinkActive: o = !0,
    onClick: i,
    children: s,
    ...l
  }, a) => {
    const { editor: c } = Y(t), [u, d] = y.useState(!1), {
      isVisible: f,
      canSet: h,
      isActive: p,
      url: m,
      setUrl: b,
      openInNewTab: C,
      setOpenInNewTab: v,
      setLink: S,
      removeLink: w,
      openLink: x,
      label: k,
      Icon: E
    } = _2({
      editor: c,
      hideWhenUnavailable: e,
      onSetLink: n
    }), M = y.useCallback(
      (P) => {
        d(P), r?.(P);
      },
      [r]
    ), N = y.useCallback(() => {
      S(), d(!1);
    }, [S]), T = y.useCallback(
      (P) => {
        i?.(P), !P.defaultPrevented && d(!u);
      },
      [i, u]
    );
    return y.useEffect(() => {
      o && p && d(!0);
    }, [o, p]), f ? /* @__PURE__ */ R(Qs, { open: u, onOpenChange: M, children: [
      /* @__PURE__ */ g(el, { asChild: !0, children: /* @__PURE__ */ g(
        qu,
        {
          disabled: !h,
          "data-active-state": p ? "on" : "off",
          "data-disabled": !h,
          "aria-label": k,
          "aria-pressed": p,
          onClick: T,
          ...l,
          ref: a,
          children: s ?? /* @__PURE__ */ g(E, { className: "tiptap-button-icon" })
        }
      ) }),
      /* @__PURE__ */ g(tl, { children: /* @__PURE__ */ g(
        B2,
        {
          url: m,
          setUrl: b,
          openInNewTab: C,
          setOpenInNewTab: v,
          setLink: N,
          removeLink: w,
          openLink: x,
          isActive: p
        }
      ) })
    ] }) : null;
  }
);
H2.displayName = "LinkPopover";
function F2(t) {
  return !t || !t.isEditable ? !1 : t.can().setMark("link");
}
function tc(t) {
  return !t || !t.isEditable ? !1 : t.isActive("link");
}
function X6(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !nn("link", e) || !e ? !1 : n && !e.isActive("code") ? F2(e) : !0;
}
function Q6(t) {
  const { editor: e, onSetLink: n } = t, [r, o] = y.useState(null), [i, s] = y.useState(!0);
  y.useEffect(() => {
    if (!e) return;
    const u = () => {
      const { href: d, target: f } = e.getAttributes("link");
      tc(e) ? (o(d || ""), s(f === "_blank")) : d || (o(""), s(!0));
    };
    return e.on("selectionUpdate", u), e.on("transaction", u), u(), () => {
      e.off("selectionUpdate", u), e.off("transaction", u);
    };
  }, [e]);
  const l = y.useCallback(() => {
    if (!r || !e) return;
    const { selection: u } = e.state, d = u.empty, f = tc(e);
    let h = e.chain().focus();
    const p = {
      href: r,
      target: i ? "_blank" : "_self"
    };
    f ? h = h.extendMarkRange("link").setLink(p) : (h = h.setLink(p), d && (h = h.insertContent({ type: "text", text: r }))), h.run(), o(null), s(!1), n?.();
  }, [e, n, r, i]), a = y.useCallback(() => {
    e && (e.chain().focus().extendMarkRange("link").unsetLink().setMeta("preventAutolink", !0).run(), o(""), s(!1));
  }, [e]), c = y.useCallback(
    (u = "_blank", d = "noopener,noreferrer") => {
      if (!r) return;
      const f = f9(r, window.location.href);
      f !== "#" && window.open(f, u, d);
    },
    [r]
  );
  return {
    url: r || "",
    setUrl: o,
    openInNewTab: i,
    setOpenInNewTab: s,
    setLink: l,
    removeLink: a,
    openLink: c
  };
}
function eT(t) {
  const { editor: e, hideWhenUnavailable: n = !1 } = t, r = F2(e), o = tc(e), [i, s] = y.useState(!1);
  return y.useEffect(() => {
    if (!e) return;
    const l = () => {
      s(
        X6({
          editor: e,
          hideWhenUnavailable: n
        })
      );
    };
    return l(), e.on("selectionUpdate", l), () => {
      e.off("selectionUpdate", l);
    };
  }, [e, n]), {
    isVisible: i,
    canSet: r,
    isActive: o
  };
}
function _2(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onSetLink: r
  } = t || {}, { editor: o } = Y(e), { isVisible: i, canSet: s, isActive: l } = eT({
    editor: o,
    hideWhenUnavailable: n
  }), a = Q6({
    editor: o,
    onSetLink: r
  });
  return {
    isVisible: i,
    canSet: s,
    isActive: l,
    label: "Link",
    Icon: nl,
    ...a
  };
}
const ms = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M20 2C20 1.44772 19.5523 1 19 1C18.4477 1 18 1.44772 18 2V4H16C15.4477 4 15 4.44772 15 5C15 5.55228 15.4477 6 16 6H18V8C18 8.55228 18.4477 9 19 9C19.5523 9 20 8.55228 20 8V6H22C22.5523 6 23 5.55228 23 5C23 4.44772 22.5523 4 22 4H20V2ZM5 4C4.73478 4 4.48043 4.10536 4.29289 4.29289C4.10536 4.48043 4 4.73478 4 5V19C4 19.2652 4.10536 19.5196 4.29289 19.7071C4.48043 19.8946 4.73478 20 5 20H5.58579L14.379 11.2068C14.9416 10.6444 15.7045 10.3284 16.5 10.3284C17.2955 10.3284 18.0584 10.6444 18.621 11.2068L20 12.5858V12C20 11.4477 20.4477 11 21 11C21.5523 11 22 11.4477 22 12V14.998C22 14.9994 22 15.0007 22 15.002V19C22 19.7957 21.6839 20.5587 21.1213 21.1213C20.5587 21.6839 19.7957 22 19 22H6.00219C6.00073 22 5.99927 22 5.99781 22H5C4.20435 22 3.44129 21.6839 2.87868 21.1213C2.31607 20.5587 2 19.7957 2 19V5C2 4.20435 2.31607 3.44129 2.87868 2.87868C3.44129 2.31607 4.20435 2 5 2H12C12.5523 2 13 2.44772 13 3C13 3.55228 12.5523 4 12 4H5ZM8.41422 20H19C19.2652 20 19.5196 19.8946 19.7071 19.7071C19.8946 19.5196 20 19.2652 20 19V15.4142L17.207 12.6212C17.0195 12.4338 16.7651 12.3284 16.5 12.3284C16.2349 12.3284 15.9806 12.4337 15.7931 12.6211L8.41422 20ZM6.87868 6.87868C7.44129 6.31607 8.20435 6 9 6C9.79565 6 10.5587 6.31607 11.1213 6.87868C11.6839 7.44129 12 8.20435 12 9C12 9.79565 11.6839 10.5587 11.1213 11.1213C10.5587 11.6839 9.79565 12 9 12C8.20435 12 7.44129 11.6839 6.87868 11.1213C6.31607 10.5587 6 9.79565 6 9C6 8.20435 6.31607 7.44129 6.87868 6.87868ZM9 8C8.73478 8 8.48043 8.10536 8.29289 8.29289C8.10536 8.48043 8 8.73478 8 9C8 9.26522 8.10536 9.51957 8.29289 9.70711C8.48043 9.89464 8.73478 10 9 10C9.26522 10 9.51957 9.89464 9.70711 9.70711C9.89464 9.51957 10 9.26522 10 9C10 8.73478 9.89464 8.48043 9.70711 8.29289C9.51957 8.10536 9.26522 8 9 8Z",
          fill: "currentColor"
        }
      )
    }
  )
);
ms.displayName = "ImagePlusIcon";
const tT = (t, e = {}) => {
  const { shouldShow: n = !0 } = e, [r, o] = y.useState(!1), [i, s] = y.useState(null);
  y.useEffect(() => {
    const c = () => {
      if (!t || !n) return;
      const { state: u } = t, { selection: d } = u;
      if (t.isActive("image")) {
        let h = null;
        if (d.node && d.node.type.name === "image")
          h = d.node;
        else {
          const { $from: p } = d, m = p.nodeAfter, b = p.nodeBefore;
          if (m && m.type.name === "image")
            h = m;
          else if (b && b.type.name === "image")
            h = b;
          else {
            const C = u.doc.nodeAt(p.pos);
            C && C.type.name === "image" && (h = C);
          }
        }
        if (h) {
          const p = h.attrs.alt || "";
          s(p), o(!0);
        } else
          o(!1), s(null);
      } else
        o(!1), s(null);
    };
    return t && (t.on("selectionUpdate", c), t.on("transaction", c), t.on("focus", c)), () => {
      t && (t.off("selectionUpdate", c), t.off("transaction", c), t.off("focus", c));
    };
  }, [t, n]);
  const l = y.useCallback(
    (c) => {
      t && (t.isActive("image") && t.commands.updateAttributes("image", {
        alt: c || ""
      }), o(!1));
    },
    [t]
  ), a = y.useCallback(() => {
    t && (t.isActive("image") && t.commands.deleteSelection(), o(!1));
  }, [t]);
  return {
    alt: i,
    setAlt: s,
    onSetImage: l,
    onRemoveImage: a,
    isOpen: r,
    setIsOpen: o
  };
};
function nT({
  shortcutKeys: t = nc
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const z2 = y.forwardRef(
  ({
    editor: t,
    text: e,
    hideWhenUnavailable: n = !1,
    onInserted: r,
    showShortcut: o = !1,
    onClick: i,
    children: s,
    ...l
  }, a) => {
    const { editor: c } = Y(t), {
      isVisible: u,
      canInsert: d,
      handleImage: f,
      label: h,
      isActive: p,
      shortcutKeys: m,
      Icon: b
    } = sT({
      editor: c,
      hideWhenUnavailable: n,
      onInserted: r
    }), C = y.useCallback(
      (v) => {
        i?.(v), !v.defaultPrevented && f();
      },
      [f, i]
    );
    return u ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        "data-style": "ghost",
        "data-active-state": p ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !d,
        "data-disabled": !d,
        "aria-label": h,
        "aria-pressed": p,
        tooltip: h,
        shortcutKeys: m,
        onClick: C,
        ...l,
        ref: a,
        children: s ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          e && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: e }),
          o && /* @__PURE__ */ g(nT, { shortcutKeys: m })
        ] })
      }
    ) : null;
  }
);
z2.displayName = "ImageUploadButton";
const nc = "mod+shift+i";
function Gu(t) {
  return !t || !t.isEditable || !Eo(t, "imageUpload") || wt(t, ["image"]) ? !1 : t.can().insertContent({ type: "imageUpload" });
}
function rT(t) {
  return !t || !t.isEditable ? !1 : t.isActive("imageUpload");
}
function oT(t) {
  if (!t || !t.isEditable || !Gu(t)) return !1;
  try {
    return t.chain().focus().insertContent({
      type: "imageUpload"
    }).run();
  } catch {
    return !1;
  }
}
function iT(t) {
  const { editor: e, hideWhenUnavailable: n } = t;
  return !e || !e.isEditable || !Eo(e, "imageUpload") ? !1 : n && !e.isActive("code") ? Gu(e) : !0;
}
function sT(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onInserted: r
  } = t || {}, { editor: o } = Y(e), i = ut(), [s, l] = y.useState(!0), a = Gu(o), c = rT(o);
  y.useEffect(() => {
    if (!o) return;
    const d = () => {
      l(iT({ editor: o, hideWhenUnavailable: n }));
    };
    return d(), o.on("selectionUpdate", d), () => {
      o.off("selectionUpdate", d);
    };
  }, [o, n]);
  const u = y.useCallback(() => {
    if (!o) return !1;
    const d = oT(o);
    return d && r?.(), d;
  }, [o, r]);
  return Lr(
    nc,
    (d) => {
      d.preventDefault(), u();
    },
    {
      enabled: s && a,
      enableOnContentEditable: !i,
      enableOnFormTags: !0
    }
  ), {
    isVisible: s,
    isActive: c,
    handleImage: u,
    canInsert: a,
    label: "Add image",
    shortcutKeys: nc,
    Icon: ms
  };
}
const lT = y.forwardRef(({ text: t, onClick: e, ...n }, r) => {
  const { editor: o } = Y(), {
    alt: i,
    setAlt: s,
    onSetImage: l,
    onRemoveImage: a,
    isOpen: c
  } = tT(o), u = ut(), [d, f] = y.useState(!1), h = (S) => {
    S.key === "Enter" && (S.preventDefault(), m());
  }, p = (S) => {
    s(S.target.value);
  }, m = y.useCallback(() => {
    l(i || void 0), f(!1);
  }, [l, i]), b = y.useCallback(() => {
    a(), f(!1);
  }, [a]), C = y.useCallback(
    (S) => {
      e?.(S), !S.defaultPrevented && c && f(!d);
    },
    [e, c, d]
  ), v = y.useCallback((S) => {
    f(S);
  }, []);
  return y.useEffect(() => {
    f(!!c);
  }, [c]), o && c ? /* @__PURE__ */ R(Qs, { open: d, onOpenChange: v, children: [
    /* @__PURE__ */ g(el, { asChild: !0, children: /* @__PURE__ */ R(
      J,
      {
        ref: r,
        "data-style": "outline",
        "data-state": d ? "open" : "closed",
        onClick: C,
        ...n,
        children: [
          /* @__PURE__ */ g(ms, { className: "tiptap-button-icon" }),
          t
        ]
      }
    ) }),
    /* @__PURE__ */ g(
      tl,
      {
        className: "tiptap-image-popover-content",
        side: "bottom",
        align: "start",
        children: /* @__PURE__ */ g(St, { "data-style": "popover", className: "tiptap-image-popover", children: /* @__PURE__ */ R(xt, { children: [
          /* @__PURE__ */ g(Xn, { children: /* @__PURE__ */ g(D2, { children: /* @__PURE__ */ g(
            L2,
            {
              type: "text",
              placeholder: "Enter alt text for accessibility...",
              value: i || "",
              onChange: p,
              onKeyDown: h,
              autoFocus: !u
            }
          ) }) }),
          /* @__PURE__ */ g(Xn, { children: /* @__PURE__ */ R(lt, { orientation: "horizontal", children: [
            /* @__PURE__ */ g(
              J,
              {
                type: "button",
                "data-style": "ghost",
                title: "Remove Image",
                onClick: b,
                children: /* @__PURE__ */ g(kn, { className: "tiptap-button-icon" })
              }
            ),
            /* @__PURE__ */ g(Ir, {}),
            /* @__PURE__ */ g(
              J,
              {
                type: "button",
                "data-style": "ghost",
                title: "Apply alt text",
                style: { marginLeft: "auto" },
                onClick: m,
                children: /* @__PURE__ */ g(ju, { className: "tiptap-button-icon" })
              }
            )
          ] }) })
        ] }) })
      }
    )
  ] }) : /* @__PURE__ */ R(z2, { ref: r, text: t, onClick: C, ...n, children: [
    /* @__PURE__ */ g(ms, { className: "tiptap-button-icon" }),
    t
  ] });
});
function aT({
  type: t,
  shortcutKeys: e = G2[t]
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: e }) });
}
const Kt = y.forwardRef(
  ({
    editor: t,
    type: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onToggled: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), {
      isVisible: d,
      handleMark: f,
      label: h,
      canToggle: p,
      isActive: m,
      Icon: b,
      shortcutKeys: C
    } = pT({
      editor: u,
      type: e,
      hideWhenUnavailable: r,
      onToggled: o
    }), v = y.useCallback(
      (S) => {
        s?.(S), !S.defaultPrevented && f();
      },
      [f, s]
    );
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        disabled: !p,
        "data-style": "ghost",
        "data-active-state": m ? "on" : "off",
        "data-disabled": !p,
        role: "button",
        tabIndex: -1,
        "aria-label": h,
        "aria-pressed": m,
        tooltip: h,
        shortcutKeys: C,
        onClick: v,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(aT, { type: e, shortcutKeys: C })
        ] })
      }
    ) : null;
  }
);
Kt.displayName = "MarkButton";
const V2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 2.5C5.17157 2.5 4.5 3.17157 4.5 4V20C4.5 20.8284 5.17157 21.5 6 21.5H15C16.4587 21.5 17.8576 20.9205 18.8891 19.8891C19.9205 18.8576 20.5 17.4587 20.5 16C20.5 14.5413 19.9205 13.1424 18.8891 12.1109C18.6781 11.9 18.4518 11.7079 18.2128 11.5359C19.041 10.5492 19.5 9.29829 19.5 8C19.5 6.54131 18.9205 5.14236 17.8891 4.11091C16.8576 3.07946 15.4587 2.5 14 2.5H6ZM14 10.5C14.663 10.5 15.2989 10.2366 15.7678 9.76777C16.2366 9.29893 16.5 8.66304 16.5 8C16.5 7.33696 16.2366 6.70107 15.7678 6.23223C15.2989 5.76339 14.663 5.5 14 5.5H7.5V10.5H14ZM7.5 18.5V13.5H15C15.663 13.5 16.2989 13.7634 16.7678 14.2322C17.2366 14.7011 17.5 15.337 17.5 16C17.5 16.663 17.2366 17.2989 16.7678 17.7678C16.2989 18.2366 15.663 18.5 15 18.5H7.5Z",
          fill: "currentColor"
        }
      )
    }
  )
);
V2.displayName = "BoldIcon";
const $2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M15.4545 4.2983C15.6192 3.77115 15.3254 3.21028 14.7983 3.04554C14.2712 2.88081 13.7103 3.1746 13.5455 3.70175L8.54554 19.7017C8.38081 20.2289 8.6746 20.7898 9.20175 20.9545C9.72889 21.1192 10.2898 20.8254 10.4545 20.2983L15.4545 4.2983Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M6.70711 7.29289C7.09763 7.68342 7.09763 8.31658 6.70711 8.70711L3.41421 12L6.70711 15.2929C7.09763 15.6834 7.09763 16.3166 6.70711 16.7071C6.31658 17.0976 5.68342 17.0976 5.29289 16.7071L1.29289 12.7071C0.902369 12.3166 0.902369 11.6834 1.29289 11.2929L5.29289 7.29289C5.68342 6.90237 6.31658 6.90237 6.70711 7.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M17.2929 7.29289C17.6834 6.90237 18.3166 6.90237 18.7071 7.29289L22.7071 11.2929C23.0976 11.6834 23.0976 12.3166 22.7071 12.7071L18.7071 16.7071C18.3166 17.0976 17.6834 17.0976 17.2929 16.7071C16.9024 16.3166 16.9024 15.6834 17.2929 15.2929L20.5858 12L17.2929 8.70711C16.9024 8.31658 16.9024 7.68342 17.2929 7.29289Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
$2.displayName = "Code2Icon";
const U2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          d: "M15.0222 3H19C19.5523 3 20 3.44772 20 4C20 4.55228 19.5523 5 19 5H15.693L10.443 19H14C14.5523 19 15 19.4477 15 20C15 20.5523 14.5523 21 14 21H9.02418C9.00802 21.0004 8.99181 21.0004 8.97557 21H5C4.44772 21 4 20.5523 4 20C4 19.4477 4.44772 19 5 19H8.30704L13.557 5H10C9.44772 5 9 4.55228 9 4C9 3.44772 9.44772 3 10 3H14.9782C14.9928 2.99968 15.0075 2.99967 15.0222 3Z",
          fill: "currentColor"
        }
      )
    }
  )
);
U2.displayName = "ItalicIcon";
const W2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M9.00039 3H16.0001C16.5524 3 17.0001 3.44772 17.0001 4C17.0001 4.55229 16.5524 5 16.0001 5H9.00011C8.68006 4.99983 8.36412 5.07648 8.07983 5.22349C7.79555 5.37051 7.55069 5.5836 7.36585 5.84487C7.181 6.10614 7.06155 6.40796 7.01754 6.72497C6.97352 7.04198 7.00623 7.36492 7.11292 7.66667C7.29701 8.18737 7.02414 8.75872 6.50344 8.94281C5.98274 9.1269 5.4114 8.85403 5.2273 8.33333C5.01393 7.72984 4.94851 7.08396 5.03654 6.44994C5.12456 5.81592 5.36346 5.21229 5.73316 4.68974C6.10285 4.1672 6.59256 3.74101 7.16113 3.44698C7.72955 3.15303 8.36047 2.99975 9.00039 3Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M18 13H20C20.5523 13 21 12.5523 21 12C21 11.4477 20.5523 11 20 11H4C3.44772 11 3 11.4477 3 12C3 12.5523 3.44772 13 4 13H14C14.7956 13 15.5587 13.3161 16.1213 13.8787C16.6839 14.4413 17 15.2044 17 16C17 16.7956 16.6839 17.5587 16.1213 18.1213C15.5587 18.6839 14.7956 19 14 19H6C5.44772 19 5 19.4477 5 20C5 20.5523 5.44772 21 6 21H14C15.3261 21 16.5979 20.4732 17.5355 19.5355C18.4732 18.5979 19 17.3261 19 16C19 14.9119 18.6453 13.8604 18 13Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
W2.displayName = "StrikeIcon";
const K2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M3.29289 7.29289C3.68342 6.90237 4.31658 6.90237 4.70711 7.29289L12.7071 15.2929C13.0976 15.6834 13.0976 16.3166 12.7071 16.7071C12.3166 17.0976 11.6834 17.0976 11.2929 16.7071L3.29289 8.70711C2.90237 8.31658 2.90237 7.68342 3.29289 7.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12.7071 7.29289C13.0976 7.68342 13.0976 8.31658 12.7071 8.70711L4.70711 16.7071C4.31658 17.0976 3.68342 17.0976 3.29289 16.7071C2.90237 16.3166 2.90237 15.6834 3.29289 15.2929L11.2929 7.29289C11.6834 6.90237 12.3166 6.90237 12.7071 7.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M17.4079 14.3995C18.0284 14.0487 18.7506 13.9217 19.4536 14.0397C20.1566 14.1578 20.7977 14.5138 21.2696 15.0481L21.2779 15.0574L21.2778 15.0575C21.7439 15.5988 22 16.2903 22 17C22 18.0823 21.3962 18.8401 20.7744 19.3404C20.194 19.8073 19.4858 20.141 18.9828 20.378C18.9638 20.387 18.9451 20.3958 18.9266 20.4045C18.4473 20.6306 18.2804 20.7817 18.1922 20.918C18.1773 20.9412 18.1619 20.9681 18.1467 21H21C21.5523 21 22 21.4477 22 22C22 22.5523 21.5523 23 21 23H17C16.4477 23 16 22.5523 16 22C16 21.1708 16.1176 20.4431 16.5128 19.832C16.9096 19.2184 17.4928 18.8695 18.0734 18.5956C18.6279 18.334 19.138 18.0901 19.5207 17.7821C19.8838 17.49 20 17.2477 20 17C20 16.7718 19.9176 16.5452 19.7663 16.3672C19.5983 16.1792 19.3712 16.0539 19.1224 16.0121C18.8722 15.9701 18.6152 16.015 18.3942 16.1394C18.1794 16.2628 18.0205 16.4549 17.9422 16.675C17.7572 17.1954 17.1854 17.4673 16.665 17.2822C16.1446 17.0972 15.8728 16.5254 16.0578 16.005C16.2993 15.3259 16.7797 14.7584 17.4039 14.4018L17.4079 14.3995L17.4079 14.3995Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
K2.displayName = "SubscriptIcon";
const j2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12.7071 7.29289C13.0976 7.68342 13.0976 8.31658 12.7071 8.70711L4.70711 16.7071C4.31658 17.0976 3.68342 17.0976 3.29289 16.7071C2.90237 16.3166 2.90237 15.6834 3.29289 15.2929L11.2929 7.29289C11.6834 6.90237 12.3166 6.90237 12.7071 7.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M3.29289 7.29289C3.68342 6.90237 4.31658 6.90237 4.70711 7.29289L12.7071 15.2929C13.0976 15.6834 13.0976 16.3166 12.7071 16.7071C12.3166 17.0976 11.6834 17.0976 11.2929 16.7071L3.29289 8.70711C2.90237 8.31658 2.90237 7.68342 3.29289 7.29289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M17.405 1.40657C18.0246 1.05456 18.7463 0.92634 19.4492 1.04344C20.1521 1.16054 20.7933 1.51583 21.2652 2.0497L21.2697 2.05469L21.2696 2.05471C21.7431 2.5975 22 3.28922 22 4.00203C22 5.08579 21.3952 5.84326 20.7727 6.34289C20.1966 6.80531 19.4941 7.13675 18.9941 7.37261C18.9714 7.38332 18.9491 7.39383 18.9273 7.40415C18.4487 7.63034 18.2814 7.78152 18.1927 7.91844C18.1778 7.94155 18.1625 7.96834 18.1473 8.00003H21C21.5523 8.00003 22 8.44774 22 9.00003C22 9.55231 21.5523 10 21 10H17C16.4477 10 16 9.55231 16 9.00003C16 8.17007 16.1183 7.44255 16.5138 6.83161C16.9107 6.21854 17.4934 5.86971 18.0728 5.59591C18.6281 5.33347 19.1376 5.09075 19.5208 4.78316C19.8838 4.49179 20 4.25026 20 4.00203C20 3.77192 19.9178 3.54865 19.7646 3.37182C19.5968 3.18324 19.3696 3.05774 19.1205 3.01625C18.8705 2.97459 18.6137 3.02017 18.3933 3.14533C18.1762 3.26898 18.0191 3.45826 17.9406 3.67557C17.7531 4.19504 17.18 4.46414 16.6605 4.27662C16.141 4.0891 15.8719 3.51596 16.0594 2.99649C16.303 2.3219 16.7817 1.76125 17.4045 1.40689L17.405 1.40657Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
j2.displayName = "SuperscriptIcon";
const q2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M7 4C7 3.44772 6.55228 3 6 3C5.44772 3 5 3.44772 5 4V10C5 11.8565 5.7375 13.637 7.05025 14.9497C8.36301 16.2625 10.1435 17 12 17C13.8565 17 15.637 16.2625 16.9497 14.9497C18.2625 13.637 19 11.8565 19 10V4C19 3.44772 18.5523 3 18 3C17.4477 3 17 3.44772 17 4V10C17 11.3261 16.4732 12.5979 15.5355 13.5355C14.5979 14.4732 13.3261 15 12 15C10.6739 15 9.40215 14.4732 8.46447 13.5355C7.52678 12.5979 7 11.3261 7 10V4ZM4 19C3.44772 19 3 19.4477 3 20C3 20.5523 3.44772 21 4 21H20C20.5523 21 21 20.5523 21 20C21 19.4477 20.5523 19 20 19H4Z",
          fill: "currentColor"
        }
      )
    }
  )
);
q2.displayName = "UnderlineIcon";
const cT = {
  bold: V2,
  italic: U2,
  underline: q2,
  strike: W2,
  code: $2,
  superscript: j2,
  subscript: K2
}, G2 = {
  bold: "mod+b",
  italic: "mod+i",
  underline: "mod+u",
  strike: "mod+shift+s",
  code: "mod+e",
  superscript: "mod+.",
  subscript: "mod+,"
};
function Zu(t, e) {
  return !t || !t.isEditable || !nn(e, t) || wt(t, ["image"]) ? !1 : t.can().toggleMark(e);
}
function uT(t, e) {
  return !t || !t.isEditable ? !1 : t.isActive(e);
}
function dT(t, e) {
  return !t || !t.isEditable || !Zu(t, e) ? !1 : t.chain().focus().toggleMark(e).run();
}
function fT(t) {
  const { editor: e, type: n, hideWhenUnavailable: r } = t;
  return !e || !e.isEditable || !nn(n, e) ? !1 : r && !e.isActive("code") ? Zu(e, n) : !0;
}
function hT(t) {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
function pT(t) {
  const {
    editor: e,
    type: n,
    hideWhenUnavailable: r = !1,
    onToggled: o
  } = t, { editor: i } = Y(e), [s, l] = y.useState(!0), a = Zu(i, n), c = uT(i, n);
  y.useEffect(() => {
    if (!i) return;
    const d = () => {
      l(fT({ editor: i, type: n, hideWhenUnavailable: r }));
    };
    return d(), i.on("selectionUpdate", d), () => {
      i.off("selectionUpdate", d);
    };
  }, [i, n, r]);
  const u = y.useCallback(() => {
    if (!i) return !1;
    const d = dT(i, n);
    return d && o?.(), d;
  }, [i, n, o]);
  return {
    isVisible: s,
    isActive: c,
    handleMark: u,
    canToggle: a,
    label: hT(n),
    shortcutKeys: G2[n],
    Icon: cT[n]
  };
}
function mT({
  align: t,
  shortcutKeys: e = rc[t]
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: e }) });
}
const Z2 = y.forwardRef(
  ({
    editor: t,
    align: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onAligned: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), {
      isVisible: d,
      handleTextAlign: f,
      label: h,
      canAlign: p,
      isActive: m,
      Icon: b,
      shortcutKeys: C
    } = ST({
      editor: u,
      align: e,
      hideWhenUnavailable: r,
      onAligned: o
    }), v = y.useCallback(
      (S) => {
        s?.(S), !S.defaultPrevented && f();
      },
      [f, s]
    );
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        disabled: !p,
        "data-style": "ghost",
        "data-active-state": m ? "on" : "off",
        "data-disabled": !p,
        role: "button",
        tabIndex: -1,
        "aria-label": h,
        "aria-pressed": m,
        tooltip: h,
        shortcutKeys: C,
        onClick: v,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(b, { className: "tiptap-button-icon" }),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(
            mT,
            {
              align: e,
              shortcutKeys: C
            }
          )
        ] })
      }
    ) : null;
  }
);
Z2.displayName = "TextAlignButton";
const J2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6 12C6 11.4477 6.44772 11 7 11H17C17.5523 11 18 11.4477 18 12C18 12.5523 17.5523 13 17 13H7C6.44772 13 6 12.5523 6 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4 18C4 17.4477 4.44772 17 5 17H19C19.5523 17 20 17.4477 20 18C20 18.5523 19.5523 19 19 19H5C4.44772 19 4 18.5523 4 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
J2.displayName = "AlignCenterIcon";
const Y2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 12C2 11.4477 2.44772 11 3 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H3C2.44772 13 2 12.5523 2 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 18C2 17.4477 2.44772 17 3 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H3C2.44772 19 2 18.5523 2 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Y2.displayName = "AlignJustifyIcon";
const X2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 12C2 11.4477 2.44772 11 3 11H15C15.5523 11 16 11.4477 16 12C16 12.5523 15.5523 13 15 13H3C2.44772 13 2 12.5523 2 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 18C2 17.4477 2.44772 17 3 17H17C17.5523 17 18 17.4477 18 18C18 18.5523 17.5523 19 17 19H3C2.44772 19 2 18.5523 2 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
X2.displayName = "AlignLeftIcon";
const Q2 = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M8 12C8 11.4477 8.44772 11 9 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H9C8.44772 13 8 12.5523 8 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M6 18C6 17.4477 6.44772 17 7 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H7C6.44772 19 6 18.5523 6 18Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
Q2.displayName = "AlignRightIcon";
const rc = {
  left: "mod+shift+l",
  center: "mod+shift+e",
  right: "mod+shift+r",
  justify: "mod+shift+j"
}, gT = {
  left: X2,
  center: J2,
  right: Q2,
  justify: Y2
}, yT = {
  left: "Align left",
  center: "Align center",
  right: "Align right",
  justify: "Align justify"
};
function Ju(t, e) {
  return !t || !t.isEditable || !Eo(t, "textAlign") || wt(t, ["image"]) ? !1 : t.can().setTextAlign(e);
}
function bT(t) {
  return "setTextAlign" in t;
}
function CT(t, e) {
  return !t || !t.isEditable ? !1 : t.isActive({ textAlign: e });
}
function vT(t, e) {
  if (!t || !t.isEditable || !Ju(t, e)) return !1;
  const n = t.chain().focus();
  return bT(n) ? n.setTextAlign(e).run() : !1;
}
function wT(t) {
  const { editor: e, hideWhenUnavailable: n, align: r } = t;
  return !e || !e.isEditable || !Eo(e, "textAlign") ? !1 : n && !e.isActive("code") ? Ju(e, r) : !0;
}
function ST(t) {
  const {
    editor: e,
    align: n,
    hideWhenUnavailable: r = !1,
    onAligned: o
  } = t, { editor: i } = Y(e), s = ut(), [l, a] = y.useState(!0), c = Ju(i, n), u = CT(i, n);
  y.useEffect(() => {
    if (!i) return;
    const f = () => {
      a(wT({ editor: i, align: n, hideWhenUnavailable: r }));
    };
    return f(), i.on("selectionUpdate", f), () => {
      i.off("selectionUpdate", f);
    };
  }, [i, r, n]);
  const d = y.useCallback(() => {
    if (!i) return !1;
    const f = vT(i, n);
    return f && o?.(), f;
  }, [i, n, o]);
  return Lr(
    rc[n],
    (f) => {
      f.preventDefault(), d();
    },
    {
      enabled: l && c,
      enableOnContentEditable: !s,
      enableOnFormTags: !0
    }
  ), {
    isVisible: l,
    isActive: u,
    handleTextAlign: d,
    canAlign: c,
    label: yT[n],
    shortcutKeys: rc[n],
    Icon: gT[n]
  };
}
function xT({
  action: t,
  shortcutKeys: e = ic[t]
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: e }) });
}
const oc = y.forwardRef(
  ({
    editor: t,
    action: e,
    text: n,
    hideWhenUnavailable: r = !1,
    onExecuted: o,
    showShortcut: i = !1,
    onClick: s,
    children: l,
    ...a
  }, c) => {
    const { editor: u } = Y(t), { isVisible: d, handleAction: f, label: h, canExecute: p, Icon: m, shortcutKeys: b } = RT({
      editor: u,
      action: e,
      hideWhenUnavailable: r,
      onExecuted: o
    }), C = y.useCallback(
      (v) => {
        s?.(v), !v.defaultPrevented && f();
      },
      [f, s]
    );
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        disabled: !p,
        "data-style": "ghost",
        "data-disabled": !p,
        role: "button",
        tabIndex: -1,
        "aria-label": h,
        tooltip: h,
        shortcutKeys: b,
        onClick: C,
        ...a,
        ref: c,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(m, { className: "tiptap-button-icon" }),
          n && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: n }),
          i && /* @__PURE__ */ g(
            xT,
            {
              action: e,
              shortcutKeys: b
            }
          )
        ] })
      }
    ) : null;
  }
);
oc.displayName = "UndoRedoButton";
const ey = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M15.7071 2.29289C15.3166 1.90237 14.6834 1.90237 14.2929 2.29289C13.9024 2.68342 13.9024 3.31658 14.2929 3.70711L17.5858 7H9.5C7.77609 7 6.12279 7.68482 4.90381 8.90381C3.68482 10.1228 3 11.7761 3 13.5C3 14.3536 3.16813 15.1988 3.49478 15.9874C3.82144 16.7761 4.30023 17.4926 4.90381 18.0962C6.12279 19.3152 7.77609 20 9.5 20H13C13.5523 20 14 19.5523 14 19C14 18.4477 13.5523 18 13 18H9.5C8.30653 18 7.16193 17.5259 6.31802 16.682C5.90016 16.2641 5.56869 15.768 5.34254 15.2221C5.1164 14.6761 5 14.0909 5 13.5C5 12.3065 5.47411 11.1619 6.31802 10.318C7.16193 9.47411 8.30653 9 9.5 9H17.5858L14.2929 12.2929C13.9024 12.6834 13.9024 13.3166 14.2929 13.7071C14.6834 14.0976 15.3166 14.0976 15.7071 13.7071L20.7071 8.70711C21.0976 8.31658 21.0976 7.68342 20.7071 7.29289L15.7071 2.29289Z",
          fill: "currentColor"
        }
      )
    }
  )
);
ey.displayName = "Redo2Icon";
const ty = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.70711 3.70711C10.0976 3.31658 10.0976 2.68342 9.70711 2.29289C9.31658 1.90237 8.68342 1.90237 8.29289 2.29289L3.29289 7.29289C2.90237 7.68342 2.90237 8.31658 3.29289 8.70711L8.29289 13.7071C8.68342 14.0976 9.31658 14.0976 9.70711 13.7071C10.0976 13.3166 10.0976 12.6834 9.70711 12.2929L6.41421 9H14.5C15.0909 9 15.6761 9.1164 16.2221 9.34254C16.768 9.56869 17.2641 9.90016 17.682 10.318C18.0998 10.7359 18.4313 11.232 18.6575 11.7779C18.8836 12.3239 19 12.9091 19 13.5C19 14.0909 18.8836 14.6761 18.6575 15.2221C18.4313 15.768 18.0998 16.2641 17.682 16.682C17.2641 17.0998 16.768 17.4313 16.2221 17.6575C15.6761 17.8836 15.0909 18 14.5 18H11C10.4477 18 10 18.4477 10 19C10 19.5523 10.4477 20 11 20H14.5C15.3536 20 16.1988 19.8319 16.9874 19.5052C17.7761 19.1786 18.4926 18.6998 19.0962 18.0962C19.6998 17.4926 20.1786 16.7761 20.5052 15.9874C20.8319 15.1988 21 14.3536 21 13.5C21 12.6464 20.8319 11.8012 20.5052 11.0126C20.1786 10.2239 19.6998 9.50739 19.0962 8.90381C18.4926 8.30022 17.7761 7.82144 16.9874 7.49478C16.1988 7.16813 15.3536 7 14.5 7H6.41421L9.70711 3.70711Z",
          fill: "currentColor"
        }
      )
    }
  )
);
ty.displayName = "Undo2Icon";
const ic = {
  undo: "mod+z",
  redo: "mod+shift+z"
}, kT = {
  undo: "Undo",
  redo: "Redo"
}, ET = {
  undo: ty,
  redo: ey
};
function Yu(t, e) {
  return !t || !t.isEditable || wt(t, ["image"]) ? !1 : e === "undo" ? t.can().undo() : t.can().redo();
}
function MT(t, e) {
  if (!t || !t.isEditable || !Yu(t, e)) return !1;
  const n = t.chain().focus();
  return e === "undo" ? n.undo().run() : n.redo().run();
}
function TT(t) {
  const { editor: e, hideWhenUnavailable: n, action: r } = t;
  return !e || !e.isEditable ? !1 : n && !e.isActive("code") ? Yu(e, r) : !0;
}
function RT(t) {
  const {
    editor: e,
    action: n,
    hideWhenUnavailable: r = !1,
    onExecuted: o
  } = t, { editor: i } = Y(e), s = ut(), [l, a] = y.useState(!0), c = Yu(i, n);
  y.useEffect(() => {
    if (!i) return;
    const d = () => {
      a(TT({ editor: i, hideWhenUnavailable: r, action: n }));
    };
    return d(), i.on("transaction", d), () => {
      i.off("transaction", d);
    };
  }, [i, r, n]);
  const u = y.useCallback(() => {
    if (!i) return !1;
    const d = MT(i, n);
    return d && o?.(), d;
  }, [i, n, o]);
  return Lr(
    ic[n],
    (d) => {
      d.preventDefault(), u();
    },
    {
      enabled: l && c,
      enableOnContentEditable: !s,
      enableOnFormTags: !0
    }
  ), {
    isVisible: l,
    handleAction: u,
    canExecute: c,
    label: kT[n],
    shortcutKeys: ic[n],
    Icon: ET[n]
  };
}
const ny = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ R(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: t,
    ref: n,
    ...e,
    children: [
      /* @__PURE__ */ g(
        "path",
        {
          d: "M3 5C2.44772 5 2 4.55228 2 4C2 3.44772 2.44772 3 3 3H21C21.5523 3 22 3.44772 22 4C22 4.55228 21.5523 5 21 5H3Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M3 12C2.44772 12 2 11.5523 2 11C2 10.4477 2.44772 10 3 10H8C8.55228 10 9 10.4477 9 11C9 11.5523 8.55228 12 8 12H3Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M16 12C15.4477 12 15 11.5523 15 11C15 10.4477 15.4477 10 16 10H21C21.5523 10 22 10.4477 22 11C22 11.5523 21.5523 12 21 12H16Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M10 11L12 9L14 11",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M10 13L12 15L14 13",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M3 19C2.44772 19 2 18.5523 2 18C2 17.4477 2.44772 17 3 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H3Z",
          fill: "currentColor"
        }
      )
    ]
  }
));
ny.displayName = "PageBreakIcon";
const ry = "mod+enter";
function AT(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onInserted: r
  } = t, { editor: o } = Y(e), [i, s] = y.useState(!0), l = o?.can().insertPageBreak() ?? !1;
  y.useEffect(() => {
    if (!o) return;
    const c = () => {
      s(n ? o.can().insertPageBreak() : !0);
    };
    return c(), o.on("selectionUpdate", c), () => {
      o.off("selectionUpdate", c);
    };
  }, [o, n]);
  const a = y.useCallback(() => {
    if (!o || !l) return !1;
    const c = o.chain().focus().insertPageBreak().run();
    return c && r?.(), c;
  }, [o, l, r]);
  return {
    editor: o,
    canInsertPageBreak: l,
    isVisible: i,
    handleInsertPageBreak: a
  };
}
function OT({
  shortcutKeys: t = ry
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const oy = y.forwardRef(
  ({
    editor: t,
    hideWhenUnavailable: e = !1,
    onInserted: n,
    text: r,
    showShortcut: o = !1,
    shortcutKeys: i = ry,
    className: s,
    children: l,
    ...a
  }, c) => {
    const { canInsertPageBreak: u, isVisible: d, handleInsertPageBreak: f } = AT({
      editor: t,
      hideWhenUnavailable: e,
      onInserted: n
    });
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        className: s,
        "data-style": "ghost",
        "data-appearance": "default",
        role: "button",
        tabIndex: -1,
        "aria-label": "Insert page break",
        tooltip: "Page Break",
        shortcutKeys: i,
        ref: c,
        onClick: f,
        disabled: !u,
        ...a,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(ny, { className: "tiptap-button-icon" }),
          r && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: r }),
          o && /* @__PURE__ */ g(OT, { shortcutKeys: i })
        ] })
      }
    ) : null;
  }
);
oy.displayName = "PageBreakButton";
const iy = y.forwardRef(({ className: t, ...e }, n) => /* @__PURE__ */ R(
  "svg",
  {
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: t,
    ref: n,
    ...e,
    children: [
      /* @__PURE__ */ g(
        "path",
        {
          d: "M3 6C2.44772 6 2 5.55228 2 5C2 4.44772 2.44772 4 3 4H21C21.5523 4 22 4.44772 22 5C22 5.55228 21.5523 6 21 6H3Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M6 10C5.44772 10 5 9.55228 5 9C5 8.44772 5.44772 8 6 8H18C18.5523 8 19 8.44772 19 9C19 9.55228 18.5523 10 18 10H6Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M9 14C8.44772 14 8 13.5523 8 13C8 12.4477 8.44772 12 9 12H15C15.5523 12 16 12.4477 16 13C16 13.5523 15.5523 14 15 14H9Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M6 18C5.44772 18 5 17.5523 5 17C5 16.4477 5.44772 16 6 16H18C18.5523 16 19 16.4477 19 17C19 17.5523 18.5523 18 18 18H6Z",
          fill: "currentColor"
        }
      ),
      /* @__PURE__ */ g(
        "path",
        {
          d: "M3 20C2.44772 20 2 19.5523 2 19C2 18.4477 2.44772 18 3 18H21C21.5523 18 22 18.4477 22 19C22 19.5523 21.5523 20 21 20H3Z",
          fill: "currentColor"
        }
      )
    ]
  }
));
iy.displayName = "TableOfContentsIcon";
const sy = "mod+shift+t";
function NT(t) {
  const {
    editor: e,
    hideWhenUnavailable: n = !1,
    onInserted: r
  } = t, { editor: o } = Y(e), [i, s] = y.useState(!0), l = o?.can().insertTableOfContents() ?? !1;
  y.useEffect(() => {
    if (!o) return;
    const c = () => {
      s(n ? o.can().insertTableOfContents() : !0);
    };
    return c(), o.on("selectionUpdate", c), () => {
      o.off("selectionUpdate", c);
    };
  }, [o, n]);
  const a = y.useCallback(() => {
    if (!o || !l) return !1;
    const c = o.chain().focus().insertTableOfContents().run();
    return c && r?.(), c;
  }, [o, l, r]);
  return {
    editor: o,
    canInsertTableOfContents: l,
    isVisible: i,
    handleInsertTableOfContents: a
  };
}
function IT({
  shortcutKeys: t = sy
}) {
  return /* @__PURE__ */ g(ct, { children: at({ shortcutKeys: t }) });
}
const ly = y.forwardRef(
  ({
    editor: t,
    hideWhenUnavailable: e = !1,
    onInserted: n,
    text: r,
    showShortcut: o = !1,
    shortcutKeys: i = sy,
    className: s,
    children: l,
    ...a
  }, c) => {
    const { canInsertTableOfContents: u, isVisible: d, handleInsertTableOfContents: f } = NT({
      editor: t,
      hideWhenUnavailable: e,
      onInserted: n
    });
    return d ? /* @__PURE__ */ g(
      J,
      {
        type: "button",
        className: s,
        "data-style": "ghost",
        "data-appearance": "default",
        role: "button",
        tabIndex: -1,
        "aria-label": "Insert table of contents",
        tooltip: "Table of Contents",
        shortcutKeys: i,
        ref: c,
        onClick: f,
        disabled: !u,
        ...a,
        children: l ?? /* @__PURE__ */ R(le, { children: [
          /* @__PURE__ */ g(iy, { className: "tiptap-button-icon" }),
          r && /* @__PURE__ */ g("span", { className: "tiptap-button-text", children: r }),
          o && /* @__PURE__ */ g(IT, { shortcutKeys: i })
        ] })
      }
    ) : null;
  }
);
ly.displayName = "TableOfContentsButton";
function LT(t, e) {
  const n = Math.min(t.top, e.top), r = Math.max(t.bottom, e.bottom), o = Math.min(t.left, e.left), s = Math.max(t.right, e.right) - o, l = r - n, a = o, c = n;
  return new DOMRect(a, c, s, l);
}
var DT = class {
  constructor({
    editor: t,
    element: e,
    view: n,
    updateDelay: r = 250,
    resizeDelay: o = 60,
    shouldShow: i,
    appendTo: s,
    getReferencedVirtualElement: l,
    options: a
  }) {
    this.preventHide = !1, this.isVisible = !1, this.scrollTarget = window, this.floatingUIOptions = {
      strategy: "absolute",
      placement: "top",
      offset: 8,
      flip: {},
      shift: {},
      arrow: !1,
      size: !1,
      autoPlacement: !1,
      hide: !1,
      inline: !1,
      onShow: void 0,
      onHide: void 0,
      onUpdate: void 0,
      onDestroy: void 0
    }, this.shouldShow = ({ view: u, state: d, from: f, to: h }) => {
      const { doc: p, selection: m } = d, { empty: b } = m, C = !p.textBetween(f, h).length && Pc(d.selection), v = this.element.contains(document.activeElement);
      return !(!(u.hasFocus() || v) || b || C || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.resizeHandler = () => {
      this.resizeDebounceTimer && clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = window.setTimeout(() => {
        this.updatePosition();
      }, this.resizeDelay);
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: u }) => {
      var d;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      u?.relatedTarget && ((d = this.element.parentNode) != null && d.contains(u.relatedTarget)) || u?.relatedTarget !== this.editor.view.dom && this.hide();
    }, this.handleDebouncedUpdate = (u, d) => {
      const f = !d?.selection.eq(u.state.selection), h = !d?.doc.eq(u.state.doc);
      !f && !h || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(u, f, h, d);
      }, this.updateDelay));
    }, this.updateHandler = (u, d, f, h) => {
      const { composing: p } = u;
      if (p || !d && !f)
        return;
      if (!this.getShouldShow(h)) {
        this.hide();
        return;
      }
      this.updatePosition(), this.show();
    };
    var c;
    this.editor = t, this.element = e, this.view = n, this.updateDelay = r, this.resizeDelay = o, this.appendTo = s, this.scrollTarget = (c = a?.scrollTarget) != null ? c : window, this.getReferencedVirtualElement = l, this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...a
    }, this.element.tabIndex = 0, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), window.addEventListener("resize", this.resizeHandler), this.scrollTarget.addEventListener("scroll", this.resizeHandler), this.update(n, n.state), this.getShouldShow() && this.show();
  }
  get middlewares() {
    const t = [];
    return this.floatingUIOptions.flip && t.push(lu(typeof this.floatingUIOptions.flip != "boolean" ? this.floatingUIOptions.flip : void 0)), this.floatingUIOptions.shift && t.push(
      su(typeof this.floatingUIOptions.shift != "boolean" ? this.floatingUIOptions.shift : void 0)
    ), this.floatingUIOptions.offset && t.push(
      iu(typeof this.floatingUIOptions.offset != "boolean" ? this.floatingUIOptions.offset : void 0)
    ), this.floatingUIOptions.arrow && t.push(us(this.floatingUIOptions.arrow)), this.floatingUIOptions.size && t.push(au(typeof this.floatingUIOptions.size != "boolean" ? this.floatingUIOptions.size : void 0)), this.floatingUIOptions.autoPlacement && t.push(
      eg(
        typeof this.floatingUIOptions.autoPlacement != "boolean" ? this.floatingUIOptions.autoPlacement : void 0
      )
    ), this.floatingUIOptions.hide && t.push(cu(typeof this.floatingUIOptions.hide != "boolean" ? this.floatingUIOptions.hide : void 0)), this.floatingUIOptions.inline && t.push(
      tg(typeof this.floatingUIOptions.inline != "boolean" ? this.floatingUIOptions.inline : void 0)
    ), t;
  }
  get virtualElement() {
    var t;
    const { selection: e } = this.editor.state, n = (t = this.getReferencedVirtualElement) == null ? void 0 : t.call(this);
    if (n)
      return n;
    const r = Sm(this.view, e.from, e.to);
    let o = {
      getBoundingClientRect: () => r,
      getClientRects: () => [r]
    };
    if (e instanceof z) {
      let i = this.view.nodeDOM(e.from);
      const s = i.dataset.nodeViewWrapper ? i : i.querySelector("[data-node-view-wrapper]");
      s && (i = s), i && (o = {
        getBoundingClientRect: () => i.getBoundingClientRect(),
        getClientRects: () => [i.getBoundingClientRect()]
      });
    }
    if (e instanceof se) {
      const { $anchorCell: i, $headCell: s } = e, l = i ? i.pos : s.pos, a = s ? s.pos : i.pos, c = this.view.nodeDOM(l), u = this.view.nodeDOM(a);
      if (!c || !u)
        return;
      const d = c === u ? c.getBoundingClientRect() : LT(
        c.getBoundingClientRect(),
        u.getBoundingClientRect()
      );
      o = {
        getBoundingClientRect: () => d,
        getClientRects: () => [d]
      };
    }
    return o;
  }
  updatePosition() {
    const t = this.virtualElement;
    t && uu(t, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x: e, y: n, strategy: r }) => {
      this.element.style.width = "max-content", this.element.style.position = r, this.element.style.left = `${e}px`, this.element.style.top = `${n}px`, this.isVisible && this.floatingUIOptions.onUpdate && this.floatingUIOptions.onUpdate();
    });
  }
  update(t, e) {
    const { state: n } = t, r = n.selection.from !== n.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(t, e);
      return;
    }
    const o = !e?.selection.eq(t.state.selection), i = !e?.doc.eq(t.state.doc);
    this.updateHandler(t, o, i, e);
  }
  getShouldShow(t) {
    var e;
    const { state: n } = this.view, { selection: r } = n, { ranges: o } = r, i = Math.min(...o.map((a) => a.$from.pos)), s = Math.max(...o.map((a) => a.$to.pos));
    return (e = this.shouldShow) == null ? void 0 : e.call(this, {
      editor: this.editor,
      element: this.element,
      view: this.view,
      state: n,
      oldState: t,
      from: i,
      to: s
    });
  }
  show() {
    var t, e;
    this.isVisible || (this.element.style.visibility = "visible", this.element.style.opacity = "1", (e = (t = this.appendTo) != null ? t : this.view.dom.parentElement) == null || e.appendChild(this.element), this.floatingUIOptions.onShow && this.floatingUIOptions.onShow(), this.isVisible = !0);
  }
  hide() {
    this.isVisible && (this.element.style.visibility = "hidden", this.element.style.opacity = "0", this.element.remove(), this.floatingUIOptions.onHide && this.floatingUIOptions.onHide(), this.isVisible = !1);
  }
  destroy() {
    this.hide(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), window.removeEventListener("resize", this.resizeHandler), this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler), this.floatingUIOptions.onDestroy && this.floatingUIOptions.onDestroy();
  }
}, ay = (t) => new ue({
  key: typeof t.pluginKey == "string" ? new pe(t.pluginKey) : t.pluginKey,
  view: (e) => new DT({ view: e, ...t })
});
Q.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      appendTo: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      ay({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        updateDelay: this.options.updateDelay,
        options: this.options.options,
        appendTo: this.options.appendTo,
        getReferencedVirtualElement: this.options.getReferencedVirtualElement,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
var PT = class {
  constructor({ editor: t, element: e, view: n, options: r, shouldShow: o }) {
    this.preventHide = !1, this.isVisible = !1, this.shouldShow = ({ view: i, state: s }) => {
      const { selection: l } = s, { $anchor: a, empty: c } = l, u = a.depth === 1, d = a.parent.isTextblock && !a.parent.type.spec.code && !a.parent.textContent && a.parent.childCount === 0 && !this.getTextContent(a.parent);
      return !(!i.hasFocus() || !c || !u || !d || !this.editor.isEditable);
    }, this.floatingUIOptions = {
      strategy: "absolute",
      placement: "right",
      offset: 8,
      flip: {},
      shift: {},
      arrow: !1,
      size: !1,
      autoPlacement: !1,
      hide: !1,
      inline: !1
    }, this.updateHandler = (i, s, l, a) => {
      const { composing: c } = i;
      if (c || !s && !l)
        return;
      if (!this.getShouldShow(a)) {
        this.hide();
        return;
      }
      this.updatePosition(), this.show();
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: i }) => {
      var s;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      i?.relatedTarget && ((s = this.element.parentNode) != null && s.contains(i.relatedTarget)) || i?.relatedTarget !== this.editor.view.dom && this.hide();
    }, this.editor = t, this.element = e, this.view = n, this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...r
    }, this.element.tabIndex = 0, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.update(n, n.state), this.getShouldShow() && this.show();
  }
  getTextContent(t) {
    return gm(t, { textSerializers: Nc(this.editor.schema) });
  }
  get middlewares() {
    const t = [];
    return this.floatingUIOptions.flip && t.push(lu(typeof this.floatingUIOptions.flip != "boolean" ? this.floatingUIOptions.flip : void 0)), this.floatingUIOptions.shift && t.push(
      su(typeof this.floatingUIOptions.shift != "boolean" ? this.floatingUIOptions.shift : void 0)
    ), this.floatingUIOptions.offset && t.push(
      iu(typeof this.floatingUIOptions.offset != "boolean" ? this.floatingUIOptions.offset : void 0)
    ), this.floatingUIOptions.arrow && t.push(us(this.floatingUIOptions.arrow)), this.floatingUIOptions.size && t.push(au(typeof this.floatingUIOptions.size != "boolean" ? this.floatingUIOptions.size : void 0)), this.floatingUIOptions.autoPlacement && t.push(
      eg(
        typeof this.floatingUIOptions.autoPlacement != "boolean" ? this.floatingUIOptions.autoPlacement : void 0
      )
    ), this.floatingUIOptions.hide && t.push(cu(typeof this.floatingUIOptions.hide != "boolean" ? this.floatingUIOptions.hide : void 0)), this.floatingUIOptions.inline && t.push(
      tg(typeof this.floatingUIOptions.inline != "boolean" ? this.floatingUIOptions.inline : void 0)
    ), t;
  }
  getShouldShow(t) {
    var e;
    const { state: n } = this.view, { selection: r } = n, { ranges: o } = r, i = Math.min(...o.map((a) => a.$from.pos)), s = Math.max(...o.map((a) => a.$to.pos));
    return (e = this.shouldShow) == null ? void 0 : e.call(this, {
      editor: this.editor,
      view: this.view,
      state: n,
      oldState: t,
      from: i,
      to: s
    });
  }
  updatePosition() {
    const { selection: t } = this.editor.state, e = Sm(this.view, t.from, t.to);
    uu({
      getBoundingClientRect: () => e,
      getClientRects: () => [e]
    }, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x: r, y: o, strategy: i }) => {
      this.element.style.width = "max-content", this.element.style.position = i, this.element.style.left = `${r}px`, this.element.style.top = `${o}px`, this.isVisible && this.floatingUIOptions.onUpdate && this.floatingUIOptions.onUpdate();
    });
  }
  update(t, e) {
    const n = !e?.selection.eq(t.state.selection), r = !e?.doc.eq(t.state.doc);
    this.updateHandler(t, n, r, e);
  }
  show() {
    var t;
    this.isVisible || (this.element.style.visibility = "visible", this.element.style.opacity = "1", (t = this.view.dom.parentElement) == null || t.appendChild(this.element), this.floatingUIOptions.onShow && this.floatingUIOptions.onShow(), this.isVisible = !0);
  }
  hide() {
    this.isVisible && (this.element.style.visibility = "hidden", this.element.style.opacity = "0", this.element.remove(), this.floatingUIOptions.onHide && this.floatingUIOptions.onHide(), this.isVisible = !1);
  }
  destroy() {
    this.hide(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler), this.floatingUIOptions.onDestroy && this.floatingUIOptions.onDestroy();
  }
}, cy = (t) => new ue({
  key: typeof t.pluginKey == "string" ? new pe(t.pluginKey) : t.pluginKey,
  view: (e) => new PT({ view: e, ...t })
});
Q.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      options: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      cy({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        options: this.options.options,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
var BT = ve.forwardRef(
  ({ pluginKey: t = "bubbleMenu", editor: e, updateDelay: n, resizeDelay: r, shouldShow: o = null, options: i, children: s, ...l }, a) => {
    const c = Nt(document.createElement("div"));
    typeof a == "function" ? a(c.current) : a && (a.current = c.current);
    const { editor: u } = Fc();
    return Zt(() => {
      const d = c.current;
      if (d.style.visibility = "hidden", d.style.position = "absolute", e?.isDestroyed || u?.isDestroyed)
        return;
      const f = e || u;
      if (!f) {
        console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
        return;
      }
      const h = ay({
        updateDelay: n,
        resizeDelay: r,
        editor: f,
        element: d,
        pluginKey: t,
        shouldShow: o,
        options: i
      });
      return f.registerPlugin(h), () => {
        f.unregisterPlugin(t), window.requestAnimationFrame(() => {
          d.parentNode && d.parentNode.removeChild(d);
        });
      };
    }, [e, u]), Lh(/* @__PURE__ */ g("div", { ...l, children: s }), c.current);
  }
);
ve.forwardRef(
  ({ pluginKey: t = "floatingMenu", editor: e, shouldShow: n = null, options: r, children: o, ...i }, s) => {
    const l = Nt(document.createElement("div"));
    typeof s == "function" ? s(l.current) : s && (s.current = l.current);
    const { editor: a } = Fc();
    return Zt(() => {
      const c = l.current;
      if (c.style.visibility = "hidden", c.style.position = "absolute", e?.isDestroyed || a?.isDestroyed)
        return;
      const u = e || a;
      if (!u) {
        console.warn(
          "FloatingMenu component is not rendered inside of an editor component or does not have editor prop."
        );
        return;
      }
      const d = cy({
        editor: u,
        element: c,
        pluginKey: t,
        shouldShow: n,
        options: r
      });
      return u.registerPlugin(d), () => {
        u.unregisterPlugin(t), window.requestAnimationFrame(() => {
          c.parentNode && c.parentNode.removeChild(c);
        });
      };
    }, [e, a]), Lh(/* @__PURE__ */ g("div", { ...i, children: o }), l.current);
  }
);
function HT({
  editor: t,
  formats: e
}) {
  return t ? /* @__PURE__ */ g(
    BT,
    {
      editor: t,
      options: { placement: "bottom", offset: 8, flip: !0 },
      children: /* @__PURE__ */ g(St, { children: /* @__PURE__ */ g(xt, { children: /* @__PURE__ */ g(lt, { orientation: "horizontal", children: e.map((n) => /* @__PURE__ */ g(Kt, { type: n, editor: t }, n)) }) }) })
    }
  ) : null;
}
const uy = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ g(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: /* @__PURE__ */ g(
        "path",
        {
          d: "M12.7071 5.70711C13.0976 5.31658 13.0976 4.68342 12.7071 4.29289C12.3166 3.90237 11.6834 3.90237 11.2929 4.29289L4.29289 11.2929C3.90237 11.6834 3.90237 12.3166 4.29289 12.7071L11.2929 19.7071C11.6834 20.0976 12.3166 20.0976 12.7071 19.7071C13.0976 19.3166 13.0976 18.6834 12.7071 18.2929L7.41421 13L19 13C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11L7.41421 11L12.7071 5.70711Z",
          fill: "currentColor"
        }
      )
    }
  )
);
uy.displayName = "ArrowLeftIcon";
var ta, Oh;
function FT() {
  if (Oh) return ta;
  Oh = 1;
  var t = "Expected a function", e = NaN, n = "[object Symbol]", r = /^\s+|\s+$/g, o = /^[-+]0x[0-9a-f]+$/i, i = /^0b[01]+$/i, s = /^0o[0-7]+$/i, l = parseInt, a = typeof Lo == "object" && Lo && Lo.Object === Object && Lo, c = typeof self == "object" && self && self.Object === Object && self, u = a || c || Function("return this")(), d = Object.prototype, f = d.toString, h = Math.max, p = Math.min, m = function() {
    return u.Date.now();
  };
  function b(k, E, M) {
    var N, T, P, _, F, D, W = 0, $ = !1, H = !1, O = !0;
    if (typeof k != "function")
      throw new TypeError(t);
    E = x(E) || 0, v(M) && ($ = !!M.leading, H = "maxWait" in M, P = H ? h(x(M.maxWait) || 0, E) : P, O = "trailing" in M ? !!M.trailing : O);
    function I(oe) {
      var Xe = N, Ft = T;
      return N = T = void 0, W = oe, _ = k.apply(Ft, Xe), _;
    }
    function j(oe) {
      return W = oe, F = setTimeout(te, E), $ ? I(oe) : _;
    }
    function re(oe) {
      var Xe = oe - D, Ft = oe - W, rr = E - Xe;
      return H ? p(rr, P - Ft) : rr;
    }
    function q(oe) {
      var Xe = oe - D, Ft = oe - W;
      return D === void 0 || Xe >= E || Xe < 0 || H && Ft >= P;
    }
    function te() {
      var oe = m();
      if (q(oe))
        return Ye(oe);
      F = setTimeout(te, re(oe));
    }
    function Ye(oe) {
      return F = void 0, O && N ? I(oe) : (N = T = void 0, _);
    }
    function fe() {
      F !== void 0 && clearTimeout(F), W = 0, N = D = T = F = void 0;
    }
    function xe() {
      return F === void 0 ? _ : Ye(m());
    }
    function ne() {
      var oe = m(), Xe = q(oe);
      if (N = arguments, T = this, D = oe, Xe) {
        if (F === void 0)
          return j(D);
        if (H)
          return F = setTimeout(te, E), I(D);
      }
      return F === void 0 && (F = setTimeout(te, E)), _;
    }
    return ne.cancel = fe, ne.flush = xe, ne;
  }
  function C(k, E, M) {
    var N = !0, T = !0;
    if (typeof k != "function")
      throw new TypeError(t);
    return v(M) && (N = "leading" in M ? !!M.leading : N, T = "trailing" in M ? !!M.trailing : T), b(k, E, {
      leading: N,
      maxWait: E,
      trailing: T
    });
  }
  function v(k) {
    var E = typeof k;
    return !!k && (E == "object" || E == "function");
  }
  function S(k) {
    return !!k && typeof k == "object";
  }
  function w(k) {
    return typeof k == "symbol" || S(k) && f.call(k) == n;
  }
  function x(k) {
    if (typeof k == "number")
      return k;
    if (w(k))
      return e;
    if (v(k)) {
      var E = typeof k.valueOf == "function" ? k.valueOf() : k;
      k = v(E) ? E + "" : E;
    }
    if (typeof k != "string")
      return k === 0 ? k : +k;
    k = k.replace(r, "");
    var M = i.test(k);
    return M || s.test(k) ? l(k.slice(2), M ? 2 : 8) : o.test(k) ? e : +k;
  }
  return ta = C, ta;
}
var _T = FT();
const zT = /* @__PURE__ */ Dh(_T), VT = (t) => {
  const e = Nt(t);
  e.current = t, Zt(
    () => () => {
      e.current();
    },
    []
  );
}, $T = {
  leading: !1,
  trailing: !0
};
function dy(t, e = 250, n = [], r = $T) {
  const o = y.useMemo(
    () => zT(t, e, r),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  );
  return VT(() => {
    o.cancel();
  }), o;
}
function fy() {
  const [t, e] = y.useState({
    width: 0,
    height: 0,
    offsetTop: 0,
    offsetLeft: 0,
    scale: 0
  }), n = dy(() => {
    if (typeof window > "u") return;
    const r = window.visualViewport;
    if (!r) return;
    const {
      width: o = 0,
      height: i = 0,
      offsetTop: s = 0,
      offsetLeft: l = 0,
      scale: a = 0
    } = r;
    e((c) => o === c.width && i === c.height && s === c.offsetTop && l === c.offsetLeft && a === c.scale ? c : { width: o, height: i, offsetTop: s, offsetLeft: l, scale: a });
  }, 200);
  return y.useEffect(() => {
    const r = window.visualViewport;
    if (r)
      return r.addEventListener("resize", n), n(), () => {
        r.removeEventListener("resize", n);
      };
  }, [n]), t;
}
const oi = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
}, hy = typeof window > "u", UT = !hy && typeof ResizeObserver < "u", gi = () => !hy;
function WT({
  element: t,
  enabled: e = !0,
  throttleMs: n = 100,
  useResizeObserver: r = !0
} = {}) {
  const [o, i] = y.useState(oi), s = y.useCallback(() => !e || !gi() ? null : t ? typeof t == "string" ? document.querySelector(t) : "current" in t ? t.current : t : document.body, [t, e]), l = dy(
    () => {
      if (!e || !gi()) return;
      const a = s();
      if (!a) {
        i(oi);
        return;
      }
      const c = a.getBoundingClientRect();
      i({
        x: c.x,
        y: c.y,
        width: c.width,
        height: c.height,
        top: c.top,
        right: c.right,
        bottom: c.bottom,
        left: c.left
      });
    },
    n,
    [e, s],
    { leading: !0, trailing: !0 }
  );
  return y.useEffect(() => {
    if (!e || !gi()) {
      i(oi);
      return;
    }
    const a = s();
    if (!a) return;
    l();
    const c = [];
    if (r && UT) {
      const d = new ResizeObserver(() => {
        window.requestAnimationFrame(l);
      });
      d.observe(a), c.push(() => d.disconnect());
    }
    const u = () => l();
    return window.addEventListener("scroll", u, { passive: !0 }), window.addEventListener("resize", u, { passive: !0 }), c.push(() => {
      window.removeEventListener("scroll", u), window.removeEventListener("resize", u);
    }), () => {
      c.forEach((d) => d()), i(oi);
    };
  }, [e, s, l, r]), o;
}
function KT(t = {}) {
  return WT({
    ...t,
    element: gi() ? document.body : null
  });
}
function jT({
  editor: t,
  overlayHeight: e = 0
}) {
  const { height: n } = fy(), r = KT({
    enabled: !0,
    throttleMs: 100,
    useResizeObserver: !0
  });
  return y.useEffect(() => {
    (() => {
      if (!t) return;
      const { state: i, view: s } = t;
      if (!s.hasFocus()) return;
      const { from: l } = i.selection, a = s.coordsAtPos(l);
      if (n < r.height && a && n - a.top < e) {
        const u = Math.max(n / 2, e), d = window.scrollY, h = a.top + d - u;
        window.scrollTo({
          top: Math.max(0, h),
          behavior: "smooth"
        });
      }
    })();
  }, [t, e, n, r.height]), r;
}
const py = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 11.5955 21.7564 11.2309 21.3827 11.0761C21.009 10.9213 20.5789 11.0069 20.2929 11.2929C19.287 12.2988 17.9226 12.864 16.5 12.864C15.0774 12.864 13.713 12.2988 12.7071 11.2929C11.7012 10.287 11.136 8.92261 11.136 7.5C11.136 6.07739 11.7012 4.71304 12.7071 3.70711C12.9931 3.42111 13.0787 2.99099 12.9239 2.61732C12.7691 2.24364 12.4045 2 12 2ZM7.55544 5.34824C8.27036 4.87055 9.05353 4.51389 9.87357 4.28778C9.39271 5.27979 9.13604 6.37666 9.13604 7.5C9.13604 9.45304 9.91189 11.3261 11.2929 12.7071C12.6739 14.0881 14.547 14.864 16.5 14.864C17.6233 14.864 18.7202 14.6073 19.7122 14.1264C19.4861 14.9465 19.1295 15.7296 18.6518 16.4446C17.7727 17.7602 16.5233 18.7855 15.0615 19.391C13.5997 19.9965 11.9911 20.155 10.4393 19.8463C8.88743 19.5376 7.46197 18.7757 6.34315 17.6569C5.22433 16.538 4.4624 15.1126 4.15372 13.5607C3.84504 12.0089 4.00347 10.4003 4.60897 8.93853C5.21447 7.47672 6.23985 6.22729 7.55544 5.34824Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M19 2C19.5523 2 20 2.44772 20 3V4H21C21.5523 4 22 4.44772 22 5C22 5.55228 21.5523 6 21 6H20V7C20 7.55228 19.5523 8 19 8C18.4477 8 18 7.55228 18 7V6H17C16.4477 6 16 5.55228 16 5C16 4.44772 16.4477 4 17 4H18V3C18 2.44772 18.4477 2 19 2Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
py.displayName = "MoonStarIcon";
const my = y.memo(
  ({ className: t, ...e }) => /* @__PURE__ */ R(
    "svg",
    {
      width: "24",
      height: "24",
      className: t,
      viewBox: "0 0 24 24",
      fill: "currentColor",
      xmlns: "http://www.w3.org/2000/svg",
      ...e,
      children: [
        /* @__PURE__ */ g(
          "path",
          {
            d: "M12 1C12.5523 1 13 1.44772 13 2V4C13 4.55228 12.5523 5 12 5C11.4477 5 11 4.55228 11 4V2C11 1.44772 11.4477 1 12 1Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M7 12C7 9.23858 9.23858 7 12 7C14.7614 7 17 9.23858 17 12C17 14.7614 14.7614 17 12 17C9.23858 17 7 14.7614 7 12ZM12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M13 20C13 19.4477 12.5523 19 12 19C11.4477 19 11 19.4477 11 20V22C11 22.5523 11.4477 23 12 23C12.5523 23 13 22.5523 13 22V20Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M4.22282 4.22289C4.61335 3.83236 5.24651 3.83236 5.63704 4.22289L7.04704 5.63289C7.43756 6.02341 7.43756 6.65658 7.04704 7.0471C6.65651 7.43762 6.02335 7.43762 5.63283 7.0471L4.22282 5.6371C3.8323 5.24658 3.8323 4.61341 4.22282 4.22289Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M18.367 16.9529C17.9765 16.5623 17.3433 16.5623 16.9528 16.9529C16.5623 17.3434 16.5623 17.9766 16.9528 18.3671L18.3628 19.7771C18.7533 20.1676 19.3865 20.1676 19.777 19.7771C20.1675 19.3866 20.1675 18.7534 19.777 18.3629L18.367 16.9529Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M1 12C1 11.4477 1.44772 11 2 11H4C4.55228 11 5 11.4477 5 12C5 12.5523 4.55228 13 4 13H2C1.44772 13 1 12.5523 1 12Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M20 11C19.4477 11 19 11.4477 19 12C19 12.5523 19.4477 13 20 13H22C22.5523 13 23 12.5523 23 12C23 11.4477 22.5523 11 22 11H20Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M7.04704 16.9529C7.43756 17.3434 7.43756 17.9766 7.04704 18.3671L5.63704 19.7771C5.24651 20.1676 4.61335 20.1676 4.22282 19.7771C3.8323 19.3866 3.8323 18.7534 4.22283 18.3629L5.63283 16.9529C6.02335 16.5623 6.65651 16.5623 7.04704 16.9529Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ g(
          "path",
          {
            d: "M19.777 5.6371C20.1675 5.24657 20.1675 4.61341 19.777 4.22289C19.3865 3.83236 18.7533 3.83236 18.3628 4.22289L16.9528 5.63289C16.5623 6.02341 16.5623 6.65658 16.9528 7.0471C17.3433 7.43762 17.9765 7.43762 18.367 7.0471L19.777 5.6371Z",
            fill: "currentColor"
          }
        )
      ]
    }
  )
);
my.displayName = "SunIcon";
function qT() {
  const [t, e] = y.useState(!1);
  return y.useEffect(() => {
    const r = window.matchMedia("(prefers-color-scheme: dark)"), o = () => e(r.matches);
    return r.addEventListener("change", o), () => r.removeEventListener("change", o);
  }, []), y.useEffect(() => {
    const r = !!document.querySelector('meta[name="color-scheme"][content="dark"]') || window.matchMedia("(prefers-color-scheme: dark)").matches;
    e(r);
  }, []), y.useEffect(() => {
    document.documentElement.classList.toggle("dark", t);
  }, [t]), /* @__PURE__ */ g(
    J,
    {
      onClick: () => e((r) => !r),
      "aria-label": `Switch to ${t ? "light" : "dark"} mode`,
      "data-style": "ghost",
      children: t ? /* @__PURE__ */ g(py, { className: "tiptap-button-icon" }) : /* @__PURE__ */ g(my, { className: "tiptap-button-icon" })
    }
  );
}
const GT = {
  formatting: {
    bold: !0,
    italic: !0,
    underline: !0,
    strike: !0,
    code: !0,
    superscript: !0,
    subscript: !0
  },
  blocks: {
    headings: [1, 2, 3, 4, 5, 6],
    lists: ["bulletList", "orderedList", "taskList"],
    blockquote: !0,
    codeBlock: !0,
    horizontalRule: !0,
    pageBreak: !0
  },
  media: {
    images: !0,
    imageUpload: !0
  },
  alignment: {
    types: ["left", "center", "right", "justify"]
  },
  highlighting: !0,
  links: !0,
  tables: !0,
  tableOfContents: !0,
  textColor: !0,
  textSize: !0,
  undoRedo: !0
}, ZT = {
  toolbar: !0,
  toolbarPosition: "top",
  theme: "auto",
  themeToggle: !0
}, JT = ({
  features: t,
  onHighlighterClick: e,
  onLinkClick: n,
  onTextColorClick: r,
  isMobile: o
}) => {
  const i = t.undoRedo, s = t.blocks?.headings && t.blocks.headings.length > 0, l = t.blocks?.lists && t.blocks.lists.length > 0, a = t.blocks?.blockquote, c = t.blocks?.codeBlock, u = t.blocks?.pageBreak, d = t.formatting && Object.values(t.formatting).some(Boolean), f = t.highlighting, h = t.textColor, p = t.textSize, m = t.links, b = t.alignment?.types && t.alignment.types.length > 0, C = t.media?.imageUpload, v = t.tables, S = t.tableOfContents;
  return /* @__PURE__ */ R(le, { children: [
    /* @__PURE__ */ g(hh, {}),
    i && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        /* @__PURE__ */ g(oc, { action: "undo" }),
        /* @__PURE__ */ g(oc, { action: "redo" })
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    (s || l || a || c) && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        s && /* @__PURE__ */ g(
          J0,
          {
            levels: t.blocks.headings,
            portal: o
          }
        ),
        l && /* @__PURE__ */ g(
          c6,
          {
            types: t.blocks.lists,
            portal: o
          }
        ),
        a && /* @__PURE__ */ g(i2, {}),
        c && /* @__PURE__ */ g(a2, {})
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    d && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        t.formatting.bold && /* @__PURE__ */ g(Kt, { type: "bold" }),
        t.formatting.italic && /* @__PURE__ */ g(Kt, { type: "italic" }),
        t.formatting.strike && /* @__PURE__ */ g(Kt, { type: "strike" }),
        t.formatting.code && /* @__PURE__ */ g(Kt, { type: "code" }),
        t.formatting.underline && /* @__PURE__ */ g(Kt, { type: "underline" }),
        h && (o ? /* @__PURE__ */ g(Wu, { onClick: r }) : /* @__PURE__ */ g(M2, {})),
        f && (o ? /* @__PURE__ */ g(Vu, { onClick: e }) : /* @__PURE__ */ g(V6, {})),
        p && /* @__PURE__ */ g(N2, {}),
        m && (o ? /* @__PURE__ */ g(qu, { onClick: n }) : /* @__PURE__ */ g(H2, {}))
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    (t.formatting?.superscript || t.formatting?.subscript) && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        t.formatting.superscript && /* @__PURE__ */ g(Kt, { type: "superscript" }),
        t.formatting.subscript && /* @__PURE__ */ g(Kt, { type: "subscript" })
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    b && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ g(Mt, { children: t.alignment.types.map((w) => /* @__PURE__ */ g(Z2, { align: w }, w)) }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    (C || v) && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        C && /* @__PURE__ */ g(lT, { text: "Add" }),
        v && /* @__PURE__ */ g(o2, { portal: o })
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    (u || S) && /* @__PURE__ */ R(le, { children: [
      /* @__PURE__ */ R(Mt, { children: [
        u && /* @__PURE__ */ g(oy, {}),
        S && /* @__PURE__ */ g(ly, {})
      ] }),
      /* @__PURE__ */ g(Tt, {})
    ] }),
    /* @__PURE__ */ g(hh, {}),
    o && /* @__PURE__ */ g(Tt, {}),
    /* @__PURE__ */ g(Mt, { children: /* @__PURE__ */ g(qT, {}) })
  ] });
}, YT = ({
  type: t,
  onBack: e
}) => /* @__PURE__ */ R(le, { children: [
  /* @__PURE__ */ g(Mt, { children: /* @__PURE__ */ R(J, { "data-style": "ghost", onClick: e, children: [
    /* @__PURE__ */ g(uy, { className: "tiptap-button-icon" }),
    t === "highlighter" ? /* @__PURE__ */ g(Ys, { className: "tiptap-button-icon" }) : t === "textColor" ? /* @__PURE__ */ g($u, { className: "tiptap-button-icon" }) : /* @__PURE__ */ g(nl, { className: "tiptap-button-icon" })
  ] }) }),
  /* @__PURE__ */ g(Tt, {}),
  t === "highlighter" ? /* @__PURE__ */ g(x2, {}) : t === "textColor" ? /* @__PURE__ */ g(E2, {}) : /* @__PURE__ */ g(Y6, {})
] });
function rl({ config: t }) {
  const e = ut(), { height: n } = fy(), [r, o] = y.useState("main"), i = y.useRef(null), s = { ...GT, ...t.features }, l = { ...ZT, ...t.ui }, a = y.useMemo(() => {
    const h = [], p = {
      horizontalRule: !1
    };
    if (s.links ? p.link = {
      openOnClick: !1,
      enableClickSelection: !0
    } : p.link = !1, s.blocks?.blockquote || (p.blockquote = !1), s.blocks?.codeBlock || (p.codeBlock = !1), s.formatting?.bold || (p.bold = !1), s.formatting?.italic || (p.italic = !1), s.formatting?.strike || (p.strike = !1), s.formatting?.code || (p.code = !1), s.blocks?.lists?.includes("bulletList") || (p.bulletList = !1), s.blocks?.lists?.includes("orderedList") || (p.orderedList = !1), s.blocks?.headings && s.blocks.headings.length > 0 ? p.heading = {
      levels: s.blocks.headings
    } : p.heading = !1, h.push(d5.configure(p)), s.blocks?.horizontalRule && h.push(R9), s.alignment?.types && s.alignment.types.length > 0 && h.push(p5.configure({ types: ["heading", "paragraph"] })), s.blocks?.lists?.includes("taskList") && h.push(f1, d1.configure({ nested: !0 })), s.highlighting && h.push(z5.configure({ multicolor: !0 })), s.media?.images && h.push(
      h5.configure({
        inline: !0,
        allowBase64: !0,
        HTMLAttributes: {
          class: "tiptap-image"
        }
      })
    ), s.formatting?.superscript && h.push($5), s.formatting?.subscript && h.push(V5), s.formatting?.underline && h.push(h1), (s.textColor || s.textSize) && h.push(I1), s.textColor && h.push(L1), s.textSize && h.push(J3), s.blocks?.pageBreak && h.push(O9), s.tableOfContents && h.push(I9), s.media?.imageUpload && h.push(
      T9.configure({
        accept: "image/*",
        maxSize: t.maxFileSize ?? ja,
        limit: 3,
        upload: t.onImageUpload ?? c9,
        onError: (m) => console.error("Upload failed:", m)
      })
    ), s.tables) {
      const m = N1.extend({
        addOptions: {
          resizable: !0
        },
        addNodeView() {
          return Ds(y9);
        }
      });
      h.push(m, O1, A1, R1);
    }
    return h.push(H5, a5), h;
  }, [s, t.maxFileSize, t.onImageUpload]), c = O7({
    immediatelyRender: !1,
    shouldRerenderOnTransaction: !1,
    editable: t.editable ?? !0,
    editorProps: {
      attributes: {
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        "aria-label": t.placeholder ?? "Main content area, start typing to enter text.",
        class: `postedin-editor ${t.className ?? ""}`.trim()
      }
    },
    extensions: a,
    content: t.content,
    onUpdate: ({ editor: h }) => {
      t.onChange && t.onChange(h.getJSON());
    },
    onCreate: ({ editor: h }) => {
      t.onEditor && t.onEditor(h);
    }
  }), u = jT({
    editor: c,
    overlayHeight: i.current?.getBoundingClientRect().height ?? 0
  });
  y.useEffect(() => {
    !e && r !== "main" && o("main");
  }, [e, r]);
  const d = l.toolbar && t.editable !== !1, f = s.formatting ? Object.entries(s.formatting).map(([h, p]) => p ? h : null).filter(Boolean) : [];
  return /* @__PURE__ */ g("div", { className: "postedin-editor-wrapper", children: /* @__PURE__ */ R(Hc.Provider, { value: { editor: c }, children: [
    d && /* @__PURE__ */ g(
      mg,
      {
        ref: i,
        style: {
          ...e ? {
            bottom: `calc(100% - ${n - u.y}px)`
          } : {}
        },
        children: r === "main" ? /* @__PURE__ */ g(
          JT,
          {
            features: s,
            onHighlighterClick: () => o("highlighter"),
            onLinkClick: () => o("link"),
            onTextColorClick: () => o("textColor"),
            isMobile: e
          }
        ) : /* @__PURE__ */ g(
          YT,
          {
            type: r,
            onBack: () => o("main")
          }
        )
      }
    ),
    s && /* @__PURE__ */ g(HT, { editor: c, formats: f }),
    /* @__PURE__ */ g(
      E7,
      {
        editor: c,
        role: "presentation",
        className: "postedin-editor-content"
      }
    )
  ] }) });
}
function s8(t) {
  const e = {
    features: {
      formatting: {
        bold: !0,
        italic: !0,
        underline: !0,
        strike: !0,
        code: !0,
        superscript: !0,
        subscript: !0
      },
      blocks: {
        headings: [1, 2, 3, 4, 5, 6],
        lists: ["bulletList", "orderedList", "taskList"],
        blockquote: !0,
        codeBlock: !0,
        horizontalRule: !0,
        pageBreak: !0
      },
      media: {
        images: !0,
        imageUpload: !0
      },
      alignment: {
        types: ["left", "center", "right", "justify"]
      },
      highlighting: !0,
      tableOfContents: !0,
      textColor: !0,
      textSize: !0,
      links: !0,
      tables: !0,
      undoRedo: !0,
      ...t.features
    },
    ui: {
      toolbar: !0,
      toolbarPosition: "top",
      themeToggle: !0,
      ...t.ui
    },
    className: `full-editor ${t.className || ""}`.trim(),
    ...t
  };
  return /* @__PURE__ */ g(rl, { config: e });
}
function l8(t) {
  const e = {
    features: {
      formatting: {
        bold: !0,
        italic: !0,
        strike: !0,
        code: !1,
        underline: !1,
        superscript: !1,
        subscript: !1
      },
      blocks: {
        headings: [2, 3, 4],
        lists: ["bulletList", "orderedList"],
        blockquote: !1,
        codeBlock: !1,
        horizontalRule: !1
      },
      media: {
        images: !0,
        imageUpload: !1
      },
      alignment: {
        types: ["left", "center"]
      },
      highlighting: !1,
      links: !0,
      tables: !1,
      undoRedo: !0,
      ...t.features
    },
    ui: {
      toolbar: !0,
      toolbarPosition: "top",
      themeToggle: !1,
      ...t.ui
    },
    className: `standard-editor ${t.className || ""}`.trim(),
    ...t
  };
  return /* @__PURE__ */ g(rl, { config: e });
}
function a8(t) {
  const e = {
    features: {
      formatting: {
        bold: !0,
        italic: !0,
        strike: !1,
        code: !1,
        underline: !1,
        superscript: !1,
        subscript: !1
      },
      blocks: {
        headings: [],
        lists: ["bulletList"],
        blockquote: !1,
        codeBlock: !1,
        horizontalRule: !1
      },
      media: {
        images: !1,
        imageUpload: !1
      },
      alignment: {
        types: []
      },
      highlighting: !1,
      links: !0,
      tables: !1,
      undoRedo: !0,
      ...t.features
    },
    ui: {
      toolbar: !0,
      toolbarPosition: "bottom",
      themeToggle: !1,
      ...t.ui
    },
    className: `minimal-editor ${t.className || ""}`.trim(),
    ...t
  };
  return /* @__PURE__ */ g(rl, { config: e });
}
function c8(t) {
  const e = {
    features: {
      // Enable all features for display purposes
      formatting: {
        bold: !0,
        italic: !0,
        underline: !0,
        strike: !0,
        code: !0,
        superscript: !0,
        subscript: !0
      },
      blocks: {
        headings: [1, 2, 3, 4, 5, 6],
        lists: ["bulletList", "orderedList", "taskList"],
        blockquote: !0,
        codeBlock: !0,
        horizontalRule: !0
      },
      media: {
        images: !0,
        imageUpload: !1
      },
      alignment: {
        types: ["left", "center", "right", "justify"]
      },
      highlighting: !0,
      links: !0,
      tables: !0,
      undoRedo: !1,
      ...t.features
    },
    ui: {
      toolbar: !1,
      themeToggle: !1,
      ...t.ui
    },
    editable: !1,
    className: `display-editor ${t.className || ""}`.trim(),
    ...t
  };
  return /* @__PURE__ */ g(rl, { config: e });
}
export {
  c8 as DisplayEditor,
  s8 as FullEditor,
  a8 as MinimalEditor,
  rl as PostedinEditor,
  l8 as StandardEditor
};
